import{k as a,m as n,p as r,w as d,d as _}from"./index-DXDxuD1W.js";function A(e){const t=String(e??"").toUpperCase();return t==="MIS"||t==="NRML"||t==="CNC"?t:"MIS"}async function l(){const e=_.getState().apiKey;if(e)return e;try{const s=await(await fetch("/api/websocket/apikey",{credentials:"include"})).json();if(s.status==="success"&&s.api_key)return _.getState().setApiKey(s.api_key),s.api_key}catch{}return null}const k={getQuotes:async(e,t,s)=>n()?r("feed","quotes",{apikey:e,symbol:t,exchange:s}):(await a.post("/quotes",{apikey:e,symbol:t,exchange:s})).data,getMultiQuotes:async(e,t)=>n()?r("feed","multiquotes",{apikey:e,symbols:t}):(await a.post("/multiquotes",{apikey:e,symbols:t})).data,getHistory:async(e,t,s,o,i,p,c="api")=>n()?r("feed","history",{apikey:e,symbol:t,exchange:s,interval:o,start_date:i,end_date:p,source:c}):(await a.post("/history",{apikey:e,symbol:t,exchange:s,interval:o,start_date:i,end_date:p,source:c})).data,getDepth:async(e,t,s)=>n()?r("feed","depth",{apikey:e,symbol:t,exchange:s}):(await a.post("/depth",{apikey:e,symbol:t,exchange:s})).data,getFunds:async e=>n()?r("execution","funds",{apikey:e}):(await a.post("/funds",{apikey:e})).data,getPositions:async e=>n()?r("execution","positionbook",{apikey:e}):(await a.post("/positionbook",{apikey:e})).data,getOrders:async e=>n()?r("execution","orderbook",{apikey:e}):(await a.post("/orderbook",{apikey:e})).data,getTrades:async e=>n()?r("execution","tradebook",{apikey:e}):(await a.post("/tradebook",{apikey:e})).data,getHoldings:async e=>n()?r("execution","holdings",{apikey:e}):(await a.post("/holdings",{apikey:e})).data,placeOrder:async e=>n()?r("execution","placeorder",e):(await a.post("/placeorder",e)).data,modifyOrder:async(e,t)=>{if(n()){const o=await l();return o?r("execution","modifyorder",{apikey:o,strategy:"Scalping",orderid:e,symbol:t.symbol,exchange:t.exchange,action:t.action,product:t.product,pricetype:t.pricetype,price:t.price,quantity:t.quantity,disclosed_quantity:t.disclosed_quantity??0,trigger_price:t.trigger_price??0}):{status:"error",message:"Missing API key"}}return(await d.post("/modify_order",{orderid:e,...t})).data},cancelOrder:async e=>{if(n()){const s=await l();return s?r("execution","cancelorder",{apikey:s,strategy:"Scalping",orderid:e}):{status:"error",message:"Missing API key"}}return(await d.post("/cancel_order",{orderid:e})).data},closePosition:async(e,t,s)=>{if(n()){const i=await l();if(!i)return{status:"error",message:"Missing API key"};const p=await k.getPositions(i),u=(Array.isArray(p.data)?p.data:[]).find(f=>{const q=Number(f.quantity)||0;return f.symbol===e&&f.exchange===t&&f.product===s&&q!==0});if(!u)return{status:"success",message:"No open position to close"};const y=Number(u.quantity)||0,g=Math.abs(y);if(g<=0)return{status:"success",message:"No open position to close"};const w=y>0?"SELL":"BUY",m=await k.placeOrder({apikey:i,strategy:"Scalping",exchange:t,symbol:e,action:w,quantity:g,pricetype:"MARKET",product:A(s),price:0,trigger_price:0,disclosed_quantity:0});return{status:m.status,message:m.message}}return(await d.post("/close_position",{symbol:e,exchange:t,product:s})).data},closeAllPositions:async()=>{if(n()){const t=await l();if(!t)return{status:"error",message:"Missing API key"};const s=await k.getPositions(t),i=(Array.isArray(s.data)?s.data:[]).filter(c=>(Number(c.quantity)||0)!==0);if(!i.length)return{status:"success",message:"No open positions to close"};let p=0;for(const c of i){const u=Number(c.quantity)||0,y=Math.abs(u);if(y<=0)continue;const g=u>0?"SELL":"BUY";(await k.placeOrder({apikey:t,strategy:"Scalping",exchange:c.exchange,symbol:c.symbol,action:g,quantity:y,pricetype:"MARKET",product:A(c.product),price:0,trigger_price:0,disclosed_quantity:0})).status!=="success"&&(p+=1)}return p>0?{status:"error",message:`Failed to close ${p} position(s)`}:{status:"success",message:"All positions closed"}}return(await d.post("/close_all_positions",{})).data},cancelAllOrders:async()=>{if(n()){const t=await l();return t?r("execution","cancelallorder",{apikey:t,strategy:"Scalping"}):{status:"error",message:"Missing API key"}}return(await d.post("/cancel_all_orders",{})).data},getScalpingBridgePending:async(e,t=50)=>(await a.post("/scalpingbridge/pending",{apikey:e,limit:t})).data,ackScalpingBridgeEntries:async(e,t)=>{const s=t.map(i=>Number(i)).filter(i=>Number.isInteger(i)&&i>0);return(await a.post("/scalpingbridge/ack",{apikey:e,ids:s})).data}};export{k as t};
