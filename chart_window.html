<!DOCTYPE html>
<!--
╔══════════════════════════════════════════════════════════════════════╗
║                    CHART WINDOW ARCHITECTURE MAP                     ║
║                                                                      ║
║  Self-contained chart trading page (~4100 lines).                    ║
║  Opened as popup from scalping interface. Receives symbol,           ║
║  exchange, API key, lot size via URL params.                         ║
╚══════════════════════════════════════════════════════════════════════╝

STATE OBJECT (const state = {...})
  Core:     symbol, exchange, underlying, optionType, strike, expiry
  Config:   apiKey, quantity, lotSize, orderType ('MARKET'|'LIMIT'|'FAKELIMIT')
  Chart:    chart, candlestickSeries, currentPrice, candles[], pendingCandle
  Orders:   orders Map (orderId → {orderId, action, price, status, priceLine, overlay})
  Triggers: fakeLimitOrders Map (id → {action, triggerPrice, direction, priceLine, overlay, tpPoints, slPoints})
  Position: position, entryPrice, isClosingPosition
  Follow:   followingMode, followingType
  TP/SL:    tpPoints (default 5), slPoints (default 8)
  Profit:   profitProtectionEnabled, securedProfit, highestPnl, totalPnl

KEY GLOBALS (outside state)
  positionTPSL    = {tpPrice, slPrice, tpLine, slLine, tpOverlay, slOverlay}
  positionOverlay = HTML div for the position line
  followPriceLine = chart price line that follows cursor in LIMIT/TRIGGER mode
  openOrdersData  = array from /api/v1/openorders (for orders panel)

SECTIONS & KEY FUNCTIONS (search by name with Grep)
─────────────────────────────────────────────────────
CSS STYLES ............................................. lines 8-970
  .order-line-overlay, .order-close-btn, .trigger-buy/.trigger-sell
  .order-type-btn.active / .active-trigger

HTML LAYOUT ............................................ lines 870-970
  Row 1: Symbol + Price | Row 2: Market context badges
  Row 4: BUY | SELL | MARKET | LIMIT | TRIGGER | Qty ±  | TP [] SL []
  Row 5: Position info + Close button + Profit Protection

INIT & CONFIG .......................................... ~995-1100
  roundToTick(price)       — snap to 0.05 tick
  parseUrlParams()         — reads symbol/exchange/apikey/lotsize from URL
  initChart()              — creates Lightweight Charts instance + indicators

UI SETUP ............................................... ~1195-1340
  updatePnL(), showToast()
  setupEventListeners()    — button handlers, qty ±, TP/SL inputs
  setOrderType(type)       — three-way toggle: MARKET/LIMIT/FAKELIMIT

INTERACTIVE ORDER PLACEMENT ............................ ~1338-1420
  enableFollowMode(action) — creates dashed follow line (green/red/orange)
  disableFollowMode()
  setupChartInteraction()  — subscribeCrosshairMove + subscribeClick
  placeMarketOrder(action) — immediate MARKET at current price
  placeOrderAtPrice(price, action) — POST /api/v1/placeorder, draws order line

FAKE LIMIT (TRIGGER ORDERS) ............................ ~1504-1738
  placeFakeLimitOrder(triggerPrice, action) — stores virtual trigger in Map
  drawFakeLimitLine(price, action, id)     — orange dashed line + overlay
  setupFakeLimitDraggable(overlay, id)     — drag = local only, no API
  cancelFakeLimitOrder(id)                 — remove line + overlay + Map entry
  checkFakeLimitTriggers()                 — called every tick; BUY fires at ltp>=trigger, SELL at ltp<=trigger
  executeFakeLimitOrder(id, order)         — fires MARKET order, draws order line

ORDER LINE MANAGEMENT .................................. ~1740-1930
  drawOrderLine(price, action, orderId) — chart priceLine + HTML overlay + state.orders
  updateOverlayPosition(overlay, price) — keeps overlay at correct Y
  updateAllOverlays()      — repositions all overlays on scroll/resize
  setupDraggable(overlay, orderData) — drag-to-modify with API call
  modifyOrder(orderId, newPrice)     — POST /api/v1/modifyorder

POSITION MANAGEMENT .................................... ~2082-2120
  closeOrder(orderId)      — cancel via /api/v1/cancelorder
  closeAllPositions()      — cancels all orders + fake limits
  updateLivePNL()          — recalculates P&L labels per tick

WEBSOCKET .............................................. ~2144-2210
  connectWebSocket()       — auth → subscribe → handle messages
  handleMarketData(data)   — updates currentPrice, builds candles, calls:
    → updateIndicators(), updateLivePNL(), checkVirtualTPSL(), checkFakeLimitTriggers()

TECHNICAL INDICATORS ................................... ~2209-2356
  calculateEMA(candles, period)
  calculateSupertrend(candles, atrPeriod, mult)
  calculateVWAP(candles)
  updateIndicators()       — redraws EMA9/21, Supertrend, VWAP on chart

VIRTUAL TP/SL (POSITION MONITORING) .................... ~2424-2510
  checkVirtualTPSL()       — checks if price crossed TP/SL levels
  executeVirtualTPSL(type, triggerPrice) — MARKET close + cleanup

OPEN ORDERS PANEL ...................................... ~2512-2700
  toggleOrdersPanel(), fetchOpenOrders(), renderOpenOrders()
  cancelSingleOrder(orderId, symbol)
  removeOrderLineFromChart(orderId)
  closeAllOpenOrders()

ORDER FILL DETECTION ................................... ~2773-2880
  checkOrderFills()        — polls /api/v1/orderbook every 5s
    → detects fills → calculates auto TP/SL → calls fetchAndDisplayPosition()

POSITION DISPLAY + TP/SL LINES ......................... ~2881-3300
  fetchAndDisplayPosition(tpslData) — gets position from /api/v1/positionbook
  updatePositionDisplay(position, tpslData)
  drawPositionLine(entryPrice, action, tpslData) — position line + TP/SL lines
  createTPSLOverlay(price, type, parentAction)   — draggable TP/SL line overlay
  setupTPSLDraggable(overlay, type, parentAction)
  removePositionTPSL(type)
  closePosition()          — POST MARKET close + cancel TP/SL + clear visuals
  cancelTPSLOrders()       — clears TP/SL visual elements
  clearPositionVisuals()   — removes all position-related overlays

PROFIT PROTECTION ...................................... ~3368-3520
  toggleProfitProtection(), checkProfitProtection()
  closePositionAuto(reason), resetProfitProtection()

QUICK ENTRY PRESETS .................................... ~3519-3570

MARKET CONTEXT ......................................... ~3570-3630

CONNECTION HEALTH ...................................... ~3631-3700
  updateConnectionHealth(type, latency)
  fetchWithRetry(url, options, maxRetries)
  Price staleness: updatePriceTimestamp(), getPriceStaleness(), isPriceStale()

ORDER VALIDATION ....................................... ~3738-3800
  validateOrder(orderData, currentPrice)

AUDIT TRAIL ............................................ ~3795-3880
  logAuditEntry(), logOrderPlaced(), logPositionClosed()
  exportAuditTrail(), loadAuditTrail()

PSYCHOLOGY SUPPORT ..................................... ~3880-4090
  analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition)
  checkLossAversion(currentPnl), showLossWarning(), hideLossWarning()

INITIALIZATION ......................................... ~4094
  init()                   — parseUrlParams → initChart → connectWebSocket → start intervals

DATA FLOWS
──────────
  Order Placement:  B/S key → enableFollowMode → click → placeOrderAtPrice → drawOrderLine
  Trigger Order:    B/S key → enableFollowMode → click → placeFakeLimitOrder → drawFakeLimitLine
  Trigger Fire:     tick → checkFakeLimitTriggers → executeFakeLimitOrder → MARKET order → drawOrderLine
  Fill Detection:   5s poll → checkOrderFills → detect fill → auto TP/SL calc → fetchAndDisplayPosition
  TP/SL Trigger:    tick → checkVirtualTPSL → executeVirtualTPSL → MARKET close → clearPositionVisuals
  Price Updates:    WS tick → handleMarketData → build candle → updateIndicators → updateLivePNL
  Profit Protect:   tick → checkProfitProtection → closePositionAuto if profit drops below secured level
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Window - OpenAlgo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0b0f14;
            --bg-secondary: #121821;
            --bg-card: rgba(18, 24, 33, 0.92);
            --panel-bg: rgba(14, 19, 26, 0.94);
            --text-primary: #f5f7fb;
            --text-secondary: #9aa8b6;
            --border-color: rgba(143, 162, 182, 0.2);
            --success: #57f59a;
            --danger: #ff6b6b;
            --warning: #ffb020;
            --accent-cyan: #53f2d6;
            --accent-lime: #c7f55d;
            --accent-blue: #5ab0ff;
            --dock-width: 300px;
            --shadow-tight: 0 10px 24px rgba(6, 9, 14, 0.35);
            --border: var(--border-color);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', 'Bahnschrift', 'Segoe UI', sans-serif;
            background:
                radial-gradient(900px 600px at 5% -10%, rgba(83, 242, 214, 0.14), transparent 45%),
                radial-gradient(900px 600px at 95% 0%, rgba(255, 180, 67, 0.16), transparent 45%),
                linear-gradient(160deg, var(--bg-primary) 0%, #0f1723 100%);
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
            overflow: hidden;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--dock-width);
            height: 100vh;
            background: #0e131a;
            border-right: 1px solid var(--border-color);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            overflow-y: auto;
            contain: layout paint;
            scrollbar-gutter: stable;
            transform: translateZ(0);
        }

        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(83, 242, 214, 0.25);
            border-radius: 999px;
        }

        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .scalp-radar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .scalp-radar-title {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scalp-radar-meter {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .radar-toggle-btn {
            padding: 3px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 9px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .radar-toggle-btn.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.45);
            background: rgba(0, 255, 136, 0.12);
        }

        .scalp-radar.off .scalp-radar-fill {
            width: 0% !important;
        }

        .scalp-radar.off .scalp-radar-label {
            color: var(--text-secondary);
        }

        .scalp-radar-bar {
            width: 110px;
            height: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .scalp-radar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(0, 255, 136, 0.4) 0%, rgba(255, 210, 63, 0.6) 60%, rgba(255, 107, 107, 0.6) 100%);
            transition: width 0.12s ease;
        }

        .scalp-radar-label {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .scalp-radar-label.hot {
            color: var(--success);
        }

        .scalp-radar-label.warm {
            color: var(--warning);
        }

        .scalp-radar-label.cool {
            color: var(--text-secondary);
        }

        .scalp-radar-value {
            font-size: 9px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .symbol-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .current-price {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .current-price .price-value {
            display: inline-block;
            min-width: 70px;
        }

        .side-badge {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.4px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-secondary);
        }

        .side-badge.ce {
            border-color: rgba(83, 242, 214, 0.6);
            color: var(--accent-cyan);
        }

        .side-badge.pe {
            border-color: rgba(255, 176, 32, 0.6);
            color: var(--warning);
        }

        .price-positive {
            color: var(--success);
        }

        .price-negative {
            color: var(--danger);
        }

        .controls-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .dock-section {
            background: #121821;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: var(--shadow-tight);
        }

        .depth-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .depth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .depth-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .depth-meta {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-status {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-status.live {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .depth-symbol {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .depth-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .depth-level-select,
        .depth-toggle {
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 9px;
            cursor: pointer;
        }

        .depth-toggle.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-summary {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-summary span {
            display: block;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-table {
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
        }

        .depth-header-row,
        .depth-row {
            display: grid;
            grid-template-columns: 1.1fr 1fr 1fr 1.1fr;
            gap: 6px;
            padding: 5px 8px;
            font-size: 9px;
            font-variant-numeric: tabular-nums;
        }

        .depth-header-row {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-row {
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .depth-row.selected {
            background: rgba(0, 212, 255, 0.08);
        }

        .depth-bid {
            color: var(--success);
        }

        .depth-ask {
            color: var(--danger);
            text-align: right;
        }

        .depth-price-cell {
            cursor: pointer;
        }

        .depth-rows {
            max-height: 200px;
            overflow: auto;
        }

        .depth-quick {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-selected {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-selected span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .depth-quick-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .depth-modes {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-mode-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-mode-btn {
            padding: 3px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 9px;
            cursor: pointer;
        }

        .depth-mode-btn.active {
            background: rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-color: var(--accent-cyan);
        }

        .tooltip-target {
            position: relative;
        }

        .tooltip-target[data-tooltip]:hover::after,
        .tooltip-target.tooltip-show[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 6px);
            transform: translateX(-50%);
            background: rgba(15, 20, 27, 0.95);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 9px;
            padding: 5px 7px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .depth-reprice {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-reprice-input {
            width: 60px;
            padding: 3px 5px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 9px;
        }

        .depth-signals {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .signal-badge {
            padding: 3px 7px;
            border-radius: 999px;
            font-size: 9px;
            font-weight: 600;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .signal-badge.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .signal-badge.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-score {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-score-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-score-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-score-pill {
            padding: 3px 7px;
            border-radius: 999px;
            font-size: 9px;
            font-weight: 700;
            border: 1px solid transparent;
        }

        .depth-score-pill.hot {
            background: rgba(0, 255, 136, 0.15);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-score-pill.warm {
            background: rgba(255, 210, 63, 0.12);
            color: var(--warning);
            border-color: rgba(255, 210, 63, 0.35);
        }

        .depth-score-pill.cool {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .greeks-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .greeks-panel span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .greeks-panel .hot {
            color: var(--success);
        }

        .greeks-panel .warm {
            color: var(--warning);
        }

        .depth-alert {
            padding: 5px 8px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            border: 1px solid transparent;
        }

        .depth-alert.neutral {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .depth-alert.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-alert.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-hint {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .controls-row--actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .controls-row--settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
        }

        .order-type-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .controls-row--settings .divider {
            display: none;
        }

        .controls-row--settings .qty-control,
        .controls-row--settings .tpsl-control {
            justify-content: space-between;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            text-transform: uppercase;
        }

        .order-type-btn {
            padding: 6px 6px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .action-btn {
            padding: 10px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 700;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .action-btn.buy {
            background: rgba(87, 245, 154, 0.18);
            border-color: rgba(87, 245, 154, 0.45);
            color: var(--success);
        }

        .action-btn.sell {
            background: rgba(255, 107, 107, 0.18);
            border-color: rgba(255, 107, 107, 0.45);
            color: var(--danger);
        }

        .order-type-btn.active {
            background: var(--accent-lime);
            color: var(--bg-primary);
            font-weight: 600;
        }

        .order-type-btn:hover {
            border-color: var(--accent-cyan);
        }

        /* Order Line Overlays */
        .order-line-overlay {
            position: absolute;
            left: 0;
            right: 0;
            height: 20px;
            /* Larger hit area for dragging */
            margin-top: -10px;
            /* Center on price */
            cursor: ns-resize;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }

        .tpsl-line-overlay {
            position: absolute;
            left: 0;
            right: 0;
            height: 16px;
            margin-top: -8px;
            cursor: ns-resize;
            z-index: 9;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            padding: 0 10px;
            pointer-events: auto;
        }

        .tpsl-line-overlay:hover {
            background: rgba(255, 255, 255, 0.04);
        }

        .tpsl-line-overlay.dragging {
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
        }

        .tpsl-close {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-secondary);
            font-size: 10px;
            line-height: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
        }

        .tpsl-close:hover {
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .order-line-overlay:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .order-line-overlay.dragging {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .order-line-label {
            font-size: 11px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 3px;
            font-weight: 600;
            pointer-events: none;
        }

        .order-line-label.buy {
            color: var(--success);
        }

        .order-line-label.sell {
            color: var(--danger);
        }

        .order-line-label.trigger-buy,
        .order-line-label.trigger-sell {
            color: var(--warning);
        }

        .order-line-overlay.fake-limit:hover {
            background: rgba(255, 165, 0, 0.08);
        }

        .order-line-overlay.fake-limit.dragging {
            background: rgba(255, 165, 0, 0.15);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.4);
        }

        .order-type-btn.active-trigger {
            background: var(--warning);
            color: var(--bg-primary);
            font-weight: 600;
        }

        .pnl-label {
            font-size: 11px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 3px;
            font-weight: 600;
            pointer-events: none;
        }

        .pnl-label.profit {
            color: #00ff88;
        }

        .pnl-label.loss {
            color: #ff4560;
        }

        .order-close-btn {
            background: rgba(255, 69, 96, 0.2);
            border: 1px solid #ff4560;
            color: #ff4560;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .order-close-btn:hover {
            background: #ff4560;
            color: white;
        }

        /* Order Controls Popup */
        .order-controls-popup {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .order-controls-popup button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .set-tp-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
        }

        .set-sl-btn {
            background: linear-gradient(135deg, #ff4560 0%, #cc3748 100%);
            color: white;
        }

        .close-order-btn {
            background: var(--danger);
            color: white;
        }

        .btn-buy {
            background: rgba(87, 245, 154, 0.2);
            color: var(--bg-primary);
            border: 1px solid rgba(87, 245, 154, 0.45);
        }

        .btn-buy:hover {
            border-color: rgba(87, 245, 154, 0.7);
        }

        .btn-sell {
            background: rgba(255, 107, 107, 0.2);
            color: var(--text-primary);
            border: 1px solid rgba(255, 107, 107, 0.45);
        }

        .btn-sell:hover {
            border-color: rgba(255, 107, 107, 0.7);
        }

        .btn-toggle {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-toggle.active {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            border-color: var(--accent-cyan);
        }

        .divider {
            width: 1px;
            height: 30px;
            background: var(--border-color);
        }

        .qty-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .qty-btn {
            width: 26px;
            height: 26px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qty-value {
            min-width: 50px;
            text-align: center;
            font-weight: 600;
        }

        .tpsl-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-secondary);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .tpsl-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tpsl-btn {
            width: 22px;
            height: 22px;
            font-size: 14px;
        }

        .tpsl-unit {
            font-size: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .tpsl-control label {
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .tpsl-input {
            width: 36px;
            padding: 3px 2px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            font-weight: 600;
            text-align: center;
        }

        .tpsl-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .price-input {
            width: 120px;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .price-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .position-info {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 13px;
        }

        .position-label {
            color: var(--text-secondary);
        }

        .position-value {
            font-weight: 600;
        }

        .pnl-display {
            font-weight: 700;
            font-size: 16px;
        }

        .btn-close-position {
            background: var(--danger);
            color: white;
            padding: 8px 16px;
            font-size: 12px;
        }

        /* Indicator Legend */
        .indicator-legend {
            position: absolute;
            top: 8px;
            left: 10px;
            z-index: 10;
            display: flex;
            gap: 12px;
            font-size: 11px;
            font-weight: 600;
            background: rgba(14, 19, 26, 0.8);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 4px;
            pointer-events: none;
        }
        .ind-item {
            opacity: 0.85;
        }

        .side-toggle {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .side-btn {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
        }

        .side-btn.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        /* Chart Container */
        #chart-container {
            position: absolute;
            top: 0;
            left: var(--dock-width);
            right: 0;
            bottom: 0;
        }

        .chart-split {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        .chart-pane {
            position: relative;
            background: #0a0e27;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .chart-pane.active {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 1px rgba(83, 242, 214, 0.35);
        }

        .chart-pane-label {
            position: absolute;
            top: 6px;
            right: 10px;
            z-index: 12;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 700;
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-secondary);
            letter-spacing: 0.4px;
        }

        .chart-inner {
            position: absolute;
            inset: 0;
        }

        /* Loading Spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border-left: 4px solid var(--accent-cyan);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-left-color: var(--success);
        }

        .toast.error {
            border-left-color: var(--danger);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        /* Open Orders Panel */
        .orders-panel {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 320px;
            max-height: 70vh;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 200;
            overflow: hidden;
        }

        .orders-panel.collapsed {
            width: 140px;
            max-height: 45px;
        }

        .orders-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(83, 242, 214, 0.18) 0%, rgba(255, 180, 67, 0.16) 100%);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }

        .orders-title {
            font-weight: 700;
            font-size: 13px;
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .orders-count {
            background: var(--accent-lime);
            color: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .orders-actions {
            display: flex;
            gap: 8px;
        }

        .orders-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }

        .orders-refresh-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .orders-refresh-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .orders-close-all-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .orders-close-all-btn:hover {
            background: #ff5c6e;
        }

        .orders-list {
            max-height: 450px;
            overflow-y: auto;
            padding: 10px;
        }

        .order-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .order-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent-cyan);
        }

        .order-info {
            flex: 1;
        }

        .order-symbol {
            font-weight: 700;
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .order-details {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            gap: 10px;
        }

        .order-action-buy {
            color: var(--success);
            font-weight: 600;
        }

        .order-action-sell {
            color: var(--danger);
            font-weight: 600;
        }

        .order-close-icon {
            background: rgba(255, 69, 96, 0.2);
            border: 1px solid var(--danger);
            color: var(--danger);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .order-close-icon:hover {
            background: var(--danger);
            color: white;
        }

        .orders-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .orders-loading {
            text-align: center;
            padding: 15px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Phase 2: Quick Entry Presets */
        .presets-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 0;
            border-bottom: none;
        }

        .preset-btn {
            flex: 1;
            padding: 8px 4px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            text-align: center;
        }

        .preset-btn:hover {
            background: rgba(83, 242, 214, 0.12);
            border-color: var(--accent-cyan);
        }

        .preset-btn.active {
            background: rgba(83, 242, 214, 0.2);
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .preset-btn.scalp {
            border-color: rgba(87, 245, 154, 0.6);
        }

        .preset-btn.scalp:hover,
        .preset-btn.scalp.active {
            background: rgba(87, 245, 154, 0.18);
            color: var(--text-primary);
        }

        .preset-btn.medium {
            border-color: rgba(90, 176, 255, 0.6);
        }

        .preset-btn.medium:hover,
        .preset-btn.medium.active {
            background: rgba(90, 176, 255, 0.18);
            color: var(--text-primary);
        }

        .preset-btn.full {
            border-color: rgba(255, 180, 67, 0.6);
        }

        .preset-btn.full:hover,
        .preset-btn.full.active {
            background: rgba(255, 180, 67, 0.2);
            color: var(--text-primary);
        }

        /* Phase 3: Price Staleness Indicators */
        .price-live {
            color: var(--success);
        }
        
        .price-delayed {
            color: var(--warning);
            opacity: 0.9;
        }
        
        .price-stale {
            color: var(--danger);
            opacity: 0.7;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }
        
        /* Phase 3: Connection Health */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
            color: var(--text-secondary);
        }
        
        .connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .connection-dot.warning {
            background: var(--warning);
        }
        
        .connection-dot.error {
            background: var(--danger);
        }

        /* Phase 5: Loss Warning Banner */
        .loss-warning-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 9999;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        .loss-warning-banner.warning {
            background: linear-gradient(90deg, rgba(255,165,0,0.95), rgba(255,140,0,0.95));
            color: white;
        }
        
        .loss-warning-banner.critical {
            background: linear-gradient(90deg, rgba(255,69,96,0.95), rgba(220,20,60,0.95));
            color: white;
            animation: slideDown 0.3s ease, pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .loss-message {
            font-weight: 700;
            font-size: 13px;
        }
        
        .loss-actions {
            display: flex;
            gap: 8px;
        }
        
        .loss-exit-btn {
            padding: 6px 14px;
            background: white;
            color: var(--danger);
            border: none;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 12px;
        }
        
        .loss-dismiss-btn {
            padding: 6px 10px;
            background: transparent;
            color: white;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            :root {
                --dock-width: 280px;
            }
        }

        @media (max-width: 960px) {
            :root {
                --dock-width: 0px;
            }

            body {
                overflow: auto;
            }

            .control-panel {
                position: relative;
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            #chart-container {
                position: relative;
                left: 0;
                top: 0;
                height: 70vh;
            }

            .orders-panel {
                top: auto;
                bottom: 12px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>

<body>
    <!-- Control Panel -->
    <div class="control-panel">
        <!-- Header Row -->
        <div class="symbol-header dock-section">
            <div class="symbol-title" id="symbolTitle">Loading...</div>
            <div class="current-price" id="currentPrice">
                <span class="price-value">--</span>
                <span class="side-badge ce" id="activeSideBadge">CE Active</span>
            </div>
        </div>
        <div class="side-toggle dock-section" id="sideToggle">
            <button class="side-btn active" id="sideCeBtn" data-side="CE">CE</button>
            <button class="side-btn" id="sidePeBtn" data-side="PE">PE</button>
        </div>
        <div class="scalp-radar dock-section" id="scalpRadar">
            <div class="scalp-radar-title">Scalp Radar</div>
            <div class="scalp-radar-meter">
                <div class="scalp-radar-bar">
                    <div id="scalpRadarFill" class="scalp-radar-fill"></div>
                </div>
                <span id="scalpRadarLabel" class="scalp-radar-label cool">COOL</span>
                <span id="scalpRadarValue" class="scalp-radar-value">--</span>
                <button id="scalpRadarToggle" class="radar-toggle-btn">Radar Off</button>
            </div>
        </div>

        <!-- Controls Row 1: Order Buttons -->
        <div class="controls-row controls-row--actions dock-section">
            <button id="buyBtn" class="action-btn buy" title="Hotkey: B">📈 BUY <span
                    style="opacity:0.5;font-size:10px">(B)</span></button>
            <button id="sellBtn" class="action-btn sell" title="Hotkey: S">📉 SELL <span
                    style="opacity:0.5;font-size:10px">(S)</span></button>
        </div>
        <div class="controls-row controls-row--settings dock-section">
            <div class="order-type-group">
                <button id="marketBtn" class="order-type-btn active">MARKET</button>
                <button id="limitBtn" class="order-type-btn">LIMIT</button>
                <button id="fakeLimitBtn" class="order-type-btn" title="Virtual trigger: MARKET order fires when LTP crosses price">TRIGGER</button>
            </div>

            <div class="qty-control">
                <button class="qty-btn" id="qtyMinus">−</button>
                <div class="qty-value"><span id="qtyValue">2</span> Lots</div>
                <button class="qty-btn" id="qtyPlus">+</button>
            </div>

            <div class="tpsl-control">
                <div class="tpsl-group">
                    <label style="color: var(--success);">TP</label>
                    <button class="qty-btn tpsl-btn" id="tpMinus">&minus;</button>
                    <input type="number" id="tpPointsInput" class="tpsl-input" value="5" min="1" step="1" title="Take Profit points from fill price">
                    <button class="qty-btn tpsl-btn" id="tpPlus">+</button>
                </div>
                <div class="tpsl-group">
                    <label style="color: var(--danger);">SL</label>
                    <button class="qty-btn tpsl-btn" id="slMinus">&minus;</button>
                    <input type="number" id="slPointsInput" class="tpsl-input" value="8" min="1" step="1" title="Stop Loss points from fill price">
                    <button class="qty-btn tpsl-btn" id="slPlus">+</button>
                </div>
                <span class="tpsl-unit">pts</span>
            </div>
        </div>

        <!-- Controls Row 2: Position Info -->
        <div class="position-info dock-section" id="positionInfo">
            <span class="position-label">Position:</span>
            <span class="position-value" id="positionQty">--</span>
            <span class="position-label">Entry:</span>
            <span class="position-value" id="entryPrice">--</span>
            <span class="position-label">P&L:</span>
            <span class="pnl-display" id="pnlValue">₹0.00</span>
            
            <!-- Secured Profit Display (inline) -->
            <span id="securedProfitDisplay" style="display: none; margin-left: 10px;">
                <span style="font-size: 10px; color: var(--success);">🔒</span>
                <span id="securedProfitValue" style="font-weight: 700; color: var(--success);">₹0</span>
            </span>
            
            <button class="btn btn-close-position hidden" id="btnClosePosition">Close Position</button>
            
            <!-- Profit Protection Toggle -->
            <label style="display: flex; align-items: center; gap: 5px; margin-left: 15px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="enableProfitProtection" style="width: 14px; height: 14px;" onchange="toggleProfitProtection()">
                <span style="color: var(--text-secondary);">🛡️ Protect</span>
            </label>
        </div>

        <div class="depth-panel dock-section" id="depthPanel">
            <div class="depth-header">
                <div class="depth-title">Depth Scout</div>
                <div class="depth-meta">
                    <span id="depthBroker">Broker: --</span>
                    <span id="depthStatus" class="depth-status">Off</span>
                </div>
            </div>
            <div class="depth-controls">
                <div class="depth-symbol" id="depthSymbol">--</div>
                <div class="depth-actions">
                    <select id="depthLevelSelect" class="depth-level-select">
                        <option value="5">5L</option>
                        <option value="20">20L</option>
                    </select>
                    <button id="depthToggleBtn" class="depth-toggle active">Depth On</button>
                </div>
            </div>
            <div class="depth-modes">
                <span class="depth-mode-label">Mode</span>
                <button class="depth-mode-btn tooltip-target active" data-mode="JOIN" data-tooltip="Join best bid/ask to queue without crossing">Join</button>
                <button class="depth-mode-btn tooltip-target" data-mode="STEP" data-tooltip="Step 1 tick inside spread for faster priority">Step-In</button>
                <button class="depth-mode-btn tooltip-target" data-mode="TAKE" data-tooltip="Cross spread for fastest fill (uses market if allowed)">Take</button>
                <label class="depth-reprice tooltip-target" data-tooltip="Auto-cancel/replace to stay near top of book">
                    <input type="checkbox" id="depthRepriceToggle" checked style="width: 12px; height: 12px;">
                    <span>Reprice</span>
                </label>
                <input type="number" id="depthRepriceMs" class="depth-reprice-input" min="100" step="50" value="400" title="Reprice after ms">
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAlertToggle" checked style="width: 12px; height: 12px;">
                    <span>Alerts</span>
                </label>
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAudioToggle" style="width: 12px; height: 12px;">
                    <span>Audio</span>
                </label>
                <label class="depth-reprice tooltip-target" data-tooltip="Block MARKET orders; force LIMIT for depth actions">
                    <input type="checkbox" id="depthLimitOnly" style="width: 12px; height: 12px;">
                    <span>No MKT</span>
                </label>
            </div>
            <div class="depth-signals">
                <span id="signalMomentum" class="signal-badge">Momentum --</span>
                <span id="signalSpread" class="signal-badge">Spread --</span>
                <span id="signalLiquidity" class="signal-badge">Liquidity --</span>
                <span id="signalGamma" class="signal-badge">Gamma Squeeze --</span>
            </div>
            <div class="depth-score">
                <span class="depth-score-label">Scalp Score</span>
                <span id="scalpScore" class="depth-score-value">--</span>
                <span id="scalpScoreLabel" class="depth-score-pill cool">COOL</span>
            </div>
            <div class="greeks-panel">
                <div>Gamma Proxy<span id="gammaProxy">--</span></div>
                <div>Vol Spike<span id="volProxy">--</span></div>
            </div>
            <div class="depth-summary">
                <div>Bid <span id="depthTopBid">--</span></div>
                <div>Ask <span id="depthTopAsk">--</span></div>
                <div>Spread <span id="depthSpread">--</span></div>
                <div>Imb <span id="depthImbalance">--</span></div>
            </div>
            <div class="depth-table">
                <div class="depth-header-row">
                    <div>Bid Qty</div>
                    <div>Bid</div>
                    <div style="text-align:right;">Ask</div>
                    <div style="text-align:right;">Ask Qty</div>
                </div>
                <div class="depth-rows" id="depthRows"></div>
            </div>
            <div class="depth-quick">
                <div class="depth-selected">Selected <span id="depthSelectedPrice">--</span></div>
                <div class="depth-quick-actions">
                    <button id="depthBuyBtn" class="action-btn buy">BUY @ --</button>
                    <button id="depthSellBtn" class="action-btn sell">SELL @ --</button>
                </div>
            </div>
            <div class="depth-alert neutral" id="depthAlert">Imbalance neutral</div>
            <div class="depth-hint" id="depthHint">Read-only. Uses live depth feed when available.</div>
        </div>
    </div>

    <!-- Open Orders Panel -->
    <div class="orders-panel" id="ordersPanel">
        <div class="orders-header" onclick="toggleOrdersPanel()">
            <div class="orders-title">
                📋 Open Orders
                <span class="orders-count" id="ordersCount">0</span>
            </div>
            <div class="orders-actions">
                <button class="orders-refresh-btn" onclick="event.stopPropagation(); fetchOpenOrders()" title="Refresh orders">🔄</button>
                <button class="orders-close-all-btn" id="closeAllOrdersBtn" onclick="event.stopPropagation(); closeAllOpenOrders()">Close All</button>
                <button class="orders-toggle" id="ordersToggle">▼</button>
            </div>
        </div>
        <div class="orders-list" id="ordersList">
            <div class="orders-loading">Loading orders...</div>
        </div>
    </div>

    <!-- Chart Container -->
    <div id="chart-container">
        <div class="chart-split" id="chartSplit">
            <div class="chart-pane active" id="chartPaneCE">
                <div class="chart-pane-label">CE</div>
                <div class="chart-inner" id="chartCE"></div>
            </div>
            <div class="chart-pane" id="chartPanePE">
                <div class="chart-pane-label">PE</div>
                <div class="chart-inner" id="chartPE"></div>
            </div>
        </div>
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px;">Loading chart...</p>
        </div>
        <!-- Indicator Legend -->
        <div id="indicatorLegend" class="indicator-legend">
            <span class="ind-item" style="color:#f7c325;">EMA 9</span>
            <span class="ind-item" style="color:#7b61ff;">EMA 21</span>
            <span class="ind-item"><span style="color:#00ff88;">S</span><span style="color:#ff4560;">T</span> 10,3</span>
            <span class="ind-item" style="color:#00bcd4;">VWAP</span>
        </div>
    </div>

    <!-- Lightweight Charts Library -->
    <script src="/static/js/lightweight-charts.standalone.production.js"></script>

    <script>
        // Configuration - wsUrl derived from page port, overridden from server config
        const CONFIG = {
            wsUrl: `ws://${window.location.hostname}:${parseInt(window.location.port || '5000') + 3765}`,
            wsReconnectInterval: 5000,
            candleInterval: 60, // 1-minute candles
            tickSize: 0.05 // Options tick size
        };

        const PERF = {
            disableConsoleLog: true,
            indicatorThrottleMs: 250,
            depthThrottleMs: 80
        };

        const ui = {
            currentPrice: document.getElementById('currentPrice'),
            currentPriceValue: null,
            sideToggle: document.getElementById('sideToggle'),
            sideCeBtn: document.getElementById('sideCeBtn'),
            sidePeBtn: document.getElementById('sidePeBtn'),
            chartSplit: document.getElementById('chartSplit'),
            chartPaneCE: document.getElementById('chartPaneCE'),
            chartPanePE: document.getElementById('chartPanePE')
        };

        const depthUi = {
            panel: document.getElementById('depthPanel'),
            scalpRadar: document.getElementById('scalpRadar'),
            scalpRadarFill: document.getElementById('scalpRadarFill'),
            scalpRadarLabel: document.getElementById('scalpRadarLabel'),
            scalpRadarValue: document.getElementById('scalpRadarValue'),
            scalpRadarToggle: document.getElementById('scalpRadarToggle'),
            status: document.getElementById('depthStatus'),
            broker: document.getElementById('depthBroker'),
            symbol: document.getElementById('depthSymbol'),
            levelSelect: document.getElementById('depthLevelSelect'),
            toggleBtn: document.getElementById('depthToggleBtn'),
            rows: document.getElementById('depthRows'),
            topBid: document.getElementById('depthTopBid'),
            topAsk: document.getElementById('depthTopAsk'),
            spread: document.getElementById('depthSpread'),
            imbalance: document.getElementById('depthImbalance'),
            selectedPrice: document.getElementById('depthSelectedPrice'),
            buyBtn: document.getElementById('depthBuyBtn'),
            sellBtn: document.getElementById('depthSellBtn'),
            alert: document.getElementById('depthAlert'),
            hint: document.getElementById('depthHint'),
            repriceToggle: document.getElementById('depthRepriceToggle'),
            repriceMs: document.getElementById('depthRepriceMs'),
            alertToggle: document.getElementById('depthAlertToggle'),
            audioToggle: document.getElementById('depthAudioToggle'),
            limitOnly: document.getElementById('depthLimitOnly'),
            scalpScore: document.getElementById('scalpScore'),
            scalpScoreLabel: document.getElementById('scalpScoreLabel'),
            gammaProxy: document.getElementById('gammaProxy'),
            volProxy: document.getElementById('volProxy'),
            signalMomentum: document.getElementById('signalMomentum'),
            signalSpread: document.getElementById('signalSpread'),
            signalLiquidity: document.getElementById('signalLiquidity'),
            signalGamma: document.getElementById('signalGamma')
        };

        const depthDomCache = {
            rows: [],
            bidQty: [],
            bidPrice: [],
            askPrice: [],
            askQty: [],
            maxRows: 20
        };

        const depthAnalytics = {
            imbalanceHistory: [],
            spreadHistory: [],
            bidQtyHistory: [],
            askQtyHistory: [],
            priceHistory: [],
            underlyingHistory: []
        };

        const depthState = {
            enabled: true,
            level: 5,
            requestedLevel: 5,
            lastUpdate: 0,
            pending: null,
            scheduled: false,
            lastRender: 0,
            broker: null,
            selectedPrice: null,
            selectedSide: null,
            topBidValue: null,
            topAskValue: null,
            orderMode: 'JOIN',
            repriceEnabled: true,
            repriceMs: 400,
            repriceMaxRetries: 2,
            alertEnabled: true,
            audioEnabled: true,
            limitOnly: false,
            radarEnabled: false,
            lastScore: 0,
            lastAlertTs: 0,
            lastAudioTs: 0,
            stepInTicks: 1,
            takeMaxSpread: 0.1,
            momentumWindow: 8,
            momentumThreshold: 6,
            spreadWide: 0.2,
            spreadTight: 0.05,
            liquidityDropPct: 40,
            imbalanceMomentum: 0,
            gammaAccelHigh: 12,
            gammaAccelMed: 6,
            volHigh: 6,
            volMed: 3,
            priceHistorySize: 12,
            lastSpeed: 0,
            gammaLevel: 'LOW',
            volLevel: 'LOW',
            underlyingHistorySize: 8,
            underlyingSpeedHigh: 60,
            underlyingAccelHigh: 25,
            underlyingMovePts: 5,
            underlyingSpeed: 0,
            underlyingAccel: 0,
            underlyingMove: 0,
            gammaSqueezeActive: false
        };

        function ensureCurrentPriceValue() {
            if (!ui.currentPrice) return null;
            if (ui.currentPriceValue && ui.currentPriceValue.isConnected) {
                return ui.currentPriceValue;
            }
            let valueEl = ui.currentPrice.querySelector('.price-value');
            if (!valueEl) {
                valueEl = document.createElement('span');
                valueEl.className = 'price-value';
                ui.currentPrice.insertBefore(valueEl, ui.currentPrice.firstChild);
            }
            ui.currentPriceValue = valueEl;
            return valueEl;
        }

        function debugLog(...args) {
            if (!PERF.disableConsoleLog) console.log(...args);
        }

        function debugWarn(...args) {
            if (!PERF.disableConsoleLog) console.warn(...args);
        }

        // Helper function to round price to tick size
        function roundToTick(price) {
            return Math.round(price / CONFIG.tickSize) * CONFIG.tickSize;
        }

        // State
        const state = {
            symbol: null,
            underlying: null,
            exchange: null,
            underlyingExchange: null,
            ceSymbol: null,
            peSymbol: null,
            splitMode: false,
            activeSide: 'CE',
            optionType: null,
            strike: null,
            expiry: null,
            indexOnly: false,
            apiKey: null,
            ws: null,
            chart: null,
            candlestickSeries: null,
            currentPrice: 0,
            quantity: 2,
            orderType: 'MARKET',
            position: null,
            entryPrice: 0,
            orderLines: new Map(),
            followingMode: false,
            followingType: null,
            currentFollowLine: null,
            lastCandleTime: 0,
            pendingCandle: null,
            lotSize: 65, // Will be updated from URL params
            // Order and position tracking
            orders: new Map(), // orderId -> order data
            manualTradeBySide: {
                CE: {
                    tradeId: null,
                    entryTs: null,
                    entryPrice: null,
                    entryQty: null,
                    entrySymbol: null,
                    entryAction: null
                },
                PE: {
                    tradeId: null,
                    entryTs: null,
                    entryPrice: null,
                    entryQty: null,
                    entrySymbol: null,
                    entryAction: null
                }
            },
            // Fake limit (virtual trigger) orders
            fakeLimitOrders: new Map(), // id -> {id, action, triggerPrice, direction, quantity, priceLine, overlay, tpPoints, slPoints}
            fakeLimitIdCounter: 0,
            positions: new Map(), // orderId -> position data
            dragState: {
                isDragging: false,
                orderId: null,
                startY: 0,
                startPrice: 0
            },
            // Phase 1: Profit Protection System
            profitProtectionEnabled: false,
            profitProtectionLevels: [
                { trigger: 500, lockPercent: 50 },
                { trigger: 1000, lockPercent: 60 },
                { trigger: 2000, lockPercent: 70 },
                { trigger: 3000, lockPercent: 80 }
            ],
            currentProtectionLevel: -1,
            securedProfit: 0,
            breakevenActivated: false,
            breakevenThreshold: 300,
            highestPnl: 0,
            totalPnl: 0,
            isClosingPosition: false,
            // Auto TP/SL point offsets (configurable via UI inputs)
            tpPoints: 5,
            slPoints: 8,
            // Indicator state
            candles: [],           // Completed candle history for indicator calculations
            ema9Series: null,
            ema21Series: null,
            supertrendSeries: null,
            vwapSeries: null
        };

        const chartContexts = {};
        const positionStates = {
            CE: {
                position: null,
                entryPrice: 0,
                positionLine: null,
                positionOverlay: null,
                positionTPSL: {
                    tpLine: null,
                    slLine: null,
                    tpOverlay: null,
                    slOverlay: null,
                    tpPrice: null,
                    slPrice: null
                }
            },
            PE: {
                position: null,
                entryPrice: 0,
                positionLine: null,
                positionOverlay: null,
                positionTPSL: {
                    tpLine: null,
                    slLine: null,
                    tpOverlay: null,
                    slOverlay: null,
                    tpPrice: null,
                    slPrice: null
                }
            }
        };

        // Parse URL parameters
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            state.symbol = params.get('symbol');
            state.underlying = params.get('underlying');
            state.ceSymbol = params.get('ceSymbol');
            state.peSymbol = params.get('peSymbol');
            const initialSide = (params.get('initialSide') || params.get('optionType') || 'CE').toUpperCase();
            state.indexOnly = params.get('indexOnly') === '1';

            // Map INDEX exchanges to options exchanges
            const rawExchange = params.get('exchange');
            state.underlyingExchange = rawExchange;
            if (state.indexOnly) {
                state.exchange = rawExchange;
            } else if (rawExchange === 'NSE_INDEX') {
                state.exchange = 'NFO'; // NIFTY options
            } else if (rawExchange === 'BSE_INDEX') {
                state.exchange = 'BFO'; // SENSEX options
            } else {
                state.exchange = rawExchange;
            }

            state.optionType = params.get('optionType');
            state.strike = params.get('strike');
            state.expiry = params.get('expiry');
            state.lotSize = parseInt(params.get('lotSize')) || 65; // Default to 65 if not provided

            if (state.indexOnly) {
                state.splitMode = false;
                state.ceSymbol = null;
                state.peSymbol = null;
                state.optionType = null;
                state.activeSide = 'CE';
                if (!state.underlying) {
                    state.underlying = state.symbol;
                }
            }

            if (state.ceSymbol || state.peSymbol) {
                state.splitMode = true;
            }
            if (!state.ceSymbol && state.optionType === 'CE') state.ceSymbol = state.symbol;
            if (!state.peSymbol && state.optionType === 'PE') state.peSymbol = state.symbol;
            if (!state.ceSymbol && state.peSymbol && state.symbol === state.peSymbol) {
                state.ceSymbol = '';
            }
            if (!state.peSymbol && state.ceSymbol && state.symbol === state.ceSymbol) {
                state.peSymbol = '';
            }

            state.activeSide = initialSide === 'PE' ? 'PE' : 'CE';
            const activeSymbol = state.activeSide === 'PE' ? state.peSymbol : state.ceSymbol;
            if (activeSymbol) {
                state.symbol = activeSymbol;
            }

            // Get API key from parent window or localStorage
            if (window.opener && window.opener.state && window.opener.state.apiKey) {
                state.apiKey = window.opener.state.apiKey;
            } else {
                state.apiKey = localStorage.getItem('openalgo_api_key') || localStorage.getItem('apiKey');
            }

            // Update title
            if (state.indexOnly) {
                document.getElementById('symbolTitle').textContent = `${state.symbol} Index`;
            } else {
                document.getElementById('symbolTitle').textContent =
                    `${state.underlying} ${state.strike} CE/PE - ${state.expiry}`;
            }
        }

        function getSideForSymbol(symbol) {
            if (symbol && state.ceSymbol && symbol === state.ceSymbol) return 'CE';
            if (symbol && state.peSymbol && symbol === state.peSymbol) return 'PE';
            return null;
        }

        function getActiveSymbol() {
            return state.activeSide === 'PE' ? state.peSymbol : state.ceSymbol;
        }

        function getContext(side) {
            return chartContexts[side];
        }

        function getContextForSide(side) {
            if (side && chartContexts[side]) return chartContexts[side];
            return chartContexts.CE || chartContexts.PE || null;
        }

        function getContextForSymbol(symbol) {
            const side = getSideForSymbol(symbol) || state.activeSide;
            return getContextForSide(side);
        }

        function getPositionState(side = state.activeSide) {
            return positionStates[side] || positionStates.CE;
        }

        function updateActivePriceUI() {
            if (!ui.currentPrice) return;
            const ctx = getContextForSide(state.activeSide);
            if (!ctx) return;
            const valueEl = ensureCurrentPriceValue();
            if (valueEl) {
                valueEl.textContent = ctx.currentPrice ? `₹${ctx.currentPrice.toFixed(2)}` : '--';
            }
            ui.currentPrice.className = 'current-price price-positive';
        }

        function updateSideUI() {
            if (ui.sideCeBtn) ui.sideCeBtn.classList.toggle('active', state.activeSide === 'CE');
            if (ui.sidePeBtn) ui.sidePeBtn.classList.toggle('active', state.activeSide === 'PE');
            if (ui.chartPaneCE) ui.chartPaneCE.classList.toggle('active', state.activeSide === 'CE');
            if (ui.chartPanePE) ui.chartPanePE.classList.toggle('active', state.activeSide === 'PE');
            if (!state.splitMode && ui.chartPaneCE) {
                const label = ui.chartPaneCE.querySelector('.chart-pane-label');
                if (label) label.textContent = state.activeSide;
            }
            const badge = document.getElementById('activeSideBadge');
            if (badge) {
                badge.textContent = `${state.activeSide} Active`;
                badge.classList.toggle('ce', state.activeSide === 'CE');
                badge.classList.toggle('pe', state.activeSide === 'PE');
            }
            updateActivePriceUI();
            updateDepthSymbolUI();
        }

        function updatePositionPanelFromState(side) {
            const posState = getPositionState(side);
            const qty = parseInt(posState?.position?.quantity) || 0;

            if (!posState?.position || qty === 0) {
                document.getElementById('positionQty').textContent = '--';
                document.getElementById('entryPrice').textContent = '--';
                document.getElementById('pnlValue').textContent = '₹0.00';
                document.getElementById('btnClosePosition').classList.add('hidden');
                return;
            }

            const entry = Number.isFinite(posState.entryPrice) && posState.entryPrice > 0
                ? posState.entryPrice
                : (parseFloat(posState.position.average_price) || 0);
            posState.entryPrice = entry;

            document.getElementById('positionQty').textContent = `${qty > 0 ? '+' : ''}${qty}`;
            document.getElementById('entryPrice').textContent = `₹${entry.toFixed(2)}`;
            document.getElementById('btnClosePosition').classList.remove('hidden');

            const ctx = getContextForSide(side);
            const ltp = ctx?.currentPrice || 0;
            if (ltp > 0) {
                const pnl = (ltp - entry) * qty;
                const pnlEl = document.getElementById('pnlValue');
                pnlEl.textContent = `₹${pnl.toFixed(2)}`;
                pnlEl.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;
            }
        }

        function setActiveSide(side, options = {}) {
            const normalized = side === 'PE' ? 'PE' : 'CE';
            if (state.activeSide === normalized) return;
            const prevSymbol = state.symbol;
            state.activeSide = normalized;
            state.symbol = getActiveSymbol() || state.symbol;
            state.optionType = normalized;

            const ctx = getContextForSide(normalized);
            if (ctx) {
                state.chart = ctx.chart;
                state.candlestickSeries = ctx.series;
                state.ema9Series = ctx.ema9Series;
                state.ema21Series = ctx.ema21Series;
                state.supertrendSeries = ctx.supertrendSeries;
                state.vwapSeries = ctx.vwapSeries;
                state.currentPrice = ctx.currentPrice || 0;
            }

            if (depthState.enabled && prevSymbol && prevSymbol !== state.symbol) {
                unsubscribeDepth(prevSymbol);
                subscribeDepth();
            } else {
                updateDepthSymbolUI();
            }

            if (!options.preserveFollow) {
                disableFollowMode();
            } else {
                resetFollowLineForSide(normalized);
            }
            const posState = getPositionState(normalized);
            state.position = posState.position;
            state.entryPrice = posState.entryPrice || 0;
            updateSideUI();
            updatePositionPanelFromState(normalized);
            fetchAndDisplayPosition(null, state.symbol, normalized);
        }

        // Depth Scout UI
        function isDhanBroker() {
            const broker = depthState.broker ? depthState.broker.toLowerCase() : '';
            if (broker.includes('dhan')) return true;
            return window.location.port === '5001';
        }

        function initDepthPanel() {
            if (!depthUi.panel) return;
            buildDepthRows();
            if (depthUi.rows) {
                depthUi.rows.addEventListener('click', handleDepthRowClick);
            }

            const modeButtons = Array.from(depthUi.panel.querySelectorAll('.depth-mode-btn'));
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setDepthOrderMode(mode);
                });
            });

            if (depthUi.levelSelect) {
                depthUi.levelSelect.value = String(depthState.level);
                depthUi.levelSelect.addEventListener('change', (e) => {
                    const level = parseInt(e.target.value, 10);
                    setDepthLevel(level);
                });
            }

            if (depthUi.toggleBtn) {
                depthUi.toggleBtn.addEventListener('click', () => {
                    setDepthEnabled(!depthState.enabled);
                });
            }
            if (depthUi.buyBtn) {
                depthUi.buyBtn.addEventListener('click', () => placeDepthOrder('BUY'));
            }
            if (depthUi.sellBtn) {
                depthUi.sellBtn.addEventListener('click', () => placeDepthOrder('SELL'));
            }
            if (depthUi.repriceToggle) {
                depthUi.repriceToggle.checked = depthState.repriceEnabled;
                depthUi.repriceToggle.addEventListener('change', (e) => {
                    depthState.repriceEnabled = e.target.checked;
                });
            }
            if (depthUi.repriceMs) {
                depthUi.repriceMs.value = String(depthState.repriceMs);
                depthUi.repriceMs.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value, 10);
                    if (Number.isFinite(val) && val >= 100) {
                        depthState.repriceMs = val;
                    }
                    depthUi.repriceMs.value = String(depthState.repriceMs);
                });
            }
            if (depthUi.alertToggle) {
                depthUi.alertToggle.checked = depthState.alertEnabled;
                depthUi.alertToggle.addEventListener('change', (e) => {
                    depthState.alertEnabled = e.target.checked;
                });
            }
            if (depthUi.scalpRadarToggle) {
                depthUi.scalpRadarToggle.addEventListener('click', () => {
                    setScalpRadarEnabled(!depthState.radarEnabled);
                });
            }
            if (depthUi.audioToggle) {
                depthUi.audioToggle.checked = depthState.audioEnabled;
                depthUi.audioToggle.addEventListener('change', (e) => {
                    depthState.audioEnabled = e.target.checked;
                    if (depthState.audioEnabled) {
                        initDepthAudio();
                    }
                });
            }
            if (depthUi.limitOnly) {
                depthUi.limitOnly.checked = depthState.limitOnly;
                depthUi.limitOnly.addEventListener('change', (e) => {
                    depthState.limitOnly = e.target.checked;
                    updateDepthQuickUI();
                });
            }

            updateDepthSymbolUI();
            updateDepthBrokerUI();
            updateDepthStatusUI();
            updateDepthModeUI();
            updateDepthQuickUI();
            updateDepthHint();
            resetDepthAnalytics();
            if (depthState.audioEnabled) {
                initDepthAudio();
            }
            setScalpRadarEnabled(false);
        }

        let tooltipHintsBound = false;

        function initTooltipHints() {
            if (tooltipHintsBound) return;
            tooltipHintsBound = true;
            const targets = Array.from(document.querySelectorAll('.tooltip-target[data-tooltip]'));
            targets.forEach(el => {
                let timer;
                el.addEventListener('touchstart', () => {
                    el.classList.add('tooltip-show');
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1600);
                }, { passive: true });
                el.addEventListener('touchend', () => {
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1200);
                }, { passive: true });
            });
        }

        function resetDepthAnalytics() {
            depthAnalytics.imbalanceHistory = [];
            depthAnalytics.spreadHistory = [];
            depthAnalytics.bidQtyHistory = [];
            depthAnalytics.askQtyHistory = [];
            depthAnalytics.priceHistory = [];
            depthAnalytics.underlyingHistory = [];
            depthState.lastSpeed = 0;
            depthState.gammaLevel = 'LOW';
            depthState.volLevel = 'LOW';
            depthState.underlyingSpeed = 0;
            depthState.underlyingAccel = 0;
            depthState.underlyingMove = 0;
            depthState.gammaSqueezeActive = false;
            updateGreeksProxyUI(depthUi.gammaProxy, '--');
            updateGreeksProxyUI(depthUi.volProxy, '--');
            updateSignalBadge(depthUi.signalMomentum, 'Momentum --', 'neutral');
            updateSignalBadge(depthUi.signalSpread, 'Spread --', 'neutral');
            updateSignalBadge(depthUi.signalLiquidity, 'Liquidity --', 'neutral');
            updateSignalBadge(depthUi.signalGamma, 'Gamma Squeeze --', 'neutral');
            updateScalpScore(0);
        }

        function buildDepthRows() {
            if (!depthUi.rows) return;
            depthUi.rows.innerHTML = '';
            depthDomCache.rows = [];
            depthDomCache.bidQty = [];
            depthDomCache.bidPrice = [];
            depthDomCache.askPrice = [];
            depthDomCache.askQty = [];

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = document.createElement('div');
                row.className = 'depth-row';
                row.dataset.index = String(i);

                const bidQty = document.createElement('div');
                const bidPrice = document.createElement('div');
                const askPrice = document.createElement('div');
                const askQty = document.createElement('div');

                bidPrice.classList.add('depth-bid', 'depth-price-cell');
                askPrice.classList.add('depth-ask', 'depth-price-cell');
                askQty.classList.add('depth-ask');
                bidPrice.dataset.side = 'bid';
                askPrice.dataset.side = 'ask';
                bidPrice.dataset.index = String(i);
                askPrice.dataset.index = String(i);

                row.appendChild(bidQty);
                row.appendChild(bidPrice);
                row.appendChild(askPrice);
                row.appendChild(askQty);

                depthUi.rows.appendChild(row);
                depthDomCache.rows.push(row);
                depthDomCache.bidQty.push(bidQty);
                depthDomCache.bidPrice.push(bidPrice);
                depthDomCache.askPrice.push(askPrice);
                depthDomCache.askQty.push(askQty);
            }
        }

        function updateDepthSymbolUI() {
            if (!depthUi.symbol) return;
            depthUi.symbol.textContent = state.symbol || '--';
        }

        function setDepthOrderMode(mode) {
            if (!mode) return;
            const normalized = mode.toUpperCase();
            if (!['JOIN', 'STEP', 'TAKE'].includes(normalized)) return;
            if (depthState.orderMode === normalized) return;
            depthState.orderMode = normalized;
            updateDepthModeUI();
            updateDepthQuickUI();
        }

        function updateDepthModeUI() {
            if (!depthUi.panel) return;
            depthUi.panel.querySelectorAll('.depth-mode-btn').forEach(btn => {
                const active = btn.dataset.mode === depthState.orderMode;
                btn.classList.toggle('active', active);
            });
        }

        function setDepthEnabled(enabled) {
            depthState.enabled = !!enabled;
            updateDepthStatusUI();
            if (depthState.enabled) {
                subscribeDepth();
            } else {
                unsubscribeDepth();
            }
            clearDepthUI();
            updateDepthHint();
        }

        function setDepthLevel(level) {
            if (!Number.isFinite(level)) return;
            const requested = Math.max(1, Math.min(20, level));
            let normalized = requested;
            const allow20 = isDhanBroker() && state.exchange !== 'BFO';
            if (!allow20 && normalized > 5) {
                normalized = 5;
            }
            depthState.requestedLevel = requested;
            if (depthState.level === normalized) return;
            depthState.level = normalized;
            if (depthUi.levelSelect) {
                depthUi.levelSelect.value = String(normalized);
            }
            if (depthState.enabled) {
                unsubscribeDepth();
                subscribeDepth();
            }
            updateDepthHint();
        }

        function updateDepthBrokerUI() {
            if (!depthUi.broker) return;
            const broker = depthState.broker ? depthState.broker.toUpperCase() : '--';
            depthUi.broker.textContent = `Broker: ${broker}`;

            if (depthUi.levelSelect) {
                const allow20 = isDhanBroker() && state.exchange !== 'BFO';
                const opt20 = depthUi.levelSelect.querySelector('option[value=\"20\"]');
                if (opt20) {
                    opt20.disabled = !allow20;
                }
                if (!allow20 && depthState.level > 5) {
                    depthState.level = 5;
                    depthUi.levelSelect.value = '5';
                }
            }
            updateDepthHint();
        }

        function updateDepthStatusUI() {
            if (!depthUi.status) return;
            if (!depthState.enabled) {
                depthUi.status.textContent = 'Off';
                depthUi.status.classList.remove('live');
            } else if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
                depthUi.status.textContent = 'On';
                depthUi.status.classList.remove('live');
            } else {
                const age = Date.now() - (depthState.lastUpdate || 0);
                if (depthState.lastUpdate && age < 5000) {
                    depthUi.status.textContent = 'Live';
                    depthUi.status.classList.add('live');
                } else {
                    depthUi.status.textContent = 'On';
                    depthUi.status.classList.remove('live');
                }
            }

            if (depthUi.toggleBtn) {
                depthUi.toggleBtn.textContent = depthState.enabled ? 'Depth On' : 'Depth Off';
                depthUi.toggleBtn.classList.toggle('active', depthState.enabled);
            }

            const disableOrders = !depthState.enabled;
            if (depthUi.buyBtn) depthUi.buyBtn.disabled = disableOrders;
            if (depthUi.sellBtn) depthUi.sellBtn.disabled = disableOrders;
        }

        function updateDepthQuickUI() {
            const selectedPrice = depthState.selectedPrice;
            if (depthUi.selectedPrice) {
                depthUi.selectedPrice.textContent = selectedPrice ? formatDepthPrice(selectedPrice) : '--';
            }
            const buySpec = getDepthOrderSpec('BUY');
            const sellSpec = getDepthOrderSpec('SELL');
            if (depthUi.buyBtn) {
                depthUi.buyBtn.textContent = buySpec.pricetype === 'MARKET'
                    ? 'BUY @ MKT'
                    : `BUY @ ${buySpec.price ? formatDepthPrice(buySpec.price) : '--'}`;
            }
            if (depthUi.sellBtn) {
                depthUi.sellBtn.textContent = sellSpec.pricetype === 'MARKET'
                    ? 'SELL @ MKT'
                    : `SELL @ ${sellSpec.price ? formatDepthPrice(sellSpec.price) : '--'}`;
            }
        }

        function updateDepthAlert(imbalance) {
            if (!depthUi.alert) return;
            if (!Number.isFinite(imbalance)) {
                depthUi.alert.className = 'depth-alert neutral';
                depthUi.alert.textContent = 'Imbalance neutral';
                return;
            }
            if (imbalance >= 25) {
                depthUi.alert.className = 'depth-alert buy';
                depthUi.alert.textContent = `Buy pressure +${imbalance.toFixed(0)}%`;
            } else if (imbalance <= -25) {
                depthUi.alert.className = 'depth-alert sell';
                depthUi.alert.textContent = `Sell pressure ${imbalance.toFixed(0)}%`;
            } else {
                depthUi.alert.className = 'depth-alert neutral';
                depthUi.alert.textContent = `Imbalance ${imbalance >= 0 ? '+' : ''}${imbalance.toFixed(0)}%`;
            }
        }

        function updateSignalBadge(el, text, type) {
            if (!el) return;
            el.textContent = text;
            el.classList.remove('buy', 'sell');
            if (type === 'buy') el.classList.add('buy');
            if (type === 'sell') el.classList.add('sell');
        }

        let depthAudioContext = null;

        function initDepthAudio() {
            if (depthAudioContext) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return;
            try {
                depthAudioContext = new AudioCtx();
            } catch (err) {
                depthAudioContext = null;
            }
        }

        function playDepthAlertTone() {
            if (!depthState.audioEnabled) return;
            if (!depthAudioContext) {
                initDepthAudio();
            }
            if (!depthAudioContext) return;
            if (depthAudioContext.state === 'suspended') {
                depthAudioContext.resume().catch(() => {});
            }
            const now = depthAudioContext.currentTime;
            const osc = depthAudioContext.createOscillator();
            const gain = depthAudioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
            osc.connect(gain);
            gain.connect(depthAudioContext.destination);
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function setScalpRadarEnabled(enabled) {
            depthState.radarEnabled = !!enabled;
            if (depthUi.scalpRadarToggle) {
                depthUi.scalpRadarToggle.textContent = depthState.radarEnabled ? 'Radar On' : 'Radar Off';
                depthUi.scalpRadarToggle.classList.toggle('active', depthState.radarEnabled);
            }
            if (depthUi.scalpRadar) {
                depthUi.scalpRadar.classList.toggle('off', !depthState.radarEnabled);
            }
            if (!depthState.radarEnabled) {
                if (depthUi.scalpRadarFill) depthUi.scalpRadarFill.style.width = '0%';
                if (depthUi.scalpRadarLabel) {
                    depthUi.scalpRadarLabel.textContent = 'OFF';
                    depthUi.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    depthUi.scalpRadarLabel.classList.add('cool');
                }
                if (depthUi.scalpRadarValue) depthUi.scalpRadarValue.textContent = '--';
            } else {
                updateScalpScore(depthState.lastScore || 0);
            }
        }

        function updateScalpScore(score) {
            if (!depthUi.scalpScore || !depthUi.scalpScoreLabel) return;
            const clipped = Math.max(0, Math.min(100, Math.round(score)));
            depthUi.scalpScore.textContent = clipped.toString();
            depthUi.scalpScoreLabel.classList.remove('hot', 'warm', 'cool');
            let label = 'COOL';
            let cls = 'cool';
            if (clipped >= 75) {
                label = 'HOT';
                cls = 'hot';
            } else if (clipped >= 50) {
                label = 'WARM';
                cls = 'warm';
            }
            depthUi.scalpScoreLabel.textContent = label;
            depthUi.scalpScoreLabel.classList.add(cls);

            if (depthState.radarEnabled) {
                if (depthUi.scalpRadarFill) {
                    depthUi.scalpRadarFill.style.width = `${clipped}%`;
                }
                if (depthUi.scalpRadarLabel) {
                    depthUi.scalpRadarLabel.textContent = label;
                    depthUi.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    depthUi.scalpRadarLabel.classList.add(cls);
                }
                if (depthUi.scalpRadarValue) {
                    depthUi.scalpRadarValue.textContent = clipped.toString();
                }
            }

            if (depthState.radarEnabled && clipped >= 75 && depthState.lastScore < 75) {
                const now = Date.now();
                if (depthState.alertEnabled && now - depthState.lastAlertTs > 5000) {
                    depthState.lastAlertTs = now;
                    showToast(`Scalp Radar HOT (${clipped})`, 'success');
                }
                if (depthState.audioEnabled && now - depthState.lastAudioTs > 5000) {
                    depthState.lastAudioTs = now;
                    playDepthAlertTone();
                }
            }
            depthState.lastScore = clipped;
        }

        function updateGreeksProxyUI(el, level) {
            if (!el) return;
            el.textContent = level;
            el.classList.remove('hot', 'warm');
            if (level === 'HIGH') el.classList.add('hot');
            if (level === 'MED') el.classList.add('warm');
        }

        function updateGreeksProxy(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.priceHistory || [];
            history.push({ price, ts });
            const maxSize = depthState.priceHistorySize || 12;
            if (history.length > maxSize) history.shift();
            depthAnalytics.priceHistory = history;
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (depthState.lastSpeed || 0);
            depthState.lastSpeed = speed;

            const diffs = [];
            for (let i = 1; i < history.length; i++) {
                diffs.push(history[i].price - history[i - 1].price);
            }
            const mean = diffs.reduce((a, b) => a + b, 0) / diffs.length;
            const variance = diffs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / diffs.length;
            const std = Math.sqrt(variance);

            const tick = CONFIG.tickSize || 0.05;
            const accelTicks = Math.abs(accel) / tick;
            const volTicks = std / tick;

            let gammaLevel = 'LOW';
            if (accelTicks >= depthState.gammaAccelHigh) gammaLevel = 'HIGH';
            else if (accelTicks >= depthState.gammaAccelMed) gammaLevel = 'MED';

            let volLevel = 'LOW';
            if (volTicks >= depthState.volHigh) volLevel = 'HIGH';
            else if (volTicks >= depthState.volMed) volLevel = 'MED';

            depthState.gammaLevel = gammaLevel;
            depthState.volLevel = volLevel;

            updateGreeksProxyUI(depthUi.gammaProxy, gammaLevel);
            updateGreeksProxyUI(depthUi.volProxy, volLevel);
        }

        function updateUnderlyingMetrics(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.underlyingHistory || [];
            history.push({ price, ts });
            const maxSize = depthState.underlyingHistorySize || 8;
            if (history.length > maxSize) history.shift();
            depthAnalytics.underlyingHistory = history;
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (depthState.underlyingSpeed || 0);
            depthState.underlyingSpeed = speed;
            depthState.underlyingAccel = accel;

            const base = history[0].price;
            depthState.underlyingMove = price - base;
        }

        function pushDepthHistory(list, value, maxLen) {
            if (!Number.isFinite(value)) return;
            list.push(value);
            if (list.length > maxLen) list.shift();
        }

        function computeMomentum(history) {
            if (!history || history.length < 2) return 0;
            return history[history.length - 1] - history[0];
        }

        function updateDepthSignals(imbalance, spread, bestBidQty, bestAskQty) {
            const windowSize = depthState.momentumWindow || 8;
            pushDepthHistory(depthAnalytics.imbalanceHistory, imbalance, windowSize);
            pushDepthHistory(depthAnalytics.spreadHistory, spread, Math.max(windowSize, 6));
            pushDepthHistory(depthAnalytics.bidQtyHistory, bestBidQty, 2);
            pushDepthHistory(depthAnalytics.askQtyHistory, bestAskQty, 2);

            const momentum = computeMomentum(depthAnalytics.imbalanceHistory);
            depthState.imbalanceMomentum = momentum;
            if (momentum >= depthState.momentumThreshold) {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ↑ ${momentum.toFixed(0)}%`, 'buy');
            } else if (momentum <= -depthState.momentumThreshold) {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ↓ ${momentum.toFixed(0)}%`, 'sell');
            } else {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ${momentum >= 0 ? '+' : ''}${momentum.toFixed(0)}%`, 'neutral');
            }

            let spreadSignal = 'Spread stable';
            let spreadType = 'neutral';
            const spreadDirection = Number.isFinite(imbalance) ? (imbalance >= 0 ? 'buy' : 'sell') : 'neutral';
            if (Number.isFinite(spread) && depthAnalytics.spreadHistory.length >= 4) {
                const prev = depthAnalytics.spreadHistory.slice(0, -1);
                const prevAvg = prev.reduce((a, b) => a + b, 0) / prev.length;
                if (prevAvg >= depthState.spreadWide && spread <= depthState.spreadTight) {
                    spreadSignal = 'Spread compress';
                    spreadType = spreadDirection;
                } else if (spread >= depthState.spreadWide) {
                    spreadSignal = 'Spread wide';
                } else if (spread <= depthState.spreadTight) {
                    spreadSignal = 'Spread tight';
                } else {
                    spreadSignal = `Spread ${spread.toFixed(2)}`;
                }
            }
            updateSignalBadge(depthUi.signalSpread, spreadSignal, spreadType);

            let liquiditySignal = 'Liquidity stable';
            let liquidityType = 'neutral';
            const prevBidQty = depthAnalytics.bidQtyHistory.length > 1 ? depthAnalytics.bidQtyHistory[0] : null;
            const prevAskQty = depthAnalytics.askQtyHistory.length > 1 ? depthAnalytics.askQtyHistory[0] : null;
            if (Number.isFinite(prevBidQty) && Number.isFinite(bestBidQty) && prevBidQty > 0) {
                const drop = ((prevBidQty - bestBidQty) / prevBidQty) * 100;
                if (drop >= depthState.liquidityDropPct) {
                    liquiditySignal = `Bid pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'sell';
                }
            }
            if (Number.isFinite(prevAskQty) && Number.isFinite(bestAskQty) && prevAskQty > 0) {
                const drop = ((prevAskQty - bestAskQty) / prevAskQty) * 100;
                if (drop >= depthState.liquidityDropPct) {
                    liquiditySignal = `Ask pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'buy';
                }
            }
            updateSignalBadge(depthUi.signalLiquidity, liquiditySignal, liquidityType);

            const momentumScore = Math.min(30, Math.abs(momentum) / depthState.momentumThreshold * 30);
            const imbalanceScore = Number.isFinite(imbalance) ? Math.min(20, Math.abs(imbalance) / 100 * 20) : 0;
            let spreadScore = 10;
            if (Number.isFinite(spread)) {
                if (spread <= depthState.spreadTight) spreadScore = 20;
                else if (spread >= depthState.spreadWide) spreadScore = 5;
                else if (spreadSignal === 'Spread compress') spreadScore = 18;
            }
            let liquidityScore = 8;
            if (liquidityType !== 'neutral') liquidityScore = 15;
            let gammaScore = 0;
            if (depthState.gammaLevel === 'HIGH') gammaScore = 10;
            else if (depthState.gammaLevel === 'MED') gammaScore = 6;
            let volScore = 0;
            if (depthState.volLevel === 'HIGH') volScore = 10;
            else if (depthState.volLevel === 'MED') volScore = 6;

            let gammaSqueezeScore = 0;
            let gammaSignal = 'Gamma Squeeze --';
            let gammaType = 'neutral';
            const speed = depthState.underlyingSpeed || 0;
            const accel = depthState.underlyingAccel || 0;
            const move = depthState.underlyingMove || 0;
            const tick = CONFIG.tickSize || 0.05;
            const speedTicks = Math.abs(speed) / tick;
            const accelTicks = Math.abs(accel) / tick;
            const squeezeActive = depthState.gammaLevel === 'HIGH'
                && depthState.volLevel === 'HIGH'
                && Math.abs(move) >= depthState.underlyingMovePts
                && speedTicks >= depthState.underlyingSpeedHigh
                && accelTicks >= depthState.underlyingAccelHigh;
            if (squeezeActive) {
                const direction = speed >= 0 ? 'buy' : 'sell';
                gammaSignal = `Gamma Squeeze ${direction === 'buy' ? 'Up' : 'Down'}`;
                gammaType = direction;
                gammaSqueezeScore = 12;
            }
            depthState.gammaSqueezeActive = squeezeActive;
            updateSignalBadge(depthUi.signalGamma, gammaSignal, gammaType);

            const score = momentumScore + imbalanceScore + spreadScore + liquidityScore + gammaScore + volScore + gammaSqueezeScore;
            updateScalpScore(score);
        }

        function updateDepthHint() {
            if (!depthUi.hint) return;
            if (!depthState.enabled) {
                depthUi.hint.textContent = 'Depth disabled.';
                return;
            }
            const requested = depthState.requestedLevel || depthState.level || 5;
            const actual = depthState.level || requested;
            if (actual !== requested) {
                depthUi.hint.textContent = `Requested ${requested}L, broker delivered ${actual}L (fallback).`;
            } else {
                depthUi.hint.textContent = 'Read-only. Proxies are experimental.';
            }
        }

        function clearDepthUI() {
            setDepthText(depthUi.topBid, '--');
            setDepthText(depthUi.topAsk, '--');
            setDepthText(depthUi.spread, '--');
            setDepthText(depthUi.imbalance, '--');
            updateDepthAlert(null);
            updateGreeksProxyUI(depthUi.gammaProxy, '--');
            updateGreeksProxyUI(depthUi.volProxy, '--');
            updateScalpScore(0);
            for (let i = 0; i < depthDomCache.maxRows; i++) {
                setDepthText(depthDomCache.bidQty[i], '--');
                setDepthText(depthDomCache.bidPrice[i], '--');
                setDepthText(depthDomCache.askPrice[i], '--');
                setDepthText(depthDomCache.askQty[i], '--');
                if (depthDomCache.rows[i]) depthDomCache.rows[i].style.background = 'transparent';
            }
            updateSignalBadge(depthUi.signalGamma, 'Gamma Squeeze --', 'neutral');
            clearDepthSelection();
            updateDepthQuickUI();
        }

        function subscribeDepth(symbolOverride) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            const symbol = symbolOverride || state.symbol;
            if (!symbol || !state.exchange) return;
            state.ws.send(JSON.stringify({
                action: 'subscribe',
                symbols: [{ symbol: symbol, exchange: state.exchange }],
                mode: 'Depth',
                depth: depthState.level
            }));
        }

        function unsubscribeDepth(symbolOverride) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            const symbol = symbolOverride || state.symbol;
            if (!symbol || !state.exchange) return;
            state.ws.send(JSON.stringify({
                action: 'unsubscribe',
                symbols: [{ symbol: symbol, exchange: state.exchange }],
                mode: 'Depth'
            }));
        }

        function handleDepthMessage(message) {
            if (!depthState.enabled) return;
            if (!message || message.symbol !== state.symbol) return;
            const depth = message.data?.depth || message.depth || {};
            const bids = depth.buy || depth.bids || [];
            const asks = depth.sell || depth.asks || [];
            const level = message.data?.depth_level || message.depth_level || depthState.level;
            const timestamp = message.data?.timestamp || message.timestamp || Date.now();

            depthState.pending = { bids, asks, level, timestamp };
            scheduleDepthRender();
        }

        function scheduleDepthRender() {
            if (depthState.scheduled) return;
            depthState.scheduled = true;
            requestAnimationFrame(() => {
                depthState.scheduled = false;
                const now = performance.now();
                const elapsed = now - depthState.lastRender;
                if (elapsed < PERF.depthThrottleMs) {
                    setTimeout(scheduleDepthRender, PERF.depthThrottleMs - elapsed);
                    return;
                }
                depthState.lastRender = now;
                const payload = depthState.pending;
                if (!payload) return;
                renderDepth(payload);
            });
        }

        function renderDepth(payload) {
            const bids = Array.isArray(payload.bids) ? payload.bids : [];
            const asks = Array.isArray(payload.asks) ? payload.asks : [];
            let level = Math.min(depthDomCache.maxRows, parseInt(payload.level, 10) || depthState.level || 5);
            depthState.lastUpdate = payload.timestamp || Date.now();
            if (Number.isFinite(level) && level > 0 && level !== depthState.level) {
                depthState.level = level;
                if (depthUi.levelSelect) {
                    depthUi.levelSelect.value = String(level);
                }
                updateDepthHint();
            }

            let bestBid = null;
            let bestAsk = null;
            let bestBidQty = null;
            let bestAskQty = null;
            let bidTotal = 0;
            let askTotal = 0;

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = depthDomCache.rows[i];
                if (!row) continue;
                const visible = i < level;
                if (visible) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                    continue;
                }

                const bid = parseDepthEntry(bids[i]);
                const ask = parseDepthEntry(asks[i]);

                const bidQty = bid ? formatDepthQty(bid.qty) : '--';
                const bidPrice = bid ? formatDepthPrice(bid.price) : '--';
                const askPrice = ask ? formatDepthPrice(ask.price) : '--';
                const askQty = ask ? formatDepthQty(ask.qty) : '--';

                setDepthText(depthDomCache.bidQty[i], bidQty);
                setDepthText(depthDomCache.bidPrice[i], bidPrice);
                setDepthText(depthDomCache.askPrice[i], askPrice);
                setDepthText(depthDomCache.askQty[i], askQty);
                depthDomCache.bidPrice[i].dataset.price = bid && bid.price ? String(bid.price) : '';
                depthDomCache.askPrice[i].dataset.price = ask && ask.price ? String(ask.price) : '';

                const bidQtyVal = bid && Number.isFinite(bid.qty) ? bid.qty : 0;
                const askQtyVal = ask && Number.isFinite(ask.qty) ? ask.qty : 0;
                const qtyTotal = bidQtyVal + askQtyVal;
                if (qtyTotal > 0) {
                    const bidPct = (bidQtyVal / qtyTotal) * 100;
                    row.style.background = `linear-gradient(90deg, rgba(0, 255, 136, 0.12) 0% ${bidPct}%, rgba(255, 107, 107, 0.12) ${bidPct}% 100%)`;
                } else {
                    row.style.background = 'transparent';
                }

                if (bid && Number.isFinite(bid.price) && bestBid === null) {
                    bestBid = bid.price;
                    bestBidQty = bid.qty;
                }
                if (ask && Number.isFinite(ask.price) && bestAsk === null) {
                    bestAsk = ask.price;
                    bestAskQty = ask.qty;
                }
                if (bid && Number.isFinite(bid.qty)) bidTotal += bid.qty;
                if (ask && Number.isFinite(ask.qty)) askTotal += ask.qty;
            }

            depthState.topBidValue = bestBid;
            depthState.topAskValue = bestAsk;

            setDepthText(depthUi.topBid, bestBid !== null ? formatDepthPrice(bestBid) : '--');
            setDepthText(depthUi.topAsk, bestAsk !== null ? formatDepthPrice(bestAsk) : '--');

            if (bestBid !== null && bestAsk !== null) {
                const spread = bestAsk - bestBid;
                setDepthText(depthUi.spread, formatDepthPrice(spread));
            } else {
                setDepthText(depthUi.spread, '--');
            }

            const total = bidTotal + askTotal;
            if (total > 0) {
                const imbalance = ((bidTotal - askTotal) / total) * 100;
                const sign = imbalance >= 0 ? '+' : '';
                setDepthText(depthUi.imbalance, `${sign}${imbalance.toFixed(0)}%`);
                updateDepthAlert(imbalance);
                updateDepthSignals(imbalance, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            } else {
                setDepthText(depthUi.imbalance, '--');
                updateDepthAlert(null);
                updateDepthSignals(null, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            }

            updateDepthStatusUI();
            updateDepthQuickUI();
        }

        function parseDepthEntry(entry) {
            if (!entry) return null;
            const price = parseFloat(
                entry.price ?? entry.rate ?? entry.prc ?? (Array.isArray(entry) ? entry[0] : undefined)
            );
            const qty = parseFloat(
                entry.quantity ?? entry.qty ?? entry.size ?? entry.volume ?? (Array.isArray(entry) ? entry[1] : undefined)
            );
            return {
                price: Number.isFinite(price) ? price : null,
                qty: Number.isFinite(qty) ? qty : null
            };
        }

        function formatDepthPrice(value) {
            if (!Number.isFinite(value)) return '--';
            return value.toFixed(2);
        }

        function formatDepthQty(value) {
            if (!Number.isFinite(value)) return '--';
            return Math.round(value).toString();
        }

        function setDepthText(element, value) {
            if (!element) return;
            if (element.textContent !== value) {
                element.textContent = value;
            }
        }

        function handleDepthRowClick(e) {
            const cell = e.target.closest('.depth-price-cell');
            if (!cell) return;
            const price = parseFloat(cell.dataset.price || cell.textContent);
            if (!Number.isFinite(price)) return;
            const index = parseInt(cell.dataset.index, 10);
            selectDepthPrice(price, Number.isFinite(index) ? index : null, cell.dataset.side || null);
        }

        function selectDepthPrice(price, rowIndex, side) {
            depthState.selectedPrice = price;
            depthState.selectedSide = side;
            depthDomCache.rows.forEach(row => row.classList.remove('selected'));
            if (Number.isFinite(rowIndex) && depthDomCache.rows[rowIndex]) {
                depthDomCache.rows[rowIndex].classList.add('selected');
                depthDomCache.rows[rowIndex].style.boxShadow = 'inset 0 0 0 1px rgba(0, 212, 255, 0.6)';
            }
            updateDepthQuickUI();
        }

        function clearDepthSelection() {
            depthState.selectedPrice = null;
            depthState.selectedSide = null;
            depthDomCache.rows.forEach(row => {
                row.classList.remove('selected');
                row.style.boxShadow = '';
            });
        }

        function isMomentumFavorable(action) {
            const m = depthState.imbalanceMomentum;
            if (!Number.isFinite(m)) return false;
            if (action === 'BUY') return m >= depthState.momentumThreshold;
            return m <= -depthState.momentumThreshold;
        }

        function getDepthOrderSpec(action, modeOverride) {
            if (Number.isFinite(depthState.selectedPrice)) {
                return { pricetype: 'LIMIT', price: depthState.selectedPrice };
            }

            let mode = modeOverride || depthState.orderMode;
            if (mode === 'TAKE' && depthState.limitOnly) {
                mode = 'JOIN';
            }
            const bestBid = depthState.topBidValue;
            const bestAsk = depthState.topAskValue;
            const spread = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? bestAsk - bestBid : null;

            if (mode === 'TAKE') {
                if (Number.isFinite(spread) && spread <= depthState.takeMaxSpread && isMomentumFavorable(action)) {
                    return { pricetype: 'MARKET', price: null };
                }
            }

            if (mode === 'STEP') {
                if (Number.isFinite(bestBid) && Number.isFinite(bestAsk)) {
                    const tick = CONFIG.tickSize || 0.05;
                    if (action === 'BUY') {
                        let price = roundToTick(bestBid + (tick * depthState.stepInTicks));
                        if (price >= bestAsk) price = bestAsk;
                        return { pricetype: 'LIMIT', price };
                    }
                    let price = roundToTick(bestAsk - (tick * depthState.stepInTicks));
                    if (price <= bestBid) price = bestBid;
                    return { pricetype: 'LIMIT', price };
                }
            }

            if (action === 'BUY') {
                return { pricetype: 'LIMIT', price: bestAsk };
            }
            return { pricetype: 'LIMIT', price: bestBid };
        }

        async function placeDepthOrder(action, options = {}) {
            const mode = options.modeOverride || depthState.orderMode;
            let spec = getDepthOrderSpec(action, mode);
            if (options.reprice && spec.pricetype === 'MARKET') {
                spec = getDepthOrderSpec(action, 'JOIN');
            }
            if (spec.pricetype === 'LIMIT' && (!Number.isFinite(spec.price) || spec.price <= 0)) {
                showToast('Depth price not available', 'error');
                return;
            }
            if (!state.apiKey) {
                showToast('API key not available', 'error');
                return;
            }
            if (spec.pricetype === 'MARKET') {
                await placeDepthSmartOrder(null, action, 'MARKET');
                return;
            }
            await placeDepthSmartOrder(spec.price, action, 'LIMIT', mode, options);
        }

        function createChartContext(side, symbol, container) {
            const overlayRoot = container?.closest('.chart-pane') || container?.parentElement || container;
            return {
                side,
                symbol,
                container,
                overlayRoot,
                chart: null,
                series: null,
                ema9Series: null,
                ema21Series: null,
                supertrendSeries: null,
                vwapSeries: null,
                candles: [],
                pendingCandle: null,
                lastCandleTime: 0,
                currentPrice: 0,
                indicatorUpdateScheduled: false,
                lastIndicatorUpdate: 0
            };
        }

        function initChartContext(ctx) {
            const container = ctx.container;
            if (!container) return;

            ctx.chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: container.clientHeight,
                layout: {
                    background: { color: '#0a0e27' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#1e2235' },
                    horzLines: { color: '#1e2235' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2d3748',
                },
                timeScale: {
                    borderColor: '#2d3748',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            ctx.series = ctx.chart.addCandlestickSeries({
                upColor: '#00ff88',
                downColor: '#ff4560',
                borderVisible: false,
                wickUpColor: '#00ff88',
                wickDownColor: '#ff4560',
            });

            ctx.ema9Series = ctx.chart.addLineSeries({
                color: '#f7c325',
                lineWidth: 1,
                title: 'EMA 9',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.ema21Series = ctx.chart.addLineSeries({
                color: '#7b61ff',
                lineWidth: 1,
                title: 'EMA 21',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.supertrendSeries = ctx.chart.addLineSeries({
                lineWidth: 2,
                title: 'ST',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.vwapSeries = ctx.chart.addLineSeries({
                color: '#00bcd4',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'VWAP',
                lastValueVisible: false,
                priceLineVisible: false,
            });

            const oneDayAgo = Math.floor(Date.now() / 1000) - (24 * 60 * 60);
            ctx.series.setData([{
                time: oneDayAgo,
                open: 100,
                high: 200,
                low: 50,
                close: 150
            }]);

            ctx.chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
                setTimeout(() => updateAllOverlays(), 50);
            });
        }

        // Initialize chart(s)
        function initChart() {
            const ceContainer = document.getElementById('chartCE');
            const peContainer = document.getElementById('chartPE');

            const split = state.splitMode && state.ceSymbol && state.peSymbol;
            if (!split && ui.chartPanePE) {
                ui.chartPanePE.style.display = 'none';
                if (ui.chartSplit) {
                    ui.chartSplit.style.gridTemplateRows = '1fr';
                }
            }

            if (split) {
                if (state.ceSymbol && ceContainer) {
                    chartContexts.CE = createChartContext('CE', state.ceSymbol, ceContainer);
                    initChartContext(chartContexts.CE);
                }
                if (state.peSymbol && peContainer) {
                    chartContexts.PE = createChartContext('PE', state.peSymbol, peContainer);
                    initChartContext(chartContexts.PE);
                }
            } else {
                const singleContainer = ceContainer || peContainer;
                if (singleContainer && state.symbol) {
                    const side = state.activeSide || (state.optionType || 'CE').toUpperCase();
                    chartContexts[side] = createChartContext(side, state.symbol, singleContainer);
                    initChartContext(chartContexts[side]);
                }
            }

            setActiveSide(state.activeSide);

            // Handle window resize
            window.addEventListener('resize', () => {
                Object.values(chartContexts).forEach(ctx => {
                    if (!ctx?.chart || !ctx.container) return;
                    ctx.chart.applyOptions({
                        width: ctx.container.clientWidth,
                        height: ctx.container.clientHeight,
                    });
                });
            });

            document.getElementById('loading').classList.add('hidden');
        }

        // Note: WebSocket connection is established in the main connectWebSocket() function below (line ~1326)

        // Update P&L
        function updatePnL() {
            if (!state.position) return;

            const qty = state.position.netqty || 0;
            const pnl = (state.currentPrice - state.entryPrice) * qty;

            const pnlElement = document.getElementById('pnlValue');
            pnlElement.textContent = `₹${pnl.toFixed(2)}`;
            pnlElement.className = 'pnl-display ' + (pnl >= 0 ? 'price-positive' : 'price-negative');
        }

        // Toast notifications
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // Event Listeners
        function setupEventListeners() {
            if (ui.sideCeBtn) {
                ui.sideCeBtn.addEventListener('click', () => setActiveSide('CE'));
            }
            if (ui.sidePeBtn) {
                ui.sidePeBtn.addEventListener('click', () => setActiveSide('PE'));
            }

            // Quantity controls
            document.getElementById('qtyPlus').addEventListener('click', () => {
                state.quantity++;
                document.getElementById('qtyValue').textContent = state.quantity;
            });

            document.getElementById('qtyMinus').addEventListener('click', () => {
                if (state.quantity > 1) {
                    state.quantity--;
                    document.getElementById('qtyValue').textContent = state.quantity;
                }
            });

            // TP/SL points inputs
            function updatePointsInput(inputId, delta) {
                const input = document.getElementById(inputId);
                if (!input) return;
                const step = parseFloat(input.step) || 0.5;
                const decimals = (step.toString().split('.')[1] || '').length;
                let current = parseFloat(input.value);
                if (!Number.isFinite(current)) {
                    current = inputId === 'tpPointsInput' ? state.tpPoints : state.slPoints;
                }
                let next = current + (delta * step);
                if (next < step) next = step;
                next = Math.round(next / step) * step;
                input.value = next.toFixed(decimals);
                if (inputId === 'tpPointsInput') {
                    state.tpPoints = next;
                } else {
                    state.slPoints = next;
                }
            }

            document.getElementById('tpPlus').addEventListener('click', () => updatePointsInput('tpPointsInput', 1));
            document.getElementById('tpMinus').addEventListener('click', () => updatePointsInput('tpPointsInput', -1));
            document.getElementById('slPlus').addEventListener('click', () => updatePointsInput('slPointsInput', 1));
            document.getElementById('slMinus').addEventListener('click', () => updatePointsInput('slPointsInput', -1));

            document.getElementById('tpPointsInput').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val > 0) {
                    state.tpPoints = val;
                } else {
                    e.target.value = state.tpPoints;
                }
            });

            document.getElementById('slPointsInput').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val > 0) {
                    state.slPoints = val;
                } else {
                    e.target.value = state.slPoints;
                }
            });

            // Order type toggle — three-way: MARKET, LIMIT, FAKELIMIT
            function setOrderType(type) {
                state.orderType = type;
                const marketBtn = document.getElementById('marketBtn');
                const limitBtn = document.getElementById('limitBtn');
                const fakeLimitBtn = document.getElementById('fakeLimitBtn');
                marketBtn.classList.remove('active', 'active-trigger');
                limitBtn.classList.remove('active', 'active-trigger');
                fakeLimitBtn.classList.remove('active', 'active-trigger');
                if (type === 'MARKET') marketBtn.classList.add('active');
                else if (type === 'LIMIT') limitBtn.classList.add('active');
                else if (type === 'FAKELIMIT') fakeLimitBtn.classList.add('active-trigger');
            }

            document.getElementById('marketBtn').addEventListener('click', () => setOrderType('MARKET'));
            document.getElementById('limitBtn').addEventListener('click', () => setOrderType('LIMIT'));
            document.getElementById('fakeLimitBtn').addEventListener('click', () => setOrderType('FAKELIMIT'));

            // BUY/SELL buttons - Interactive order placement
            document.getElementById('buyBtn').addEventListener('click', () => {
                enableFollowMode('BUY');
            });

            document.getElementById('sellBtn').addEventListener('click', () => {
                enableFollowMode('SELL');
            });

            // Close position button
            document.getElementById('btnClosePosition').addEventListener('click', () => {
                closePosition();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input field
                if (e.target.tagName === 'INPUT') return;

                const key = e.key.toLowerCase();

                if (key === 'x') {
                    // Close position with X key
                    if (state.position) {
                        closePosition();
                    }
                } else if (key === 'b') {
                    // B = BUY
                    e.preventDefault();
                    if (state.orderType === 'MARKET') {
                        // MARKET: Place immediately at current price
                        placeMarketOrder('BUY');
                    } else {
                        // LIMIT: Enable chart selection
                        enableFollowMode('BUY');
                    }
                } else if (key === 's') {
                    // S = SELL
                    e.preventDefault();
                    if (state.orderType === 'MARKET') {
                        // MARKET: Place immediately at current price
                        placeMarketOrder('SELL');
                    } else {
                        // LIMIT: Enable chart selection
                        enableFollowMode('SELL');
                    }
                } else if (key === 'x') {
                    // X = Close all positions or cancel follow mode
                    e.preventDefault();
                    if (state.followingMode) {
                        disableFollowMode();
                        showToast('Order cancelled', 'info');
                    } else {
                        // Close all positions
                        closeAllPositions();
                    }
                } else if (key === 'escape') {
                    // ESC also cancels
                    e.preventDefault();
                    if (state.followingMode) {
                        disableFollowMode();
                    }
                }
            });
        }

        // Interactive Order Placement - Cursor Following
        let followPriceLine = null;
        let followLineSide = null;

        function enableFollowMode(action) {
            if (state.followingMode) {
                // Cancel existing follow mode
                disableFollowMode();
            }

            state.followingMode = true;
            state.followingType = action;

            const isTrigger = state.orderType === 'FAKELIMIT';
            const color = isTrigger ? '#ffa500' : (action === 'BUY' ? '#00ff88' : '#ff4560');
            const titlePrefix = isTrigger ? 'TRIGGER ' : '';

            const ctx = getContextForSide(state.activeSide);
            if (!ctx || !ctx.series) return;

            // Create a price line that will follow cursor
            followPriceLine = ctx.series.createPriceLine({
                price: 100, // Initial price (will be updated on mouse move)
                color: color,
                lineWidth: 2,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: `${titlePrefix}${action}`,
            });
            followLineSide = state.activeSide;
            console.log('Created followPriceLine:', followPriceLine);

            // Change cursor
            document.getElementById('chart-container').style.cursor = 'crosshair';

            const orderLabel = isTrigger ? 'TRIGGER ' : '';
            showToast(`Click on chart to place ${orderLabel}${action} order`, 'info');
            console.log(`Follow mode enabled for ${action}`);
        }

        function disableFollowMode() {
            state.followingMode = false;
            state.followingType = null;

            if (followPriceLine) {
                const ctx = getContextForSide(followLineSide || state.activeSide);
                if (ctx?.series) {
                    ctx.series.removePriceLine(followPriceLine);
                }
                followPriceLine = null;
                followLineSide = null;
            }

            document.getElementById('chart-container').style.cursor = 'default';
        }

        function resetFollowLineForSide(side) {
            if (!state.followingMode) return;
            if (followPriceLine && followLineSide) {
                const prevCtx = getContextForSide(followLineSide);
                if (prevCtx?.series) {
                    prevCtx.series.removePriceLine(followPriceLine);
                }
            }

            const ctx = getContextForSide(side);
            if (!ctx?.series) {
                followPriceLine = null;
                followLineSide = null;
                return;
            }

            const isTrigger = state.orderType === 'FAKELIMIT';
            const color = isTrigger ? '#ffa500' : (state.followingType === 'BUY' ? '#00ff88' : '#ff4560');
            const titlePrefix = isTrigger ? 'TRIGGER ' : '';

            followPriceLine = ctx.series.createPriceLine({
                price: ctx.currentPrice || 100,
                color: color,
                lineWidth: 2,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `${titlePrefix}${state.followingType || ''}`.trim(),
            });
            followLineSide = side;
        }

        // Track crosshair position for follow line
        function setupChartInteraction() {
            console.log('setupChartInteraction called');
            Object.values(chartContexts).forEach(ctx => {
                if (!ctx?.chart || !ctx.series) return;

                ctx.chart.subscribeCrosshairMove((param) => {
                    if (!state.followingMode || !followPriceLine) return;
                    if (state.activeSide !== ctx.side) return;

                    if (param.point) {
                        const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                        const price = roundToTick(rawPrice);
                        if (price && price > 0) {
                            followPriceLine.applyOptions({ price: price });
                        }
                    }
                });

                ctx.chart.subscribeClick((param) => {
                    if (!param.point) return;

                    if (ctx.side && ctx.side !== state.activeSide) {
                        const preserveFollow = state.followingMode && (state.followingType === 'BUY' || state.followingType === 'SELL');
                        setActiveSide(ctx.side, { preserveFollow });
                    }

                    if (!state.followingMode) return;
                    if (state.followingType !== 'BUY' && state.followingType !== 'SELL') return;

                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);
                    if (price && price > 0) {
                        if (state.orderType === 'FAKELIMIT') {
                            placeFakeLimitOrder(price, state.followingType);
                        } else {
                            placeOrderAtPrice(price, state.followingType, {
                                side: ctx.side,
                                symbol: ctx.symbol,
                                ctx: ctx,
                                orderType: state.orderType
                            });
                        }
                        disableFollowMode();
                    }
                });
            });
        }

        // Place MARKET order immediately at current price
        function placeMarketOrder(action) {
            // Get current price from the last candle or state
            const currentPrice = state.currentPrice || 0;

            if (!currentPrice || currentPrice <= 0) {
                showToast('⚠️ Current price not available. Please wait...', 'error');
                return;
            }

            console.log(`Placing MARKET ${action} at current price: ₹${currentPrice}`);
            placeOrderAtPrice(currentPrice, action);
        }

        function computeTPSLPrices(basePrice, action, tpPoints, slPoints) {
            const tpPrice = action === 'BUY' ? basePrice + tpPoints : basePrice - tpPoints;
            const slPrice = action === 'BUY' ? basePrice - slPoints : basePrice + slPoints;
            return { tpPrice, slPrice };
        }

        function createAutoTPSLLines(ctx, basePrice, action, tpPoints, slPoints) {
            if (!ctx?.series) return { tpOrder: null, slOrder: null };
            const { tpPrice, slPrice } = computeTPSLPrices(basePrice, action, tpPoints, slPoints);
            const tpLine = ctx.series.createPriceLine({
                price: tpPrice,
                color: '#00ff88',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `TP @ ${tpPrice.toFixed(2)}`
            });
            const slLine = ctx.series.createPriceLine({
                price: slPrice,
                color: '#ff4560',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `SL @ ${slPrice.toFixed(2)}`
            });
            return {
                tpOrder: { price: tpPrice, priceLine: tpLine },
                slOrder: { price: slPrice, priceLine: slLine }
            };
        }

        function attachOrderTPSLOverlays(orderData) {
            if (!orderData) return;
            if (orderData.tpOrder?.priceLine && !orderData.tpOrder.overlay) {
                orderData.tpOrder.overlay = createOrderTPSLOverlay(orderData, 'TP');
            }
            if (orderData.slOrder?.priceLine && !orderData.slOrder.overlay) {
                orderData.slOrder.overlay = createOrderTPSLOverlay(orderData, 'SL');
            }
        }

        function removeOrderTPSL(orderData, type) {
            if (!orderData) return;
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            if (!ctx?.series) return;

            if (type === 'TP') {
                if (orderData.tpOrder?.priceLine) {
                    ctx.series.removePriceLine(orderData.tpOrder.priceLine);
                }
                if (orderData.tpOrder?.overlay) {
                    orderData.tpOrder.overlay.remove();
                }
                orderData.tpOrder = null;
                orderData.tpAuto = false;
            } else {
                if (orderData.slOrder?.priceLine) {
                    ctx.series.removePriceLine(orderData.slOrder.priceLine);
                }
                if (orderData.slOrder?.overlay) {
                    orderData.slOrder.overlay.remove();
                }
                orderData.slOrder = null;
                orderData.slAuto = false;
            }
        }

        function createOrderTPSLOverlay(orderData, type) {
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            const tpsl = type === 'TP' ? orderData.tpOrder : orderData.slOrder;
            if (!ctx?.series || !tpsl || !Number.isFinite(tpsl.price)) return null;

            const overlay = document.createElement('div');
            overlay.className = 'tpsl-line-overlay';
            overlay.dataset.orderId = orderData.orderId || orderData.id || '';
            overlay.dataset.tpslType = type;

            const label = document.createElement('div');
            label.className = `order-line-label ${type === 'TP' ? 'buy' : 'sell'}`;
            label.textContent = `${type} @ ₹${tpsl.price.toFixed(2)}`;
            overlay.appendChild(label);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'tpsl-close';
            closeBtn.type = 'button';
            closeBtn.textContent = '×';
            closeBtn.title = `Remove ${type}`;
            closeBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                removeOrderTPSL(orderData, type);
            });
            overlay.appendChild(closeBtn);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, tpsl.price, ctx);

            setupOrderTPSLDraggable(overlay, orderData, type);
            return overlay;
        }

        function setupOrderTPSLDraggable(overlay, orderData, type) {
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            if (!ctx?.series) return;
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                const tpsl = type === 'TP' ? orderData.tpOrder : orderData.slOrder;
                if (!tpsl) return;
                startY = e.clientY;
                startPrice = tpsl.price;

                const onMouseMove = (e) => {
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        tpsl.price = newPrice;
                        tpsl.priceLine?.applyOptions({
                            price: newPrice,
                            title: `${type} @ ${newPrice.toFixed(2)}`
                        });
                        if (type === 'TP') {
                            orderData.tpAuto = false;
                        } else {
                            orderData.slAuto = false;
                        }
                        updateOverlayPosition(overlay, newPrice, ctx);
                        const label = overlay.querySelector('.order-line-label');
                        if (label) {
                            label.textContent = `${type} @ ₹${newPrice.toFixed(2)}`;
                        }
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function updateAutoTPSLLines(orderData, basePrice) {
            if (!orderData) return;
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            const tpPoints = Number.isFinite(orderData.tpPoints) ? orderData.tpPoints : state.tpPoints;
            const slPoints = Number.isFinite(orderData.slPoints) ? orderData.slPoints : state.slPoints;
            const { tpPrice, slPrice } = computeTPSLPrices(basePrice, orderData.action, tpPoints, slPoints);

            const tpAuto = orderData.tpAuto !== false;
            const slAuto = orderData.slAuto !== false;

            if (tpAuto && orderData.tpOrder?.priceLine) {
                orderData.tpOrder.price = tpPrice;
                orderData.tpOrder.priceLine.applyOptions({
                    price: tpPrice,
                    title: `TP @ ${tpPrice.toFixed(2)}`
                });
                if (orderData.tpOrder?.overlay) {
                    updateOverlayPosition(orderData.tpOrder.overlay, tpPrice, ctx);
                    const label = orderData.tpOrder.overlay.querySelector('.order-line-label');
                    if (label) label.textContent = `TP @ ₹${tpPrice.toFixed(2)}`;
                }
            } else if (tpAuto) {
                const lines = createAutoTPSLLines(ctx, basePrice, orderData.action, tpPoints, slPoints);
                orderData.tpOrder = lines.tpOrder;
                orderData.slOrder = lines.slOrder;
                attachOrderTPSLOverlays(orderData);
                return;
            }

            if (slAuto && orderData.slOrder?.priceLine) {
                orderData.slOrder.price = slPrice;
                orderData.slOrder.priceLine.applyOptions({
                    price: slPrice,
                    title: `SL @ ${slPrice.toFixed(2)}`
                });
                if (orderData.slOrder?.overlay) {
                    updateOverlayPosition(orderData.slOrder.overlay, slPrice, ctx);
                    const label = orderData.slOrder.overlay.querySelector('.order-line-label');
                    if (label) label.textContent = `SL @ ₹${slPrice.toFixed(2)}`;
                }
            }
        }

        // Place order at specific price
        async function placeOrderAtPrice(price, action, options = {}) {
            const symbol = options.symbol || state.symbol;
            const side = options.side || state.activeSide;
            const orderType = options.orderType || state.orderType;
            const ctx = options.ctx || getContextForSide(side);

            console.log(`Placing ${action} order at ₹${price.toFixed(2)}`);

            // Use lot size from URL params (passed from main interface)
            const actualQuantity = state.quantity * state.lotSize;
            console.log(`Quantity: ${state.quantity} lots × ${state.lotSize} = ${actualQuantity}`);

            const orderData = {
                apikey: state.apiKey,
                strategy: 'chart_trading',
                exchange: state.exchange, // Already mapped to NFO/BFO
                symbol: symbol,
                action: action,
                quantity: String(actualQuantity),
                pricetype: orderType,
                product: 'MIS'
            };

            // Add price for LIMIT orders (use clicked price)
            if (orderType === 'LIMIT') {
                orderData.price = price.toFixed(2);
                console.log(`LIMIT order - using clicked price: ₹${price.toFixed(2)}`);
            }

            try {
                showToast(`Placing ${action} order...`, 'info');

                console.log('Order data:', orderData);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 sec timeout for order placement

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();
                console.log('Order response:', result);

                if (result.status === 'success') {
                    showToast(`✅ ${action} order placed at ₹${price.toFixed(2)}`, 'success');

                    // Draw order line on chart immediately
                    drawOrderLine(price, action, result.orderid, orderType, side, ctx);

                    // For MARKET orders, check fill immediately (don't wait for 5s poll)
                    if (orderType === 'MARKET') {
                        setTimeout(() => checkOrderFills(), 200);
                    }
                } else {
                    showToast(`❌ Order failed: ${result.message}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Order timeout - broker server slow', 'error');
                } else {
                    console.error('Error placing order:', error);
                    showToast(`❌ Order failed: ${error.message}`, 'error');
                }
            }
        }

        // Depth panel: place smart order directly from order book price (does not change UI order type)
        async function placeDepthSmartOrder(price, action, pricetype, mode, options = {}) {
            const actualQuantity = state.quantity * state.lotSize;
            const orderData = {
                apikey: state.apiKey,
                strategy: 'chart_trading',
                exchange: state.exchange,
                symbol: state.symbol,
                action: action,
                quantity: String(actualQuantity),
                pricetype: pricetype,
                product: 'MIS',
                price: pricetype === 'LIMIT' ? price.toFixed(2) : undefined
            };

            try {
                const label = pricetype === 'MARKET' ? 'market' : 'limit';
                showToast(`Placing ${action} ${label}...`, 'info');

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 sec timeout

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    const orderId = result.orderid || result.order_id || `DEPTH_${Date.now()}`;
                    if (pricetype === 'LIMIT') {
                        drawOrderLine(price, action, orderId, 'LIMIT', state.activeSide, getContextForSide(state.activeSide));
                        showToast(`✅ ${action} limit placed at ₹${price.toFixed(2)}`, 'success');
                        if (depthState.repriceEnabled && !Number.isFinite(depthState.selectedPrice)) {
                            const retriesLeft = Number.isFinite(options.retriesLeft) ? options.retriesLeft : depthState.repriceMaxRetries;
                            scheduleDepthReprice(orderId, action, mode || depthState.orderMode, retriesLeft);
                        }
                    } else {
                        showToast(`✅ ${action} market order placed`, 'success');
                    }
                } else {
                    showToast(`❌ Order failed: ${result.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Order timeout - broker server slow', 'error');
                } else {
                    console.error('Error placing depth order:', error);
                    showToast(`❌ Order failed: ${error.message}`, 'error');
                }
            }
        }

        async function isOrderOpen(orderId) {
            try {
                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });
                const result = await response.json();
                if (result.status !== 'success' || !result.data || !result.data.orders) return false;
                const order = result.data.orders.find(o => String(o.orderid) === String(orderId));
                if (!order) return false;
                const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();
                return status === 'OPEN' ||
                    status === 'PENDING' ||
                    status === 'TRIGGER PENDING' ||
                    status === 'PENDING ORDER' ||
                    status === 'NOT EXECUTED';
            } catch (error) {
                console.error('Error checking order status:', error);
                return false;
            }
        }

        function updateDepthOrderVisual(orderId, newPrice) {
            const order = state.orders.get(orderId);
            if (!order) return;
            order.price = newPrice;
            if (order.priceLine) {
                order.priceLine.applyOptions({ price: newPrice });
            }
            if (order.overlay) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                updateOverlayPosition(order.overlay, newPrice, ctx);
                const label = order.overlay.querySelector('.order-line-label');
                if (label) {
                    label.textContent = `${order.action} @ ₹${newPrice.toFixed(2)}`;
                }
            }
            if (order.type === 'LIMIT') {
                updateAutoTPSLLines(order, newPrice);
            }
        }

        function scheduleDepthReprice(orderId, action, mode, retriesLeft) {
            if (!depthState.repriceEnabled || !depthState.enabled) return;
            if (!Number.isFinite(retriesLeft) || retriesLeft <= 0) return;
            setTimeout(async () => {
                if (!depthState.repriceEnabled || !depthState.enabled) return;
                const stillOpen = await isOrderOpen(orderId);
                if (!stillOpen) return;

                const spec = getDepthOrderSpec(action, mode);
                if (spec.pricetype !== 'LIMIT' || !Number.isFinite(spec.price)) return;

                updateDepthOrderVisual(orderId, spec.price);
                await modifyOrder(orderId, spec.price, state.orders.get(orderId)?.symbol);

                scheduleDepthReprice(orderId, action, mode, retriesLeft - 1);
            }, Math.max(100, depthState.repriceMs));
        }

        // ========== FAKE LIMIT (VIRTUAL TRIGGER) ORDERS ==========

        function placeFakeLimitOrder(triggerPrice, action) {
            const side = state.activeSide;
            const ctx = getContextForSide(side);
            const priceAtPlacement = ctx?.currentPrice || state.currentPrice;
            if (!ctx?.series) {
                showToast('Chart not ready yet', 'error');
                return;
            }

            // Direction based on action: BUY fires when price rises (>=), SELL fires when price drops (<=)
            const direction = action === 'BUY' ? 'ABOVE' : 'BELOW';

            // Prevent triggers that would fire immediately (only validate if we have a live price)
            if (priceAtPlacement > 0) {
                if (action === 'BUY' && priceAtPlacement >= triggerPrice) {
                    showToast(`BUY trigger must be above current price (₹${priceAtPlacement.toFixed(2)})`, 'error');
                    return;
                }
                if (action === 'SELL' && priceAtPlacement <= triggerPrice) {
                    showToast(`SELL trigger must be below current price (₹${priceAtPlacement.toFixed(2)})`, 'error');
                    return;
                }
            }

            const id = `fakelimit_${++state.fakeLimitIdCounter}`;
            const actualQuantity = state.quantity * state.lotSize;

            console.log(`[TRIGGER] Placing: ${action} at ₹${triggerPrice.toFixed(2)} (LTP ₹${priceAtPlacement.toFixed(2)}, ${direction})`);

            const { priceLine, overlay } = drawFakeLimitLine(ctx, triggerPrice, action, id);
            const autoLines = createAutoTPSLLines(ctx, triggerPrice, action, state.tpPoints, state.slPoints);

            state.fakeLimitOrders.set(id, {
                id,
                action,
                triggerPrice,
                priceAtPlacement,
                direction,
                side,
                symbol: ctx?.symbol || state.symbol,
                ctx,
                quantity: actualQuantity,
                lots: state.quantity,
                priceLine,
                overlay,
                tpOrder: autoLines.tpOrder,
                slOrder: autoLines.slOrder,
                tpPoints: state.tpPoints,
                slPoints: state.slPoints,
                tpAuto: true,
                slAuto: true,
                createdAt: Date.now()
            });

            const orderData = state.fakeLimitOrders.get(id);
            attachOrderTPSLOverlays(orderData);

            showToast(`Trigger ${action} at ₹${triggerPrice.toFixed(2)} (fires when LTP ${action === 'BUY' ? '>=' : '<='} ₹${triggerPrice.toFixed(2)})`, 'success');
        }

        function drawFakeLimitLine(ctx, price, action, id) {
            if (!ctx?.series) return { priceLine: null, overlay: null };
            const priceLine = ctx.series.createPriceLine({
                price: price,
                color: '#ffa500',
                lineWidth: 2,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: ''
            });

            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay fake-limit';
            overlay.dataset.fakeLimitId = id;

            // Cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.style.borderColor = '#ffa500';
            cancelBtn.style.color = '#ffa500';
            cancelBtn.style.background = 'rgba(255, 165, 0, 0.2)';
            cancelBtn.textContent = '\u2715';
            cancelBtn.title = 'Cancel trigger order';
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginRight = '8px';
            cancelBtn.style.flexShrink = '0';
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                cancelFakeLimitOrder(id);
            });
            overlay.appendChild(cancelBtn);

            // Label
            const label = document.createElement('div');
            label.className = `order-line-label trigger-${action.toLowerCase()}`;
            label.textContent = `TRIGGER ${action} @ \u20B9${price.toFixed(2)}`;
            overlay.appendChild(label);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            setupFakeLimitDraggable(overlay, id);

            return { priceLine, overlay };
        }

        function setupFakeLimitDraggable(overlay, fakeLimitId) {
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (e.target.classList.contains('order-close-btn')) return;
                e.preventDefault();
                e.stopPropagation();

                const orderData = state.fakeLimitOrders.get(fakeLimitId);
                if (!orderData) return;

                overlay.classList.add('dragging');
                startY = e.clientY;
                startPrice = orderData.triggerPrice;

                const onMouseMove = (e) => {
                    const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
                    if (!ctx?.series) return;
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        orderData.triggerPrice = newPrice;
                        orderData.priceLine.applyOptions({ price: newPrice });
                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent =
                            `TRIGGER ${orderData.action} @ \u20B9${newPrice.toFixed(2)}`;
                        updateAutoTPSLLines(orderData, newPrice);
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    const orderData = state.fakeLimitOrders.get(fakeLimitId);
                    if (orderData && Math.abs(orderData.triggerPrice - startPrice) > 0.01) {
                        showToast(`Trigger moved to \u20B9${orderData.triggerPrice.toFixed(2)}`, 'info');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function cancelFakeLimitOrder(id) {
            const order = state.fakeLimitOrders.get(id);
            if (!order) return;

            const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
            if (order.priceLine) {
                ctx?.series?.removePriceLine(order.priceLine);
            }
            if (order.overlay) {
                order.overlay.remove();
            }
            if (order.tpOrder?.priceLine) {
                ctx?.series?.removePriceLine(order.tpOrder.priceLine);
            }
            if (order.slOrder?.priceLine) {
                ctx?.series?.removePriceLine(order.slOrder.priceLine);
            }
            if (order.tpOrder?.overlay) {
                order.tpOrder.overlay.remove();
            }
            if (order.slOrder?.overlay) {
                order.slOrder.overlay.remove();
            }
            state.fakeLimitOrders.delete(id);
            showToast('Trigger order cancelled', 'info');
        }

        function checkFakeLimitTriggers() {
            if (state.fakeLimitOrders.size === 0) return;

            for (const [id, order] of [...state.fakeLimitOrders.entries()]) {
                const ctx = order.ctx || getContextForSide(order.side);
                const ltp = ctx?.currentPrice || 0;
                if (!ltp || ltp <= 0) continue;
                // BUY triggers when price rises to level (>=), SELL triggers when price drops to level (<=)
                const triggered = order.action === 'BUY'
                    ? ltp >= order.triggerPrice
                    : ltp <= order.triggerPrice;

                if (triggered) {
                    console.log(`[TRIGGER] FIRED: ${order.action} at LTP=${ltp}, trigger=${order.triggerPrice}, dir=${order.direction}`);
                    executeFakeLimitOrder(id, order);
                }
            }
        }

        async function executeFakeLimitOrder(id, order) {
            const pendingTPSL = {
                tpOrder: order.tpOrder,
                slOrder: order.slOrder,
                tpPoints: order.tpPoints,
                slPoints: order.slPoints
            };

            const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
            const symbol = order.symbol || ctx?.symbol || state.symbol;

            // Remove visual trigger line immediately (keep TP/SL lines)
            if (order.priceLine) {
                ctx?.series?.removePriceLine(order.priceLine);
            }
            if (order.overlay) {
                order.overlay.remove();
            }
            state.fakeLimitOrders.delete(id);

            showToast(`Trigger fired! Placing MARKET ${order.action}...`, 'info');

            const orderData = {
                apikey: state.apiKey,
                strategy: 'chart_trigger',
                exchange: state.exchange,
                symbol: symbol,
                action: order.action,
                quantity: String(order.quantity),
                pricetype: 'MARKET',
                product: 'MIS',
                price: '0',
                trigger_price: '0',
                disclosed_quantity: '0'
            };

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000);

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`\u2705 Trigger ${order.action} executed! OrderID: ${result.orderid}`, 'success');

                    // Temporarily use the TP/SL values from when the trigger was placed
                    const savedTP = state.tpPoints;
                    const savedSL = state.slPoints;
                    state.tpPoints = order.tpPoints;
                    state.slPoints = order.slPoints;

                    // Draw order line so checkOrderFills() tracks fill + auto TP/SL
                    drawOrderLine(ctx?.currentPrice || state.currentPrice, order.action, result.orderid, 'MARKET', order.side, ctx);

                    state.tpPoints = savedTP;
                    state.slPoints = savedSL;

                    const trackedOrder = state.orders.get(result.orderid);
                    if (trackedOrder && pendingTPSL) {
                        trackedOrder.tpOrder = pendingTPSL.tpOrder || trackedOrder.tpOrder;
                        trackedOrder.slOrder = pendingTPSL.slOrder || trackedOrder.slOrder;
                        trackedOrder.tpPoints = pendingTPSL.tpPoints;
                        trackedOrder.slPoints = pendingTPSL.slPoints;
                        trackedOrder.tpAuto = order.tpAuto !== false;
                        trackedOrder.slAuto = order.slAuto !== false;
                    }

                    // Immediate fill check for MARKET order
                    setTimeout(() => checkOrderFills(), 200);
                } else {
                    showToast(`\u274C Trigger ${order.action} failed: ${result.message}`, 'error');
                    if (pendingTPSL.tpOrder?.priceLine) {
                        ctx?.series?.removePriceLine(pendingTPSL.tpOrder.priceLine);
                    }
                    if (pendingTPSL.slOrder?.priceLine) {
                        ctx?.series?.removePriceLine(pendingTPSL.slOrder.priceLine);
                    }
                    if (pendingTPSL.tpOrder?.overlay) {
                        pendingTPSL.tpOrder.overlay.remove();
                    }
                    if (pendingTPSL.slOrder?.overlay) {
                        pendingTPSL.slOrder.overlay.remove();
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('\u274C Trigger order timeout - broker slow', 'error');
                } else {
                    showToast(`\u274C Trigger order error: ${error.message}`, 'error');
                }
                if (pendingTPSL.tpOrder?.priceLine) {
                    ctx?.series?.removePriceLine(pendingTPSL.tpOrder.priceLine);
                }
                if (pendingTPSL.slOrder?.priceLine) {
                    ctx?.series?.removePriceLine(pendingTPSL.slOrder.priceLine);
                }
                if (pendingTPSL.tpOrder?.overlay) {
                    pendingTPSL.tpOrder.overlay.remove();
                }
                if (pendingTPSL.slOrder?.overlay) {
                    pendingTPSL.slOrder.overlay.remove();
                }
            }
        }

        // ========== END FAKE LIMIT ==========

        function drawOrderLine(price, action, orderId, orderTypeOverride, sideOverride, ctxOverride) {
            const orderType = orderTypeOverride || state.orderType;
            const side = sideOverride || state.activeSide;
            const ctx = ctxOverride || getContextForSide(side);
            if (!ctx?.series) return;

            // Create lightweight charts price line
            const color = action === 'BUY' ? '#00ff88' : '#ff4560';
            const priceLine = ctx.series.createPriceLine({
                price: price,
                color: color,
                lineWidth: 2,
                lineStyle: 0, // Solid
                axisLabelVisible: true,
                title: '' // No title - we use the HTML overlay label instead
            });

            // Create HTML overlay for dragging and controls
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.dataset.orderId = orderId;

            // Cancel button (X mark) on the left
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.textContent = '✕';
            cancelBtn.title = 'Cancel order';
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginRight = '8px'; // Space between X and label
            cancelBtn.style.flexShrink = '0'; // Don't shrink
            // Use mousedown to prevent overlay drag from starting
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            // Use click for actual cancellation
            const orderSymbol = ctx.symbol || state.symbol;
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                cancelSingleOrder(orderId, orderSymbol);
            });
            overlay.appendChild(cancelBtn);

            // Order label (next to X button)
            const label = document.createElement('div');
            label.className = `order-line-label ${action.toLowerCase()}`;
            label.textContent = `${action} @ ₹${price.toFixed(2)}`;
            overlay.appendChild(label);

            // P&L label (will show when position fills)
            const pnlLabel = document.createElement('div');
            pnlLabel.className = 'pnl-label';
            pnlLabel.style.display = 'none';
            pnlLabel.style.marginLeft = 'auto'; // Push to the right
            overlay.appendChild(pnlLabel);

            // Add to chart
            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            // Store order data
            const orderData = {
                orderId,
                type: orderType,
                action,
                price,
                side,
                symbol: orderSymbol,
                ctx,
                quantity: state.quantity * state.lotSize,
                status: 'pending',
                priceLine,
                overlay,
                pnlLabel,
                tpOrder: null,
                slOrder: null,
                tpPoints: state.tpPoints,
                slPoints: state.slPoints,
                tpAuto: true,
                slAuto: true
            };

            if (orderType === 'LIMIT') {
                const autoLines = createAutoTPSLLines(ctx, price, action, orderData.tpPoints, orderData.slPoints);
                orderData.tpOrder = autoLines.tpOrder;
                orderData.slOrder = autoLines.slOrder;
                attachOrderTPSLOverlays(orderData);
            }
            state.orders.set(orderId, orderData);

            // Make draggable for LIMIT orders
            if (orderType === 'LIMIT') {
                setupDraggable(overlay, orderData);
            }

            console.log(`Order line created: ${orderId} at ₹${price}`);
        }

        // Update overlay position
        function updateOverlayPosition(overlay, price, ctx) {
            const series = ctx?.series || state.candlestickSeries;
            if (!series || !overlay) return;
            const y = series.priceToCoordinate(price);
            if (y !== null) {
                overlay.style.top = `${y}px`;
            }
        }

        // Update all overlays when chart moves
        function updateAllOverlays() {
            state.orders.forEach(order => {
                if (order.overlay) updateOverlayPosition(order.overlay, order.price, order.ctx);
                if (order.tpOrder?.overlay) updateOverlayPosition(order.tpOrder.overlay, order.tpOrder.price, order.ctx);
                if (order.slOrder?.overlay) updateOverlayPosition(order.slOrder.overlay, order.slOrder.price, order.ctx);
            });

            Object.entries(positionStates).forEach(([side, posState]) => {
                const ctx = getContextForSide(side);
                if (!ctx) return;
                if (posState.positionOverlay && posState.entryPrice) {
                    updateOverlayPosition(posState.positionOverlay, posState.entryPrice, ctx);
                }
                if (posState.positionTPSL?.tpOverlay && posState.positionTPSL?.tpPrice) {
                    updateOverlayPosition(posState.positionTPSL.tpOverlay, posState.positionTPSL.tpPrice, ctx);
                }
                if (posState.positionTPSL?.slOverlay && posState.positionTPSL?.slPrice) {
                    updateOverlayPosition(posState.positionTPSL.slOverlay, posState.positionTPSL.slPrice, ctx);
                }
            });

            state.fakeLimitOrders.forEach(order => {
                if (order.overlay) updateOverlayPosition(order.overlay, order.triggerPrice, order.ctx);
                if (order.tpOrder?.overlay) updateOverlayPosition(order.tpOrder.overlay, order.tpOrder.price, order.ctx);
                if (order.slOrder?.overlay) updateOverlayPosition(order.slOrder.overlay, order.slOrder.price, order.ctx);
            });
        }

        // Setup draggable for limit orders
        function setupDraggable(overlay, orderData) {
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                startY = e.clientY;
                startPrice = orderData.price;

                const onMouseMove = (e) => {
                    const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
                    if (!ctx?.series) return;
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        orderData.price = newPrice;
                        orderData.priceLine.applyOptions({ price: newPrice, title: `${orderData.action} @ ${newPrice.toFixed(2)}` });
                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent = `${orderData.action} @ ₹${newPrice.toFixed(2)}`;
                        if (orderData.type === 'LIMIT') {
                            updateAutoTPSLLines(orderData, newPrice);
                        }
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    if (Math.abs(orderData.price - startPrice) > 0.01) {
                        modifyOrder(orderData.orderId, orderData.price, orderData.symbol);
                        showToast(`Order modified to ₹${orderData.price.toFixed(2)}`, 'success');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // Modify order API call
        async function modifyOrder(orderId, newPrice, symbolOverride) {
            const order = state.orders.get(orderId);
            if (!order) return;
            const symbol = symbolOverride || order.symbol || state.symbol;

            try {
                const response = await fetch('/api/v1/modifyorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apikey: state.apiKey,
                        strategy: 'chart_trading',
                        exchange: state.exchange,
                        symbol: state.symbol,
                        orderid: orderId,
                        action: order.action,
                        quantity: order.quantity,
                        product: 'MIS',
                        pricetype: 'LIMIT',
                        price: newPrice.toFixed(2),
                        trigger_price: 0,
                        disclosed_quantity: 0
                    })
                });

                const result = await response.json();
                if (result.status !== 'success') {
                    showToast(`⚠️ Modify failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error modifying order:', error);
            }
        }

        // Show order controls popup
        let currentPopup = null;
        function showOrderControls(orderData, x, y) {
            // Remove existing popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            const popup = document.createElement('div');
            popup.className = 'order-controls-popup';
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;

            // Set TP button
            const tpBtn = document.createElement('button');
            tpBtn.className = 'set-tp-btn';
            tpBtn.textContent = orderData.tpOrder ? '✓ TP Set' : 'Set TP';
            tpBtn.addEventListener('click', () => {
                enableTPSLMode(orderData, 'TP');
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(tpBtn);

            // Set SL button
            const slBtn = document.createElement('button');
            slBtn.className = 'set-sl-btn';
            slBtn.textContent = orderData.slOrder ? '✓ SL Set' : 'Set SL';
            slBtn.addEventListener('click', () => {
                enableTPSLMode(orderData, 'SL');
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(slBtn);

            // Close order button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-order-btn';
            closeBtn.textContent = '✕ Close Order';
            closeBtn.addEventListener('click', () => {
                closeOrder(orderData.orderId);
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
            currentPopup = popup;

            // Close popup when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        currentPopup = null;
                        document.removeEventListener('click', closePopup);
                    }
                }, { once: true });
            }, 10);
        }

        // Enable TP/SL placement mode
        function enableTPSLMode(parentOrder, type) {
            const action = type === 'TP'
                ? (parentOrder.action === 'BUY' ? 'SELL' : 'BUY')
                : (parentOrder.action === 'BUY' ? 'SELL' : 'BUY');

            const color = type === 'TP' ? '#00ff88' : '#ff4560';
            const style = 2; // Dashed
            const ctx = parentOrder.ctx || getContextForSide(parentOrder.side) || getContextForSide(state.activeSide);
            if (!ctx?.series || !ctx?.chart) return;

            // Create follow line
            const priceLine = ctx.series.createPriceLine({
                price: parentOrder.price,
                color: color,
                lineWidth: 2,
                lineStyle: style,
                axisLabelVisible: true,
                title: `${type}`
            });

            state.followingMode = true;
            state.followingType = type;
            state.tpslParent = parentOrder;
            showToast(`Click chart to set ${type} level`, 'info');

            // Update line on mouse move
            ctx.chart.subscribeCrosshairMove((param) => {
                if (!state.followingMode || state.followingType !== type) return;

                if (param.point) {
                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);

                    if (price && price > 0) {
                        priceLine.applyOptions({ price: price });
                    }
                }
            });

            // Place TP/SL on click
            const clickHandler = (param) => {
                if (!state.followingMode || state.followingType !== type) return;

                if (param.point) {
                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);

                    if (price && price > 0) {
                        // Remove follow line
                        ctx.series.removePriceLine(priceLine);

                        // Place TP/SL order
                        placeTPSLOrder(parentOrder, type, price);

                        state.followingMode = false;
                        state.followingType = null;
                        state.tpslParent = null;
                    }
                }
            };

            ctx.chart.subscribeClick(clickHandler);
        }

        // Place TP or SL order
        async function placeTPSLOrder(parentOrder, type, price) {
            const action = type === 'TP'
                ? (parentOrder.action === 'BUY' ? 'SELL' : 'BUY')
                : (parentOrder.action === 'BUY' ? 'SELL' : 'BUY');

            // This would be a LIMIT order at the TP/SL price
            showToast(`${type} order placed at ₹${price.toFixed(2)}`, 'success');

            // For now just create the visual line
            // In production, you'd call the order API here
            const color = type === 'TP' ? '#00ff88' : '#ff4560';
            const ctx = parentOrder.ctx || getContextForSide(parentOrder.side) || getContextForSide(state.activeSide);
            if (type === 'TP' && parentOrder.tpOrder?.priceLine) {
                ctx?.series?.removePriceLine(parentOrder.tpOrder.priceLine);
                parentOrder.tpOrder = null;
            }
            if (type === 'SL' && parentOrder.slOrder?.priceLine) {
                ctx?.series?.removePriceLine(parentOrder.slOrder.priceLine);
                parentOrder.slOrder = null;
            }
            const priceLine = ctx?.series?.createPriceLine({
                price: price,
                color: color,
                lineWidth: 1,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: `${type} @ ${price.toFixed(2)}`
            });

            // Store reference
            if (type === 'TP') {
                parentOrder.tpOrder = { price, priceLine };
            } else {
                parentOrder.slOrder = { price, priceLine };
            }
        }

        // Close order/position
        async function closeOrder(orderId) {
            // TODO: Call close position API
            showToast('Closing order...', 'info');

            // Remove from chart
            const order = state.orders.get(orderId);
            if (order) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                order.priceLine && ctx?.series?.removePriceLine(order.priceLine);
                order.overlay && order.overlay.remove();
                order.tpOrder?.priceLine && ctx?.series?.removePriceLine(order.tpOrder.priceLine);
                order.slOrder?.priceLine && ctx?.series?.removePriceLine(order.slOrder.priceLine);
                order.tpOrder?.overlay && order.tpOrder.overlay.remove();
                order.slOrder?.overlay && order.slOrder.overlay.remove();
                state.orders.delete(orderId);
                showToast('Order closed', 'success');
            }
        }

        // Close all positions
        function closeAllPositions() {
            // Cancel all fake limit trigger orders
            for (const [id] of [...state.fakeLimitOrders]) {
                cancelFakeLimitOrder(id);
            }

            if (state.orders.size === 0 && state.fakeLimitOrders.size === 0) {
                showToast('No positions to close', 'info');
                return;
            }

            if (state.orders.size > 0) {
                const orderIds = Array.from(state.orders.keys());
                showToast(`Closing ${orderIds.length} position(s)...`, 'info');
                orderIds.forEach(orderId => closeOrder(orderId));
            }
        }

        // Update live P&L for all positions
        function updateLivePNL() {
            state.orders.forEach(order => {
                const ctx = order.ctx || getContextForSide(order.side);
                const ltp = ctx?.currentPrice || state.currentPrice;
                if (!ltp || ltp <= 0) return;
                if (order.status === 'filled' && order.pnlLabel) {
                    const priceDiff = order.action === 'BUY'
                        ? (ltp - order.price)
                        : (order.price - ltp);

                    const pnl = priceDiff * order.quantity;
                    const pnlPct = (priceDiff / order.price) * 100;

                    order.pnlLabel.textContent = `₹${pnl.toFixed(2)} (${pnlPct > 0 ? '+' : ''}${pnlPct.toFixed(2)}%)`;
                    order.pnlLabel.className = pnl >= 0 ? 'pnl-label profit' : 'pnl-label loss';
                    order.pnlLabel.style.display = 'block';
                }
            });
        }

        // Start P&L update interval
        setInterval(() => {
            if (state.orders.size > 0) updateLivePNL();
        }, 1000);

        // WebSocket connection for live data
        // WebSocket connection for live data
        function connectWebSocket() {
            // Use configured WebSocket URL
            const wsUrl = CONFIG.wsUrl;
            console.log('Connecting to WebSocket:', wsUrl);

            state.ws = new WebSocket(wsUrl);

            state.ws.onopen = () => {
                console.log('Chart WebSocket connected');

                // Authenticate
                state.ws.send(JSON.stringify({
                    action: 'authenticate',
                    api_key: state.apiKey
                }));
            };

            state.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                // Debug: Log ALL WebSocket messages
                debugLog('📨 WS Message:', data);

                // Handle auth response
                if (data.type === 'auth' && data.status === 'success') {
                    debugLog('✅ Chart authenticated, subscribing to', state.symbol, 'on', state.exchange);
                    depthState.broker = data.broker || depthState.broker;
                    updateDepthBrokerUI();
                    const ltpSymbols = [];
                    if (state.ceSymbol) {
                        ltpSymbols.push({ symbol: state.ceSymbol, exchange: state.exchange });
                    }
                    if (state.peSymbol && state.peSymbol !== state.ceSymbol) {
                        ltpSymbols.push({ symbol: state.peSymbol, exchange: state.exchange });
                    }
                    if (ltpSymbols.length === 0 && state.symbol) {
                        ltpSymbols.push({ symbol: state.symbol, exchange: state.exchange });
                    }
                    // Subscribe to LTP for both sides
                    state.ws.send(JSON.stringify({
                        action: 'subscribe',
                        symbols: ltpSymbols,
                        mode: 'LTP'
                    }));
                    if (state.underlying && state.underlyingExchange && state.underlying !== state.symbol) {
                        state.ws.send(JSON.stringify({
                            action: 'subscribe',
                            symbols: [{
                                symbol: state.underlying,
                                exchange: state.underlyingExchange
                            }],
                            mode: 'LTP'
                        }));
                    }
                    if (depthState.enabled) {
                        subscribeDepth();
                    }
                }
                // Handle subscription confirmation
                else if (data.status === 'subscribed') {
                    debugLog('✅ Subscribed to', data.count, 'symbols');
                }
                else if (data.type === 'subscribe' && Array.isArray(data.subscriptions)) {
                    const depthSub = data.subscriptions.find(sub =>
                        (sub.mode === 'Depth' || sub.mode === 3) &&
                        sub.symbol === state.symbol
                    );
                    if (depthSub && depthSub.depth) {
                        depthState.level = parseInt(depthSub.depth, 10) || depthState.level;
                        if (depthUi.levelSelect) {
                            depthUi.levelSelect.value = String(depthState.level);
                        }
                        updateDepthHint();
                    }
                }
                // Handle market data
                else if (data.type === 'market_data' && (data.symbol === state.ceSymbol || data.symbol === state.peSymbol || data.symbol === state.symbol)) {
                    const side = getSideForSymbol(data.symbol) || state.activeSide;
                    if ((data.mode === 3 || data.data?.depth) && side === state.activeSide) {
                        handleDepthMessage(data);
                    }
                    if (data.data?.ltp != null) {
                        debugLog('📊 Market data (nested):', data.data);
                        handleMarketData(data.data, side);
                    } else if (data.ltp != null) {
                        debugLog('📊 Market data (flat):', data);
                        handleMarketData(data, side);
                    }
                }
                else if (data.type === 'market_data' && data.symbol === state.underlying) {
                    if (data.data?.ltp != null || data.ltp != null) {
                        handleUnderlyingData(data);
                    }
                }
                // Handle market data (format 2: flat ltp)
                else if ((data.symbol === state.ceSymbol || data.symbol === state.peSymbol || data.symbol === state.symbol) && data.ltp) {
                    debugLog('📊 Market data (flat):', data);
                    const side = getSideForSymbol(data.symbol) || state.activeSide;
                    handleMarketData(data, side);
                }
                else if (data.symbol === state.underlying && data.ltp) {
                    handleUnderlyingData(data);
                }
                else {
                    debugLog('⚠️ Unhandled message type:', data.type, data);
                }
            };

            state.ws.onclose = () => {
                console.log('Chart WebSocket closed, reconnecting in 5s...');
                updateDepthStatusUI();
                setTimeout(connectWebSocket, 5000);
            };

            state.ws.onerror = (error) => {
                console.error('Chart WebSocket error:', error);
            };
        }

        // ========== TECHNICAL INDICATORS ==========

        // Calculate EMA from candle closes
        function calculateEMA(candles, period) {
            if (candles.length < period) return [];
            const multiplier = 2 / (period + 1);
            const result = [];

            // Seed with SMA of first `period` candles
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += candles[i].close;
            }
            let ema = sum / period;
            result.push({ time: candles[period - 1].time, value: ema });

            // EMA for remaining candles
            for (let i = period; i < candles.length; i++) {
                ema = (candles[i].close - ema) * multiplier + ema;
                result.push({ time: candles[i].time, value: ema });
            }
            return result;
        }

        // Calculate Supertrend (ATR period=10, multiplier=3)
        function calculateSupertrend(candles, atrPeriod = 10, mult = 3) {
            if (candles.length < atrPeriod + 1) return [];

            // Calculate True Range
            const tr = [0]; // first TR = high - low
            tr[0] = candles[0].high - candles[0].low;
            for (let i = 1; i < candles.length; i++) {
                const hl = candles[i].high - candles[i].low;
                const hpc = Math.abs(candles[i].high - candles[i - 1].close);
                const lpc = Math.abs(candles[i].low - candles[i - 1].close);
                tr.push(Math.max(hl, hpc, lpc));
            }

            // Calculate ATR using RMA (Wilder's smoothing)
            let atr = 0;
            for (let i = 0; i < atrPeriod; i++) {
                atr += tr[i];
            }
            atr /= atrPeriod;

            const atrValues = new Array(atrPeriod - 1).fill(0);
            atrValues.push(atr);
            for (let i = atrPeriod; i < candles.length; i++) {
                atr = (atr * (atrPeriod - 1) + tr[i]) / atrPeriod;
                atrValues.push(atr);
            }

            // Calculate Supertrend
            const result = [];
            let upperBand = 0, lowerBand = 0;
            let prevUpperBand = 0, prevLowerBand = 0;
            let trend = 1; // 1 = up, -1 = down

            for (let i = atrPeriod - 1; i < candles.length; i++) {
                const hl2 = (candles[i].high + candles[i].low) / 2;
                const atrVal = atrValues[i];

                let basicUpper = hl2 + mult * atrVal;
                let basicLower = hl2 - mult * atrVal;

                // Carry forward bands
                upperBand = (basicUpper < prevUpperBand || candles[i - 1].close > prevUpperBand)
                    ? basicUpper : prevUpperBand;
                lowerBand = (basicLower > prevLowerBand || candles[i - 1].close < prevLowerBand)
                    ? basicLower : prevLowerBand;

                // Determine trend direction
                if (i === atrPeriod - 1) {
                    trend = candles[i].close > upperBand ? 1 : -1;
                } else {
                    if (trend === 1 && candles[i].close < lowerBand) {
                        trend = -1;
                    } else if (trend === -1 && candles[i].close > upperBand) {
                        trend = 1;
                    }
                }

                const stValue = trend === 1 ? lowerBand : upperBand;
                result.push({
                    time: candles[i].time,
                    value: stValue,
                    color: trend === 1 ? '#00ff88' : '#ff4560'
                });

                prevUpperBand = upperBand;
                prevLowerBand = lowerBand;
            }
            return result;
        }

        // Calculate session VWAP (typical price average, resets daily)
        function calculateVWAP(candles) {
            if (candles.length < 1) return [];
            const result = [];
            let cumTP = 0;
            let count = 0;
            let currentDay = null;

            for (let i = 0; i < candles.length; i++) {
                // Detect day change to reset VWAP
                const d = new Date(candles[i].time * 1000);
                const day = d.toDateString();
                if (day !== currentDay) {
                    cumTP = 0;
                    count = 0;
                    currentDay = day;
                }

                const tp = (candles[i].high + candles[i].low + candles[i].close) / 3;
                cumTP += tp;
                count++;
                result.push({ time: candles[i].time, value: cumTP / count });
            }
            return result;
        }

        // Recalculate and render all indicators
        function updateIndicators(ctx) {
            if (!ctx) return;
            const allCandles = [...ctx.candles];
            if (ctx.pendingCandle) {
                allCandles.push(ctx.pendingCandle);
            }
            if (allCandles.length < 2) return;

            const ema9Data = calculateEMA(allCandles, 9);
            if (ema9Data.length > 0) ctx.ema9Series.setData(ema9Data);

            const ema21Data = calculateEMA(allCandles, 21);
            if (ema21Data.length > 0) ctx.ema21Series.setData(ema21Data);

            const stData = calculateSupertrend(allCandles, 10, 3);
            if (stData.length > 0) ctx.supertrendSeries.setData(stData);

            const vwapData = calculateVWAP(allCandles);
            if (vwapData.length > 0) ctx.vwapSeries.setData(vwapData);
        }

        function scheduleIndicatorUpdate(ctx) {
            if (!ctx) return;
            const now = Date.now();
            if (now - ctx.lastIndicatorUpdate < PERF.indicatorThrottleMs) return;
            if (ctx.indicatorUpdateScheduled) return;
            ctx.indicatorUpdateScheduled = true;
            requestAnimationFrame(() => {
                ctx.indicatorUpdateScheduled = false;
                ctx.lastIndicatorUpdate = Date.now();
                updateIndicators(ctx);
            });
        }

        let pnlUpdateScheduled = false;

        function scheduleLivePnLUpdate() {
            if (pnlUpdateScheduled) return;
            pnlUpdateScheduled = true;
            requestAnimationFrame(() => {
                pnlUpdateScheduled = false;
                updateLivePNL();
            });
        }

        // ========== END TECHNICAL INDICATORS ==========

        function handleUnderlyingData(data) {
            const raw = data.ltp ?? data.data?.ltp;
            const ltp = parseFloat(raw);
            if (!Number.isFinite(ltp) || ltp <= 0) {
                return;
            }
            const ts = data.data?.timestamp || data.timestamp || Date.now();
            updateUnderlyingMetrics(ltp, ts);
        }

        // Handle incoming market data and build candles
        function handleMarketData(data, side) {
            const ltp = parseFloat(data.ltp);
            if (!Number.isFinite(ltp) || ltp <= 0) {
                debugWarn('⚠️ No LTP in market data:', data);
                return;
            }

            const resolvedSide = side || state.activeSide;
            const ctx = getContextForSide(resolvedSide);
            if (!ctx) return;

            debugLog(`💹 Price tick: ${ltp} for ${ctx.symbol}`);
            if (resolvedSide === state.activeSide) {
                updatePriceTimestamp();
            }

            // Update price display for active side only
            const prevPrice = ctx.currentPrice;
            ctx.currentPrice = ltp;
            if (resolvedSide === state.activeSide) {
                const prevActive = state.currentPrice;
                state.currentPrice = ltp;
                if (ui.currentPrice && prevActive !== ltp) {
                    const valueEl = ensureCurrentPriceValue();
                    if (valueEl) {
                        valueEl.textContent = `₹${ltp.toFixed(2)}`;
                    }
                    ui.currentPrice.className = 'current-price price-positive';
                }
                updateGreeksProxy(ltp, data.timestamp || Date.now());
            }

            const now = Math.floor(Date.now() / 1000);
            const candleTime = Math.floor(now / CONFIG.candleInterval) * CONFIG.candleInterval;

            if (!ctx.pendingCandle || ctx.pendingCandle.time !== candleTime) {
                // New candle period - save old one if exists
                if (ctx.pendingCandle) {
                    debugLog('📊 Updating candle:', ctx.pendingCandle);
                    ctx.series.update(ctx.pendingCandle);
                    // Store completed candle for indicator calculations
                    ctx.candles.push({ ...ctx.pendingCandle });
                } else {
                    // First real candle - clear dummy data
                    debugLog('🧹 Clearing dummy candle data');
                    ctx.series.setData([]);
                }

                // Start new candle
                ctx.pendingCandle = {
                    time: candleTime,
                    open: ltp,
                    high: ltp,
                    low: ltp,
                    close: ltp
                };
                // Render the new candle immediately (handles single-tick after hours)
                ctx.series.update(ctx.pendingCandle);
                debugLog('🕯️ New candle started:', ctx.pendingCandle);
            } else {
                // Update current candle
                ctx.pendingCandle.high = Math.max(ctx.pendingCandle.high, ltp);
                ctx.pendingCandle.low = Math.min(ctx.pendingCandle.low, ltp);
                ctx.pendingCandle.close = ltp;

                // Update chart
                ctx.series.update(ctx.pendingCandle);
            }

            // Update indicators with latest candle data
            scheduleIndicatorUpdate(ctx);

            // Update live P&L
            scheduleLivePnLUpdate();

            // Check if price crossed virtual TP/SL levels
            checkVirtualTPSL(resolvedSide);

            // Check if price crossed any fake limit trigger levels
            checkFakeLimitTriggers();
        }

        // ========== VIRTUAL TP/SL PRICE MONITORING ==========

        // Check if current price has crossed TP or SL levels
        function checkVirtualTPSL(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position || state.isClosingPosition) return;

            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return;

            const ctx = getContextForSide(side);
            const price = ctx?.currentPrice || 0;
            if (!price || price <= 0) return;
            const isLong = qty > 0;

            // Check TP hit
            if (posState.positionTPSL.tpPrice !== null) {
                if ((isLong && price >= posState.positionTPSL.tpPrice) || (!isLong && price <= posState.positionTPSL.tpPrice)) {
                    console.log(`🎯 TP HIT: price ${price} crossed TP ${posState.positionTPSL.tpPrice}`);
                    executeVirtualTPSL('TP', posState.positionTPSL.tpPrice, side);
                    return;
                }
            }

            // Check SL hit
            if (posState.positionTPSL.slPrice !== null) {
                if ((isLong && price <= posState.positionTPSL.slPrice) || (!isLong && price >= posState.positionTPSL.slPrice)) {
                    console.log(`🛑 SL HIT: price ${price} crossed SL ${posState.positionTPSL.slPrice}`);
                    executeVirtualTPSL('SL', posState.positionTPSL.slPrice, side);
                    return;
                }
            }
        }

        // Execute virtual TP/SL by placing a MARKET close order
        async function executeVirtualTPSL(type, triggerPrice, sideOverride = null) {
            if (state.isClosingPosition) return;
            state.isClosingPosition = true;

            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const qty = parseInt(posState.position?.quantity) || 0;
            const action = qty > 0 ? 'SELL' : 'BUY';
            const absQty = Math.abs(qty);
            const symbol = getContextForSide(side)?.symbol || state.symbol;

            showToast(`${type} triggered at ₹${triggerPrice.toFixed(2)} - closing position`, type === 'TP' ? 'success' : 'error');
            console.log(`Executing virtual ${type}: ${action} ${absQty} of ${symbol} at MARKET`);

            // Clear TP/SL visuals immediately
            cancelTPSLOrders(side);

            try {
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_tpsl',
                    exchange: state.exchange,
                    symbol: symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`${type} executed - position closed`, 'success');
                    clearPositionVisuals(side);
                    resetProfitProtection();
                } else {
                    showToast(`${type} close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error(`Error executing virtual ${type}:`, error);
                showToast(`${type} execution error: ${error.message}`, 'error');
            } finally {
                setTimeout(() => {
                    state.isClosingPosition = false;
                    fetchAndDisplayPosition(null, symbol, side);
                }, 2000);
            }
        }

        // ========== OPEN ORDERS PANEL ==========

        let openOrdersData = [];

        // Toggle orders panel collapse
        function toggleOrdersPanel() {
            const panel = document.getElementById('ordersPanel');
            const toggle = document.getElementById('ordersToggle');

            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                panel.classList.add('collapsed');
                toggle.textContent = '▲';
            }
        }

        // Fetch all open orders from API
        async function fetchOpenOrders() {
            if (isFetchingOrders) return; // Skip if already fetching

            isFetchingOrders = true;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 sec timeout

                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success' && result.data && result.data.orders) {
                    const allOrders = result.data.orders;

                    // Filter only open/pending orders
                    openOrdersData = allOrders.filter(order => {
                        const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();
                        return status === 'OPEN' ||
                               status === 'PENDING' ||
                               status === 'TRIGGER PENDING' ||
                               status === 'PENDING ORDER' ||
                               status === 'NOT EXECUTED';
                    });

                    renderOpenOrders();
                } else if (result.status === 'error') {
                    // Silently log server errors to avoid console spam
                    if (!result.message.includes('WinError')) {
                        console.error('Orderbook error:', result.message);
                    }
                }
            } catch (error) {
                // Silently handle timeout and connection errors
                if (error.name !== 'AbortError') {
                    console.error('Error fetching orders:', error.message);
                }
            } finally {
                isFetchingOrders = false;
            }
        }

        // Render open orders in the panel
        function renderOpenOrders() {
            const ordersList = document.getElementById('ordersList');
            const ordersCount = document.getElementById('ordersCount');

            ordersCount.textContent = openOrdersData.length;

            if (openOrdersData.length === 0) {
                ordersList.innerHTML = '<div class="orders-empty">No open orders</div>';
                return;
            }

            ordersList.innerHTML = openOrdersData.map(order => {
                const action = order.action || 'N/A';
                const actionClass = action.toUpperCase() === 'BUY' ? 'order-action-buy' : 'order-action-sell';
                const symbol = order.symbol || 'N/A';
                const price = order.price ? `₹${parseFloat(order.price).toFixed(2)}` : 'MARKET';
                const qty = order.quantity || 0;
                const orderType = order.order_type || order.pricetype || 'N/A';
                const orderId = order.orderid || order.order_id || '';

                return `
                    <div class="order-item">
                        <div class="order-info">
                            <div class="order-symbol">${symbol}</div>
                            <div class="order-details">
                                <span class="${actionClass}">${action}</span>
                                <span>${orderType}</span>
                                <span>${price}</span>
                                <span>Qty: ${qty}</span>
                            </div>
                        </div>
                        <div class="order-close-icon" onclick="cancelSingleOrder('${orderId}', '${symbol}')" title="Cancel order">✕</div>
                    </div>
                `;
            }).join('');
        }

        // Cancel a single order
        async function cancelSingleOrder(orderId, symbol) {
            if (!orderId) {
                showToast('Invalid order ID', 'error');
                return;
            }

            try {
                showToast('Cancelling order...', 'info');

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 sec timeout

                const response = await fetch('/api/v1/cancelorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apikey: state.apiKey,
                        strategy: 'chart_trading',
                        orderid: orderId
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`✅ Order cancelled: ${symbol}`, 'success');

                    // Remove visual chart line if it exists
                    removeOrderLineFromChart(orderId);

                    // Refresh orders list
                    setTimeout(() => fetchOpenOrders(), 500);
                } else {
                    showToast(`❌ Cancel failed: ${result.message}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Cancel timeout - server slow', 'error');
                } else {
                    console.error('Error cancelling order:', error);
                    showToast(`❌ Error: ${error.message}`, 'error');
                }
            }
        }

        // Remove order line from chart
        function removeOrderLineFromChart(orderId, preserveTPSL = false) {
            const order = state.orders.get(orderId);
            if (order) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                // Save TP/SL data if preserving (for order fills)
                let savedTPSL = null;
                if (preserveTPSL && (order.tpOrder || order.slOrder)) {
                    savedTPSL = {
                        tpOrder: order.tpOrder ? { price: order.tpOrder.price, priceLine: order.tpOrder.priceLine || null } : null,
                        slOrder: order.slOrder ? { price: order.slOrder.price, priceLine: order.slOrder.priceLine || null } : null,
                        action: order.action,
                        tpPoints: order.tpPoints,
                        slPoints: order.slPoints,
                        tpAuto: order.tpAuto !== false,
                        slAuto: order.slAuto !== false
                    };
                }

                // Remove price line
                if (order.priceLine) {
                    ctx?.series?.removePriceLine(order.priceLine);
                }
                // Remove overlay
                if (order.overlay) {
                    order.overlay.remove();
                }
                // Remove TP/SL lines if they exist
                if (!preserveTPSL) {
                    if (order.tpOrder?.priceLine) {
                        ctx?.series?.removePriceLine(order.tpOrder.priceLine);
                    }
                    if (order.slOrder?.priceLine) {
                        ctx?.series?.removePriceLine(order.slOrder.priceLine);
                    }
                }
                if (order.tpOrder?.overlay) {
                    order.tpOrder.overlay.remove();
                }
                if (order.slOrder?.overlay) {
                    order.slOrder.overlay.remove();
                }
                // Remove from map
                state.orders.delete(orderId);
                console.log(`🗑️ Removed order line from chart: ${orderId}`);

                return savedTPSL;
            }
            return null;
        }

        // Close all open orders
        async function closeAllOpenOrders() {
            // Also cancel all fake limit trigger orders
            for (const [id] of [...state.fakeLimitOrders]) {
                cancelFakeLimitOrder(id);
            }

            if (openOrdersData.length === 0) {
                showToast('No orders to cancel', 'info');
                return;
            }

            showToast(`Cancelling ${openOrdersData.length} orders...`, 'info');

            let successCount = 0;
            let failCount = 0;

            for (const order of openOrdersData) {
                try {
                    const response = await fetch('/api/v1/cancelorder', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            apikey: state.apiKey,
                            strategy: 'chart_trading',
                            orderid: order.orderid || order.order_id
                        })
                    });

                    const result = await response.json();
                    if (result.status === 'success') {
                        successCount++;
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    console.error('Error cancelling order:', error);
                    failCount++;
                }

                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            showToast(`✅ ${successCount} cancelled, ${failCount} failed`, successCount > 0 ? 'success' : 'error');

            // Remove all visual chart lines for cancelled orders
            for (const order of openOrdersData) {
                removeOrderLineFromChart(order.orderid || order.order_id);
            }

            // Refresh orders list
            setTimeout(() => fetchOpenOrders(), 1000);
        }

        // Track if requests are pending to avoid overlapping calls
        let isFetchingOrders = false;
        let isCheckingFills = false;

        // Auto-refresh orders every 5 seconds and check for fills
        setInterval(() => {
            if (!isFetchingOrders) {
                fetchOpenOrders();
            }
            if (!isCheckingFills) {
                checkOrderFills();
            }
        }, 5000); // Increased to 5 seconds to reduce server load

        function normalizeTPSLForFill(tpslData, action, fillPrice, tpPoints, slPoints) {
            if (!tpslData || !action || !Number.isFinite(fillPrice) || fillPrice <= 0) return tpslData;
            const { tpPrice, slPrice } = computeTPSLPrices(fillPrice, action, tpPoints, slPoints);
            const tpAuto = tpslData.tpAuto !== false;
            const slAuto = tpslData.slAuto !== false;

            if (!tpslData.tpOrder) tpslData.tpOrder = {};
            if (tpAuto) {
                tpslData.tpOrder.price = tpPrice;
                if (tpslData.tpOrder.priceLine) {
                    tpslData.tpOrder.priceLine.applyOptions({
                        price: tpPrice,
                        title: `TP @ ${tpPrice.toFixed(2)}`
                    });
                }
            }

            if (!tpslData.slOrder) tpslData.slOrder = {};
            if (slAuto) {
                tpslData.slOrder.price = slPrice;
                if (tpslData.slOrder.priceLine) {
                    tpslData.slOrder.priceLine.applyOptions({
                        price: slPrice,
                        title: `SL @ ${slPrice.toFixed(2)}`
                    });
                }
            }

            tpslData.action = action;
            tpslData.tpPoints = tpPoints;
            tpslData.slPoints = slPoints;
            tpslData.tpAuto = tpAuto;
            tpslData.slAuto = slAuto;
            return tpslData;
        }

        // Check if any pending orders were filled or cancelled
        async function checkOrderFills() {
            if (isCheckingFills) return; // Skip if already checking

            // Get all orderIds we're tracking (pending orders on chart)
            const trackedOrderIds = Array.from(state.orders.keys());

            if (trackedOrderIds.length === 0) return;

            isCheckingFills = true;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success' && result.data && result.data.orders) {
                    let foundFill = false;
                    const fillsBySide = new Map();

                    for (const orderId of trackedOrderIds) {
                        const order = result.data.orders.find(o => (o.orderid || o.order_id) === orderId);
                        if (order) {
                            const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();

                            // Check if order was cancelled/rejected externally
                            if (status === 'CANCELLED' || status === 'CANCELED' || status === 'REJECTED' || status === 'REJECTED ORDER') {
                                console.log(`🔴 Order cancelled externally: ${orderId} - ${status}`);
                                showToast('Order cancelled from mobile/external', 'info');
                                removeOrderLineFromChart(orderId, false);
                                foundFill = true;
                            }
                            // If order is complete/executed, remove the pending line and fetch position
                            else if (status === 'COMPLETE' || status === 'EXECUTED' || status === 'FILLED' || status === 'TRADED') {
                                console.log(`✅ Order filled: ${orderId} - ${status}`);

                                // Get the filled order details to calculate auto TP/SL
                                const orderState = state.orders.get(orderId);
                                const side = orderState?.side || getSideForSymbol(order.symbol) || state.activeSide;
                                const fillPrice = parseFloat(order.average_price || order.price || orderState?.price || 0);
                                const action = order.action || orderState?.action;
                                const tpPoints = Number.isFinite(orderState?.tpPoints) ? orderState.tpPoints : state.tpPoints;
                                const slPoints = Number.isFinite(orderState?.slPoints) ? orderState.slPoints : state.slPoints;

                                let tpslData = removeOrderLineFromChart(orderId, true);
                                if (fillPrice > 0 && action) {
                                    if (tpslData) {
                                        tpslData = normalizeTPSLForFill(tpslData, action, fillPrice, tpPoints, slPoints);
                                    } else {
                                        const { tpPrice, slPrice } = computeTPSLPrices(fillPrice, action, tpPoints, slPoints);
                                        tpslData = {
                                            tpOrder: { price: tpPrice },
                                            slOrder: { price: slPrice },
                                            action: action,
                                            tpPoints: tpPoints,
                                            slPoints: slPoints
                                        };
                                    }
                                    console.log(`📊 Auto TP/SL calculated: TP=${tpslData.tpOrder?.price?.toFixed(2)}, SL=${tpslData.slOrder?.price?.toFixed(2)}`);
                                }

                                if (side) {
                                    fillsBySide.set(side, tpslData || fillsBySide.get(side) || null);
                                }

                                foundFill = true;
                            }
                        } else {
                            // Order not in orderbook - likely filled or cancelled externally
                            console.log(`⚠️ Order ${orderId} not in orderbook - removing line`);
                            const orderState = state.orders.get(orderId);
                            const side = orderState?.side || getSideForSymbol(orderState?.symbol) || state.activeSide;

                            // Try to calculate auto TP/SL even for externally filled orders
                            if (orderState && orderState.price && orderState.action) {
                                const fillPrice = orderState.price;
                                const action = orderState.action;
                                const tpPoints = Number.isFinite(orderState.tpPoints) ? orderState.tpPoints : state.tpPoints;
                                const slPoints = Number.isFinite(orderState.slPoints) ? orderState.slPoints : state.slPoints;
                                const tpslData = normalizeTPSLForFill({
                                    tpOrder: { price: orderState.tpOrder?.price || 0, priceLine: orderState.tpOrder?.priceLine || null },
                                    slOrder: { price: orderState.slOrder?.price || 0, priceLine: orderState.slOrder?.priceLine || null },
                                    action: action,
                                    tpPoints: tpPoints,
                                    slPoints: slPoints,
                                    tpAuto: orderState.tpAuto !== false,
                                    slAuto: orderState.slAuto !== false
                                }, action, fillPrice, tpPoints, slPoints);
                                if (side) {
                                    fillsBySide.set(side, tpslData || fillsBySide.get(side) || null);
                                }
                            }

                            removeOrderLineFromChart(orderId, false);
                            foundFill = true;
                        }
                    }

                    // If any fills detected, refresh position with TP/SL data
                    if (foundFill) {
                        if (fillsBySide.size === 0) {
                            setTimeout(() => fetchAndDisplayPosition(null, state.symbol, state.activeSide), 300);
                        } else {
                            fillsBySide.forEach((tpslData, side) => {
                                const symbol = getContextForSide(side)?.symbol || state.symbol;
                                setTimeout(() => fetchAndDisplayPosition(tpslData, symbol, side), 300);
                            });
                        }
                    }
                }
            } catch (error) {
                // Silently handle timeout and connection errors
                if (error.name !== 'AbortError') {
                    console.error('Error checking fills:', error.message);
                }
            } finally {
                isCheckingFills = false;
            }
        }

        // Fetch current position and display
        async function fetchAndDisplayPosition(tpslData = null, symbolOverride = null, sideOverride = null) {
            try {
                const symbol = symbolOverride || state.symbol;
                const side = sideOverride || state.activeSide;
                console.log('📍 Fetching position for symbol:', symbol);

                const response = await fetch('/api/v1/positionbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });

                const result = await response.json();
                console.log('📍 Position API response:', result);

                if (result.status === 'success' && result.data) {
                    console.log('📍 Total positions:', result.data.length);

                    // Find position for current symbol
                    const position = result.data.find(p => p.symbol === symbol);
                    if (position) {
                        console.log('📍 Found position for', symbol, ':', position);
                        const qty = parseInt(position.quantity) || 0;
                        if (qty !== 0) {
                            console.log('📍 Position has quantity:', qty, '- displaying');
                            updatePositionDisplay(position, tpslData, side);
                        } else {
                            console.log('📍 Position quantity is 0 - not displaying');
                        }
                    } else {
                        console.log('📍 No position found for', symbol);
                        clearPositionVisuals(side);
                    }
                }
            } catch (error) {
                console.error('Error fetching position:', error);
            }
        }

        // Update position display with live data
        function updatePositionDisplay(position, tpslData = null, sideOverride = null) {
            const side = sideOverride || getSideForSymbol(position.symbol) || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            const qty = parseInt(position.quantity) || 0;

            if (qty === 0) {
                clearPositionVisuals(side);
                console.log('📍 Position closed - line removed');
                return;
            }

            posState.position = position;
            posState.entryPrice = parseFloat(position.average_price) || 0;

            const entryKey = `${side}|${position.symbol}`;
            if (!chartManualEntryLogged.has(entryKey)) {
                chartManualEntryLogged.add(entryKey);
                const action = qty > 0 ? 'BUY' : 'SELL';
                logManualTrade({
                    type: 'ENTRY',
                    tradeId: `chart_${Date.now()}_${position.symbol}`,
                    symbol: position.symbol,
                    side: side,
                    action: action,
                    qty: Math.abs(qty),
                    price: posState.entryPrice
                });
            }

            if (side === state.activeSide) {
                state.position = position;
                state.entryPrice = posState.entryPrice;
                document.getElementById('positionQty').textContent = `${qty > 0 ? '+' : ''}${qty}`;
                document.getElementById('entryPrice').textContent = `₹${state.entryPrice.toFixed(2)}`;
                document.getElementById('btnClosePosition').classList.remove('hidden');
            }

            // Draw position line on the correct chart
            drawPositionLine(posState.entryPrice, qty > 0 ? 'BUY' : 'SELL', tpslData, side);

            // Update P&L for active side
            if (side === state.activeSide && ctx?.currentPrice > 0) {
                const pnl = (ctx.currentPrice - posState.entryPrice) * qty;
                const pnlEl = document.getElementById('pnlValue');
                pnlEl.textContent = `₹${pnl.toFixed(2)}`;
                pnlEl.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;
            }
        }

        // Draw position line (entry price) with live P&L
        function drawPositionLine(entryPrice, action, tpslData = null, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            if (!ctx?.series) return;

            // Remove existing position line if any
            if (posState.positionLine) {
                ctx.series.removePriceLine(posState.positionLine);
            }
            if (posState.positionOverlay) {
                posState.positionOverlay.remove();
            }

            // Create price line
            const color = action === 'BUY' ? '#00ff88' : '#ff4560';
            posState.positionLine = ctx.series.createPriceLine({
                price: entryPrice,
                color: color,
                lineWidth: 2,
                lineStyle: 1, // Dashed for position
                axisLabelVisible: true,
                title: ''
            });

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.style.cursor = 'default'; // Not draggable

            // Close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'order-close-btn';
            closeBtn.textContent = '✕';
            closeBtn.title = 'Close position';
            closeBtn.style.pointerEvents = 'auto';
            closeBtn.style.marginRight = '8px';
            closeBtn.style.flexShrink = '0';
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closePosition(side);
            });
            overlay.appendChild(closeBtn);

            // Position label
            const label = document.createElement('div');
            label.className = `order-line-label ${action.toLowerCase()}`;
            label.textContent = `${action} @ ₹${entryPrice.toFixed(2)}`;
            overlay.appendChild(label);

            // Live P&L label (always visible)
            const pnlLabel = document.createElement('div');
            pnlLabel.className = 'pnl-label';
            pnlLabel.id = `positionPnlLabel_${side}`;
            pnlLabel.style.marginLeft = 'auto';
            pnlLabel.textContent = '₹0.00';
            overlay.appendChild(pnlLabel);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, entryPrice, ctx);
            posState.positionOverlay = overlay;

            // Create or reuse TP/SL lines if data was provided
            if (tpslData) {
                console.log('📍 Creating auto TP/SL lines:', tpslData);

                if (tpslData.tpOrder) {
                    const tpPrice = tpslData.tpOrder.price;
                    posState.positionTPSL.tpPrice = tpPrice;
                    if (!posState.positionTPSL.tpLine) {
                        posState.positionTPSL.tpLine = tpslData.tpOrder.priceLine || ctx.series.createPriceLine({
                            price: tpPrice,
                            color: '#00ff88',
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            axisLabelVisible: true,
                            title: `TP @ ${tpPrice.toFixed(2)}`
                        });
                    }
                    posState.positionTPSL.tpLine.applyOptions({ price: tpPrice, title: `TP @ ${tpPrice.toFixed(2)}` });
                    if (!posState.positionTPSL.tpOverlay) {
                        posState.positionTPSL.tpOverlay = createTPSLOverlay(tpPrice, 'TP', action, side);
                    } else {
                        updateOverlayPosition(posState.positionTPSL.tpOverlay, tpPrice, ctx);
                    }
                }

                if (tpslData.slOrder) {
                    const slPrice = tpslData.slOrder.price;
                    posState.positionTPSL.slPrice = slPrice;
                    if (!posState.positionTPSL.slLine) {
                        posState.positionTPSL.slLine = tpslData.slOrder.priceLine || ctx.series.createPriceLine({
                            price: slPrice,
                            color: '#ff4560',
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            axisLabelVisible: true,
                            title: `SL @ ${slPrice.toFixed(2)}`
                        });
                    }
                    posState.positionTPSL.slLine.applyOptions({ price: slPrice, title: `SL @ ${slPrice.toFixed(2)}` });
                    if (!posState.positionTPSL.slOverlay) {
                        posState.positionTPSL.slOverlay = createTPSLOverlay(slPrice, 'SL', action, side);
                    } else {
                        updateOverlayPosition(posState.positionTPSL.slOverlay, slPrice, ctx);
                    }
                }
            }

            console.log('📍 Position line drawn at ₹' + entryPrice);
        }

        // Create draggable TP/SL overlay for position
        function createTPSLOverlay(price, type, parentAction, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const ctx = getContextForSide(side);
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.style.cursor = 'ns-resize'; // Draggable cursor
            overlay.dataset.tpslType = type;

            // Label
            const label = document.createElement('div');
            label.className = `order-line-label ${type === 'TP' ? 'buy' : 'sell'}`;
            label.textContent = `${type} @ ₹${price.toFixed(2)}`;
            overlay.appendChild(label);

            // Cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.textContent = '✕';
            cancelBtn.title = `Remove ${type}`;
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginLeft = '8px';
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                removePositionTPSL(type, side);
            });
            overlay.appendChild(cancelBtn);

            const overlayRoot = ctx?.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            // Make draggable
            setupTPSLDraggable(overlay, type, parentAction, side);

            return overlay;
        }

        // Setup draggable for TP/SL on position
        function setupTPSLDraggable(overlay, type, parentAction, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            if (!ctx?.series) return;
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                // Don't drag if clicking the cancel button
                if (e.target.classList.contains('order-close-btn')) return;

                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                const currentPrice = type === 'TP' ? posState.positionTPSL.tpPrice : posState.positionTPSL.slPrice;
                startY = e.clientY;
                startPrice = currentPrice;

                const onMouseMove = (e) => {
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        // Update stored price
                        if (type === 'TP') {
                            posState.positionTPSL.tpPrice = newPrice;
                            posState.positionTPSL.tpLine.applyOptions({
                                price: newPrice,
                                title: `TP @ ${newPrice.toFixed(2)}`
                            });
                        } else {
                            posState.positionTPSL.slPrice = newPrice;
                            posState.positionTPSL.slLine.applyOptions({
                                price: newPrice,
                                title: `SL @ ${newPrice.toFixed(2)}`
                            });
                        }

                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent = `${type} @ ₹${newPrice.toFixed(2)}`;
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    const finalPrice = type === 'TP' ? posState.positionTPSL.tpPrice : posState.positionTPSL.slPrice;
                    if (Math.abs(finalPrice - startPrice) > 0.01) {
                        showToast(`${type} moved to ₹${finalPrice.toFixed(2)}`, 'info');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // Remove TP or SL from position (visual only — no broker orders)
        function removePositionTPSL(type, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            if (type === 'TP') {
                if (posState.positionTPSL.tpLine) {
                    ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                    posState.positionTPSL.tpLine = null;
                }
                if (posState.positionTPSL.tpOverlay) {
                    posState.positionTPSL.tpOverlay.remove();
                    posState.positionTPSL.tpOverlay = null;
                }
                posState.positionTPSL.tpPrice = null;
                showToast('TP removed', 'info');
            } else {
                if (posState.positionTPSL.slLine) {
                    ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                    posState.positionTPSL.slLine = null;
                }
                if (posState.positionTPSL.slOverlay) {
                    posState.positionTPSL.slOverlay.remove();
                    posState.positionTPSL.slOverlay = null;
                }
                posState.positionTPSL.slPrice = null;
                showToast('SL removed', 'info');
            }
        }

        // Close current position
        async function closePosition(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return;

            try {
                showToast('Closing position...', 'info');

                const qty = parseInt(posState.position.quantity) || 0;
                if (qty === 0) {
                    showToast('No position to close', 'info');
                    return;
                }

                // Cancel TP/SL orders first
                await cancelTPSLOrders(side);

                // Determine opposite action (SELL if long, BUY if short)
                const action = qty > 0 ? 'SELL' : 'BUY';
                const absQty = Math.abs(qty);

                const symbol = getContextForSide(side)?.symbol || state.symbol;
                console.log(`📍 Closing position: ${action} ${absQty} qty of ${symbol}`);

                // Place opposite MARKET order to close position
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_trading',
                    exchange: state.exchange,
                    symbol: symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (result.status === 'success') {
                    const pnlInfo = getActivePositionPnl();
                    const exitPrice = pnlInfo ? pnlInfo.price : 0;
                    const pnl = pnlInfo ? pnlInfo.pnl : null;
                    logManualTrade({
                        type: 'EXIT',
                        tradeId: state.manualTradeId || `chart_${Date.now()}_${symbol}`,
                        symbol: symbol,
                        side: side,
                        action: action,
                        qty: absQty,
                        price: exitPrice,
                        pnl: pnl != null ? pnl : undefined,
                        reason: 'Manual Exit',
                        entryPrice: posState.entryPrice
                    });
                    showToast('✅ Position closed', 'success');

                    // Clear all visual elements
                    clearPositionVisuals(side);

                    // Refresh position after a delay to confirm closure
                    setTimeout(() => fetchAndDisplayPosition(null, symbol, side), 1000);
                } else {
                    showToast(`❌ Close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error closing position:', error);
                showToast(`❌ Error: ${error.message}`, 'error');
            }
        }

        // Clear virtual TP/SL lines (no broker orders to cancel)
        function cancelTPSLOrders(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            if (posState.positionTPSL.tpLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                posState.positionTPSL.tpLine = null;
            }
            if (posState.positionTPSL.slLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                posState.positionTPSL.slLine = null;
            }
            if (posState.positionTPSL.tpOverlay) {
                posState.positionTPSL.tpOverlay.remove();
                posState.positionTPSL.tpOverlay = null;
            }
            if (posState.positionTPSL.slOverlay) {
                posState.positionTPSL.slOverlay.remove();
                posState.positionTPSL.slOverlay = null;
            }
            posState.positionTPSL.tpPrice = null;
            posState.positionTPSL.slPrice = null;
        }

        // Clear all position visual elements
        function clearPositionVisuals(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            // Remove position line
            if (posState.positionLine) {
                ctx?.series?.removePriceLine(posState.positionLine);
                posState.positionLine = null;
            }
            if (posState.positionOverlay) {
                posState.positionOverlay.remove();
                posState.positionOverlay = null;
            }

            // Remove TP/SL lines
            if (posState.positionTPSL.tpLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                posState.positionTPSL.tpLine = null;
            }
            if (posState.positionTPSL.slLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                posState.positionTPSL.slLine = null;
            }
            if (posState.positionTPSL.tpOverlay) {
                posState.positionTPSL.tpOverlay.remove();
                posState.positionTPSL.tpOverlay = null;
            }
            if (posState.positionTPSL.slOverlay) {
                posState.positionTPSL.slOverlay.remove();
                posState.positionTPSL.slOverlay = null;
            }

            // Clear state (remove from manual entry logged set so next open can log ENTRY again)
            if (posState.position && posState.position.symbol) {
                chartManualEntryLogged.delete(`${side}|${posState.position.symbol}`);
            }
            posState.positionTPSL.tpPrice = null;
            posState.positionTPSL.slPrice = null;
            posState.position = null;
            posState.entryPrice = 0;

            if (side === state.activeSide) {
                state.position = null;
                state.entryPrice = 0;
                document.getElementById('positionQty').textContent = '--';
                document.getElementById('entryPrice').textContent = '--';
                document.getElementById('pnlValue').textContent = '₹0.00';
                document.getElementById('btnClosePosition').classList.add('hidden');
            }
        }

        function getActivePositionPnl() {
            const side = state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return null;
            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return null;
            const ctx = getContextForSide(side);
            const price = ctx?.currentPrice || 0;
            const entry = posState.entryPrice || parseFloat(posState.position.average_price) || 0;
            if (!price || !entry) return null;
            const pnl = (price - entry) * qty;
            return { pnl, qty, price, entry };
        }

        function getActivePositionKey() {
            const side = state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return null;
            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return null;
            const entry = Number.isFinite(posState.entryPrice) && posState.entryPrice > 0
                ? posState.entryPrice
                : (parseFloat(posState.position.average_price) || 0);
            const symbol = posState.position.symbol
                || (side === 'PE' ? state.peSymbol : state.ceSymbol)
                || state.symbol
                || '';
            const entryKey = entry ? entry.toFixed(2) : '0';
            return `${side}|${symbol}|${qty}|${entryKey}`;
        }

        // Update position P&L in real-time
        setInterval(() => {
            const snapshot = getActivePositionPnl();
            if (!snapshot) return;

            const pnl = snapshot.pnl;
            state.totalPnl = pnl;

            // Update top panel
            const pnlElement = document.getElementById('pnlValue');
            pnlElement.textContent = `₹${pnl.toFixed(2)}`;
            pnlElement.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;

            // Update position line P&L label
            const pnlLabel = document.getElementById(`positionPnlLabel_${state.activeSide}`);
            if (pnlLabel) {
                pnlLabel.textContent = `₹${pnl.toFixed(2)}`;
                pnlLabel.className = pnl >= 0 ? 'pnl-label profit' : 'pnl-label loss';
            }
            
            // Check profit protection
            if (state.profitProtectionEnabled) {
                checkProfitProtection();
            }
        }, 500);
        
        // ========== PROFIT PROTECTION SYSTEM ==========
        
        function toggleProfitProtection() {
            const checkbox = document.getElementById('enableProfitProtection');
            state.profitProtectionEnabled = checkbox.checked;
            
            const securedDisplay = document.getElementById('securedProfitDisplay');
            
            if (checkbox.checked) {
                securedDisplay.style.display = 'inline';
                
                // Reset protection state
                state.currentProtectionLevel = -1;
                state.securedProfit = 0;
                state.breakevenActivated = false;
                state.highestPnl = 0;
                
                updateProfitProtectionUI();
                showToast('🛡️ Profit Protection enabled', 'success');
            } else {
                securedDisplay.style.display = 'none';
                showToast('🛡️ Profit Protection disabled', 'info');
            }
        }
        
        function updateProfitProtectionUI() {
            const securedValue = document.getElementById('securedProfitValue');
            if (securedValue) {
                securedValue.textContent = `₹${state.securedProfit.toFixed(0)}`;
            }
        }
        
        function checkProfitProtection() {
            if (!state.profitProtectionEnabled || state.totalPnl <= 0 || state.isClosingPosition) return;
            
            // Check breakeven activation
            if (!state.breakevenActivated && state.totalPnl >= state.breakevenThreshold) {
                state.breakevenActivated = true;
                state.securedProfit = 0;
                console.log(`🟢 Breakeven activated at ₹${state.totalPnl.toFixed(2)}`);
                showToast('🟢 Breakeven activated!', 'success');
            }
            
            // Check profit protection levels
            for (let i = state.profitProtectionLevels.length - 1; i >= 0; i--) {
                const level = state.profitProtectionLevels[i];
                
                if (state.totalPnl >= level.trigger && i > state.currentProtectionLevel) {
                    state.currentProtectionLevel = i;
                    state.securedProfit = level.trigger * (level.lockPercent / 100);
                    
                    console.log(`🛡️ Protection Level ${i + 1}: Secured ₹${state.securedProfit.toFixed(0)}`);
                    showToast(`🛡️ Secured ₹${state.securedProfit.toFixed(0)} profit!`, 'success');
                    break;
                }
            }
            
            // Check if we should close due to profit protection
            if (state.securedProfit > 0 && state.totalPnl <= state.securedProfit) {
                console.log(`🛡️ Profit Protection triggered! P&L ₹${state.totalPnl.toFixed(2)} <= Secured ₹${state.securedProfit.toFixed(0)}`);
                showToast(`🛡️ Closing to secure ₹${state.securedProfit.toFixed(0)}`, 'success');
                closePositionAuto('Profit Protection');
                return;
            }
            
            // Check breakeven stop
            if (state.breakevenActivated && state.totalPnl <= 0) {
                console.log(`🛡️ Breakeven Stop triggered!`);
                showToast('🛡️ Breakeven Stop! Closing position', 'info');
                closePositionAuto('Breakeven Stop');
                return;
            }
            
            updateProfitProtectionUI();
        }
        
        async function closePositionAuto(reason) {
            if (state.isClosingPosition || !state.position) return;
            
            state.isClosingPosition = true;
            state.profitProtectionEnabled = false;
            document.getElementById('enableProfitProtection').checked = false;
            
            console.log(`🚨 Auto-closing position: ${reason}`);
            
            try {
                const qty = parseInt(state.position.quantity) || 0;
                if (qty === 0) {
                    state.isClosingPosition = false;
                    return;
                }
                
                // Cancel TP/SL orders first
                await cancelTPSLOrders();
                
                const action = qty > 0 ? 'SELL' : 'BUY';
                const absQty = Math.abs(qty);
                
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_protection',
                    exchange: state.exchange,
                    symbol: state.symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };
                
                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    const side = state.activeSide;
                    const posState = getPositionState(side);
                    const pnlInfo = getActivePositionPnl();
                    const exitPrice = pnlInfo ? pnlInfo.price : 0;
                    const pnl = pnlInfo ? pnlInfo.pnl : null;
                    logManualTrade({
                        type: 'EXIT',
                        tradeId: state.manualTradeId || `chart_${Date.now()}_${state.symbol}`,
                        symbol: state.symbol,
                        side: side,
                        action: action,
                        qty: absQty,
                        price: exitPrice,
                        pnl: pnl != null ? pnl : undefined,
                        reason: reason || 'Auto Exit',
                        entryPrice: posState.entryPrice || state.entryPrice
                    });
                    showToast(`✅ Position closed: ${reason}`, 'success');
                    clearPositionVisuals();
                    resetProfitProtection();
                } else {
                    showToast(`❌ Close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error closing position:', error);
                showToast(`❌ Error: ${error.message}`, 'error');
            } finally {
                setTimeout(() => {
                    state.isClosingPosition = false;
                    fetchAndDisplayPosition();
                }, 2000);
            }
        }
        
        function resetProfitProtection() {
            state.currentProtectionLevel = -1;
            state.securedProfit = 0;
            state.breakevenActivated = false;
            state.highestPnl = 0;
            state.totalPnl = 0;
            
            const securedDisplay = document.getElementById('securedProfitDisplay');
            if (securedDisplay) {
                securedDisplay.style.display = 'none';
            }
        }

        // ========== PHASE 3: PRICE STALENESS DETECTION ==========
        
        let lastPriceUpdate = 0;
        let lastStaleness = null;
        
        function updatePriceTimestamp() {
            lastPriceUpdate = Date.now();
        }
        
        function getPriceStaleness() {
            if (!lastPriceUpdate) return 'unknown';
            
            const staleness = Date.now() - lastPriceUpdate;
            if (staleness > 10000) return 'stale';      // > 10 seconds
            if (staleness > 5000) return 'delayed';     // > 5 seconds
            return 'live';
        }
        
        function isPriceStale() {
            return getPriceStaleness() === 'stale';
        }
        
        // Update price staleness indicator
        function updatePriceStalenessUI() {
            const priceEl = ui.currentPrice;
            if (!priceEl) return;

            ensureCurrentPriceValue();
            
            const staleness = getPriceStaleness();
            if (staleness === lastStaleness) return;
            lastStaleness = staleness;
            priceEl.classList.remove('price-live', 'price-delayed', 'price-stale');
            priceEl.classList.add(`price-${staleness}`);
            
            // Add visual indicator
            let indicator = priceEl.querySelector('.staleness-indicator');
            if (!indicator) {
                indicator = document.createElement('span');
                indicator.className = 'staleness-indicator';
                indicator.style.cssText = 'font-size: 8px; margin-left: 5px;';
                priceEl.appendChild(indicator);
            }
            
            if (staleness === 'live') {
                indicator.textContent = '🟢';
                indicator.title = 'Live price';
            } else if (staleness === 'delayed') {
                indicator.textContent = '🟡';
                indicator.title = 'Price delayed (>5s)';
            } else if (staleness === 'stale') {
                indicator.textContent = '🔴';
                indicator.title = 'Price stale (>10s)';
            }
        }
        
        // Check staleness every second
        setInterval(updatePriceStalenessUI, 1000);

        // ========== PHASE 4: ORDER VALIDATION ==========
        
        const ORDER_LIMITS = {
            maxQuantity: 50,           // Max lots per order
            maxDailyLoss: 10000,       // Max daily loss in rupees
            maxOrderValue: 500000,     // Max order value in rupees
            priceDeviationLimit: 0.5,  // Max 50% deviation from current price
            minPrice: 0.5,             // Minimum option price
            maxPrice: 50000            // Maximum option price
        };
        
        let dailyPnL = 0;
        
        function validateOrder(orderData, currentPrice) {
            const errors = [];
            const warnings = [];
            
            // 1. Quantity validation
            const lots = parseInt(orderData.quantity) / (state.lotSize || 15);
            if (lots > ORDER_LIMITS.maxQuantity) {
                errors.push(`Quantity ${lots} lots exceeds max ${ORDER_LIMITS.maxQuantity} lots`);
            }
            
            // 2. Price validation for limit orders
            if (orderData.pricetype === 'LIMIT') {
                const price = parseFloat(orderData.price);
                
                if (price < ORDER_LIMITS.minPrice) {
                    errors.push(`Price ₹${price} below minimum ₹${ORDER_LIMITS.minPrice}`);
                }
                
                if (price > ORDER_LIMITS.maxPrice) {
                    errors.push(`Price ₹${price} exceeds maximum ₹${ORDER_LIMITS.maxPrice}`);
                }
                
                // Check deviation from current price
                if (currentPrice > 0) {
                    const deviation = Math.abs(price - currentPrice) / currentPrice;
                    if (deviation > ORDER_LIMITS.priceDeviationLimit) {
                        warnings.push(`Price ₹${price} is ${(deviation * 100).toFixed(0)}% away from current ₹${currentPrice}`);
                    }
                }
            }
            
            // 3. Daily loss limit check
            if (dailyPnL < -ORDER_LIMITS.maxDailyLoss) {
                errors.push(`Daily loss limit (₹${ORDER_LIMITS.maxDailyLoss}) exceeded`);
            }
            
            // 4. Stale price check
            if (isPriceStale()) {
                warnings.push('Price data is stale (>10s old)');
            }
            
            return { errors, warnings, isValid: errors.length === 0 };
        }
        
        // ========== PHASE 4: AUDIT TRAIL ==========
        
        const auditTrail = [];
        const MAX_AUDIT_ENTRIES = 500;

        const manualLogQueue = [];
        const manualLogIds = new Set();
        const MAX_MANUAL_LOG_QUEUE = 400;
        const MANUAL_LOG_FLUSH_MS = 1200;
        let manualLogFlushTimer = null;

        function generateManualEventId() {
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return window.crypto.randomUUID();
            }
            return `manual_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        }

        function queueManualTradeLog(entry) {
            if (!entry) return;
            manualLogQueue.push(entry);
            if (manualLogQueue.length > MAX_MANUAL_LOG_QUEUE) {
                manualLogQueue.shift();
            }
            if (!manualLogFlushTimer) {
                manualLogFlushTimer = setTimeout(flushManualTradeLogs, MANUAL_LOG_FLUSH_MS);
            }
        }

        function flushManualTradeLogs() {
            manualLogFlushTimer = null;
            if (!manualLogQueue.length) return;
            const batch = manualLogQueue.splice(0, 60);
            const payload = JSON.stringify({ events: batch });
            try {
                if (navigator.sendBeacon) {
                    const ok = navigator.sendBeacon('/manual_trades/logs', new Blob([payload], { type: 'application/json' }));
                    if (!ok) {
                        throw new Error('Beacon failed');
                    }
                } else {
                    fetch('/manual_trades/logs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: payload,
                        keepalive: true
                    }).catch(() => {});
                }
            } catch (e) {
                manualLogQueue.unshift(...batch);
                if (manualLogQueue.length > MAX_MANUAL_LOG_QUEUE) {
                    manualLogQueue.length = MAX_MANUAL_LOG_QUEUE;
                }
            }
            if (manualLogQueue.length) {
                manualLogFlushTimer = setTimeout(flushManualTradeLogs, MANUAL_LOG_FLUSH_MS);
            }
        }

        function logManualTrade(event) {
            if (!event) return;
            const entry = {
                ts: new Date().toISOString(),
                ...event
            };
            if (!entry.eventId) entry.eventId = generateManualEventId();
            if (manualLogIds.has(entry.eventId)) return;
            manualLogIds.add(entry.eventId);
            if (!entry.source) entry.source = 'chart';
            if (!entry.mode) entry.mode = 'LIVE';
            if (!entry.underlying && state.underlying) entry.underlying = state.underlying;
            if (!entry.exchange && state.exchange) entry.exchange = state.exchange;
            queueManualTradeLog(entry);
        }

        const chartManualEntryLogged = new Set();
        
        function logAuditEntry(action, details) {
            const entry = {
                timestamp: new Date().toISOString(),
                action: action,
                details: details,
                symbol: state.symbol
            };
            
            auditTrail.push(entry);
            
            // Keep only last N entries
            if (auditTrail.length > MAX_AUDIT_ENTRIES) {
                auditTrail.shift();
            }
            
            // Persist to localStorage
            try {
                const key = `chart_audit_${state.symbol}`;
                localStorage.setItem(key, JSON.stringify(auditTrail.slice(-50)));
            } catch (e) {
                // Storage full, ignore
            }
            
            return entry;
        }
        
        function logOrderPlaced(orderData, result) {
            return logAuditEntry('ORDER_PLACED', {
                action: orderData.action,
                quantity: orderData.quantity,
                pricetype: orderData.pricetype,
                price: orderData.price,
                orderId: result.orderid,
                status: result.status
            });
        }
        
        function logPositionClosed(qty, pnl, reason) {
            return logAuditEntry('POSITION_CLOSED', {
                quantity: qty,
                pnl: pnl,
                reason: reason
            });
        }
        
        function logProfitProtectionTriggered(level, securedProfit) {
            return logAuditEntry('PROFIT_PROTECTION', {
                level: level,
                securedProfit: securedProfit
            });
        }
        
        function exportAuditTrail() {
            const data = JSON.stringify(auditTrail, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `chart_audit_${state.symbol}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('Audit trail exported', 'success');
        }
        
        // Load audit trail from localStorage
        function loadAuditTrail() {
            try {
                const key = `chart_audit_${state.symbol}`;
                const saved = localStorage.getItem(key);
                if (saved) {
                    const entries = JSON.parse(saved);
                    auditTrail.push(...entries);
                }
            } catch (e) {
                console.error('Failed to load audit trail:', e);
            }
        }

        // ========== PHASE 5: EXIT DECISION HELPER ==========
        
        function analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition) {
            const analysis = {
                momentum: 'neutral',
                suggestion: 'HOLD',
                reason: '',
                actions: []
            };
            
            // Calculate momentum
            const priceChange = ((currentPrice - entryPrice) / entryPrice) * 100;
            
            if (priceChange > 5) analysis.momentum = 'strong_up';
            else if (priceChange > 2) analysis.momentum = 'up';
            else if (priceChange < -5) analysis.momentum = 'strong_down';
            else if (priceChange < -2) analysis.momentum = 'down';
            
            // Time-based analysis
            const now = new Date();
            const hours = now.getHours();
            const day = now.getDay();
            
            const isExpiryDay = day === 4;
            const isLateSession = hours >= 14;
            const isClosingHour = hours >= 15;
            
            // Generate suggestion
            if (currentPnl > 0) {
                if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing - book profits';
                    analysis.actions = ['Exit Now', 'Trail Tight'];
                } else if (isExpiryDay && isLateSession) {
                    analysis.suggestion = 'TRAIL';
                    analysis.reason = 'Expiry day - use tight trailing stop';
                    analysis.actions = ['Trail +3', 'Trail +5', 'Exit 50%'];
                } else if (analysis.momentum === 'strong_up') {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Strong momentum - let it ride';
                    analysis.actions = ['Trail +5', 'Trail +10', 'Exit 50%'];
                } else {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Position in profit - monitor';
                    analysis.actions = ['Trail +5', 'Exit 50%', 'Hold'];
                }
            } else {
                if (currentPnl < -2000) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Significant loss - cut position';
                    analysis.actions = ['Exit Now', 'Exit 50%'];
                } else if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing - avoid overnight risk';
                    analysis.actions = ['Exit Now'];
                } else {
                    analysis.suggestion = 'REVIEW';
                    analysis.reason = 'Position in loss - review thesis';
                    analysis.actions = ['Exit Now', 'Hold', 'Set SL'];
                }
            }
            
            return analysis;
        }
        
        // ========== PHASE 5: LOSS AVERSION COUNTERMEASURES ==========
        
        const LOSS_LIMITS = {
            warningThreshold: 1000,
            criticalThreshold: 2000,
            autoExitThreshold: 3000,
            maxTimeInLoss: 10 * 60 * 1000
        };
        
        let lossWarningShown = false;
        let lossTimerStarted = null;
        let autoExitTimer = null;
        let lossPositionKey = null;

        function resetLossAversionState() {
            lossWarningShown = false;
            lossTimerStarted = null;
            if (autoExitTimer) {
                clearTimeout(autoExitTimer);
                autoExitTimer = null;
            }
            hideLossWarning();
        }
        
        function checkLossAversion(currentPnl) {
            if (currentPnl >= 0) {
                resetLossAversionState();
                return;
            }
            
            const loss = Math.abs(currentPnl);
            
            if (!lossTimerStarted) {
                lossTimerStarted = Date.now();
            }
            
            // Auto-exit threshold
            if (loss >= LOSS_LIMITS.autoExitThreshold) {
                showLossWarning('critical', loss);
                if (!autoExitTimer) {
                    autoExitTimer = setTimeout(() => {
                        console.log('🚨 AUTO-EXIT: Loss limit reached');
                        showToast('🚨 Auto-exit triggered', 'error');
                        closePosition();
                        logAuditEntry('AUTO_EXIT', { reason: 'loss_limit', loss: loss });
                    }, 5000);
                }
                return;
            }
            
            // Critical warning
            if (loss >= LOSS_LIMITS.criticalThreshold) {
                showLossWarning('critical', loss);
                return;
            }
            
            // Warning threshold
            if (loss >= LOSS_LIMITS.warningThreshold && !lossWarningShown) {
                lossWarningShown = true;
                showLossWarning('warning', loss);
            }
        }
        
        function showLossWarning(type, loss) {
            let existing = document.getElementById('lossWarningBanner');
            
            const messages = {
                warning: `⚠️ Position at -₹${loss.toFixed(0)} | Review your thesis`,
                critical: `🚨 CRITICAL: -₹${loss.toFixed(0)} | Consider exiting NOW`
            };
            
            const bannerHtml = `
                <div class="loss-warning-banner ${type}" id="lossWarningBanner">
                    <span class="loss-message">${messages[type]}</span>
                    <div class="loss-actions">
                        <button onclick="closePosition()" class="loss-exit-btn">Exit Now</button>
                        <button onclick="hideLossWarning()" class="loss-dismiss-btn">Dismiss</button>
                    </div>
                </div>
            `;
            
            if (existing) {
                existing.outerHTML = bannerHtml;
            } else {
                document.body.insertAdjacentHTML('afterbegin', bannerHtml);
            }
            
            // Play alert sound for critical
            if (type === 'critical') {
                try {
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleQAA');
                    audio.volume = 0.3;
                    audio.play().catch(() => {});
                } catch (e) {}
            }
        }
        
        function hideLossWarning() {
            const banner = document.getElementById('lossWarningBanner');
            if (banner) banner.remove();
        }
        
        // Check loss aversion every second when in position
        setInterval(() => {
            const snapshot = getActivePositionPnl();
            const key = getActivePositionKey();

            if (!snapshot || !key) {
                if (lossPositionKey) {
                    lossPositionKey = null;
                    resetLossAversionState();
                }
                return;
            }

            if (lossPositionKey !== key) {
                lossPositionKey = key;
                resetLossAversionState();
            }

            if (getPriceStaleness() !== 'live') return;
            checkLossAversion(snapshot.pnl);
        }, 1000);

        // Monitor for external position closures (from mobile app, etc.)
        let lastPositionCheck = 0;
        setInterval(async () => {
            // Only check if we have an active position
            if (!state.position) return;

            // Throttle checks to every 3 seconds
            const now = Date.now();
            if (now - lastPositionCheck < 3000) return;
            lastPositionCheck = now;

            try {
                const response = await fetch('/api/v1/positionbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });

                const result = await response.json();

                if (result.status === 'success' && result.data) {
                    const position = result.data.find(p => p.symbol === state.symbol);
                    const qty = position ? parseInt(position.quantity) || 0 : 0;

                    // If position was closed externally (qty is now 0)
                    if (qty === 0 && state.position) {
                        console.log('🔔 Position closed externally - cleaning up TP/SL orders');
                        showToast('Position closed externally', 'info');

                        // Cancel TP/SL orders
                        await cancelTPSLOrders();

                        // Clear all visuals
                        clearPositionVisuals();
                    }
                }
            } catch (error) {
                // Silently handle errors to avoid spam
                console.error('Error checking position:', error.message);
            }
        }, 1000); // Check every second, but throttled to 3 seconds

        // ========== END OPEN ORDERS PANEL ==========

        // Initialize
        async function init() {
            // Fetch exact WebSocket URL from server config (overrides port-derived default)
            try {
                const configResp = await fetch('/scalping/config');
                const configData = await configResp.json();
                if (configData.wsUrl) {
                    CONFIG.wsUrl = configData.wsUrl;
                }
                console.log('WebSocket URL:', CONFIG.wsUrl);
            } catch (e) {
                console.warn('Config fetch failed, using derived WebSocket URL:', CONFIG.wsUrl);
            }

            parseUrlParams();

            if (!state.symbol) {
                showToast('Invalid symbol parameter', 'error');
                return;
            }

            initDepthPanel();
            initChart();
            setupEventListeners();
            setupChartInteraction(); // Enable cursor tracking
            initTooltipHints();
            connectWebSocket();
            fetchOpenOrders(); // Load open orders immediately
            fetchAndDisplayPosition(); // Load any existing position

            console.log('Chart window initialized for:', state.symbol);
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>

</html>
