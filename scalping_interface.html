<!DOCTYPE html>
<!--
╔══════════════════════════════════════════════════════════════════════╗
║               SCALPING INTERFACE ARCHITECTURE MAP                    ║
║                                                                      ║
║  Self-contained option chain scalping page (~5330 lines).            ║
║  Displays option chain grid with one-click BUY/SELL buttons.         ║
║  Opens chart_window.html popups for individual symbol charting.      ║
╚══════════════════════════════════════════════════════════════════════╝

CONFIG OBJECT (const CONFIG = {...})
  wsUrl:              WebSocket URL (port-derived fallback, overridden from /scalping/config)
  apiUrl:             '' (relative URLs)
  strikeCount:        10 (number of strikes around ATM)
  positionUpdateInterval: 5000ms
  performanceMode:    { disableConsoleLog, fastToasts, disablePriceAnimations, optimisticUI }

STATE OBJECT (const state = {...})
  Connection: ws, connected, apiKey
  Index:      selectedIndex ('NIFTY'|'BANKNIFTY'|'SENSEX'), selectedExpiry, expiryFormatted
  Data:       optionChainData[], positions[], prices Map (symbol → ltp)
  Trading:    quantity, orderType ('MARKET'|'LIMIT'), limitPrice, hotkeysEnabled
  Profiles:   brokerProfiles[], currentProfile
  Selection:  selectedStrike (for hotkey trading)
  PnL:        totalPnl, stopLoss, targetProfit, trailingEnabled, trailPoints, highestPnl
  Monitoring: pnlMonitoringActive, isClosingPositions, activePositionTab ('open'|'closed')
  Session:    sessionClosedPnL [] (trade entries, localStorage-backed)
  Protection: profitProtectionEnabled, profitProtectionLevels[], currentProtectionLevel, securedProfit
  Breakeven:  breakevenActivated, breakevenThreshold (300)
  Auto TP/SL: autoTPEnabled, autoTPPoints (5), autoSLPoints (8), virtualTPSL Map

TRADING STATE (const tradingState = {...})  — extended state for advanced features
  Positions:  positions Map, orders Map, pendingOrders Map
  Risk:       dailyPnL, maxDailyLoss, perTradeLossLimit, dailyTradeCount, coolingOffUntil
  Trailing:   trailingStops Map, profitProtectionState Map
  Ladder:     ladderOrders Map, ladderTemplates[]
  Connection: wsConnected, wsLatency, lastHeartbeat, reconnectAttempts, apiHealthy
  UI:         selectedStrike, orderPreset, ladderConfig, riskPanelExpanded
  Session:    sessionStart, sessionTrades[], sessionStats {}

KEY GLOBALS
  elements    = { apiKeyInput, indexSelect, expirySelect, connectBtn, wsStatus, ... }
  lastPositionUpdate  = timestamp for throttling position renders (500ms)
  positionUpdateTimer = setTimeout ID for deferred position renders

SECTIONS & KEY FUNCTIONS (search by name with Grep)
─────────────────────────────────────────────────────
CSS STYLES ............................................. lines 8-1180
  :root variables, option chain table, position cards, quick entry, risk panel,
  toast notifications, debug console, ladder panel, animations

HTML LAYOUT ............................................ lines 1183-1675
  Header:           Index select, Expiry select, WS status, Connect button .... 1185-1214
  Connection Panel: API key input, broker profiles (hidden) ................... 1216-1254
  Index Card:       Index LTP, ATM strike, change % .......................... 1256-1267
  Controls Panel:   Qty ±, MARKET/LIMIT toggle, Live PnL, Close All ......... 1269-1294
  Quick Entry:      Scalp/Medium/Full presets, Ladder button, market context .. 1296-1324
  Ladder Panel:     3-level price config, summary, save/load templates ....... 1325-1396
  Risk Management:  P&L progress bar, position risk, settings, session stats . 1397-1478
  PnL Management:   Stop loss, target, trailing, profit protection, auto TP/SL 1479-1558
  Option Chain:     Table with CE BUY/SELL | Strike | PE BUY/SELL columns .... 1560-1588
  Positions Panel:  Open/Closed tabs, position cards with exit buttons ....... 1589-1611
  Hotkey Indicator: Floating indicator showing hotkeys are active ............ 1612-1623
  Debug Console:    Collapsible log panel with clear/export buttons .......... 1624-1637
  Add Profile Modal: Modal for adding new broker profiles ................... 1638-1675

SCRIPT — CONFIG, STATE, ELEMENTS ...................... lines 1676-2042
  CONFIG object ................................................ 1678-1690
  state object ................................................. 1693-1736
  tradingState (extended state for advanced features) .......... 1738-1792

PART 8.1: STATE MANAGEMENT FUNCTIONS .................. lines 1794-1900
  updatePosition(symbol, data), removePosition(symbol)
  addOrder(orderId, orderData), updateOrderStatus(orderId, status)
  setTrailingStop(symbol, config)
  checkDailyLimits(), getSessionStats()

BROKER PROFILES ....................................... lines 1901-2018
  loadBrokerProfiles(), updateProfileDropdown(), showAddProfileModal()
  saveNewProfile(), handleProfileChange(), deleteCurrentProfile()

SESSION PNL & INIT .................................... lines 2044-2130
  getTodayKey(), loadSessionPnL(), saveSessionPnL()
  init()               — loads profiles, session P&L, sets up all event listeners

EVENT HANDLERS & CHART WINDOW ......................... lines 2132-2182
  handleIndexChange(), handleExpiryChange()
  openChart(symbol, optionType, strike) — opens chart_window.html popup

WEBSOCKET ............................................. lines 2185-2285
  connectWebSocket()   — creates WS, sets up onopen/onclose/onmessage
  authenticate()       — sends API key auth message
  subscribeToOptions(symbols) — subscribes to option + index symbols
  handleWebSocketMessage(data) — routes to updatePrice() or updateIndexInfo()
  updateConnectionStatus(connected)

PHASE 3: CONNECTION HEALTH MONITOR .................... lines 2287-2330
  updateConnectionHealth(type, latency), updateConnectionStatusUI()

PHASE 3: ORDER RETRY MECHANISM ........................ lines 2333-2385
  apiCallWithRetry(endpoint, data, maxRetries) — exponential backoff (1s, 2s, 4s)
  apiCall(endpoint, data)                      — single API call wrapper

PHASE 3: PRICE STALENESS DETECTION .................... lines 2386-2435
  updatePriceTimestamp(symbol), getPriceStaleness(symbol)
  isPriceStale(symbol), showStalePriceWarning(symbol), updatePriceStalenessUI()

PHASE 4: POSITION RECONCILIATION ...................... lines 2437-2540
  reconcilePositions() — compares local state with broker positionbook every 30s

PHASE 4: ORDER VALIDATION ............................. lines 2540-2618
  validateOrder(orderData, currentPrice) — qty limits, price range, margin, cooldown
  showOrderValidationDialog(validation, onConfirm, onCancel)

PHASE 4: AUDIT TRAIL .................................. lines 2619-2745
  logAuditEntry(action, details), logOrderPlaced(), logOrderCancelled()
  logPositionClosed(), logProfitProtectionTriggered()
  exportAuditTrail(), exportAuditTrailCSV(), loadAuditTrail()

PART 8.2: API ENDPOINT WRAPPERS ....................... lines 2746-2877
  placeLadderOrderAPI(symbol, levels)  — batch limit order placement
  setTrailingStopAPI(symbol, config)
  setProfitProtectionAPI(symbol, levels)
  getTradeJournalAPI(filters)
  reconcilePositionsAPI()

PART 8.3: WEBSOCKET MESSAGE EXTENSIONS ................ lines 2878-2980
  handleExtendedWSMessage(message) — routes: order_fill, trailing_stop_update, risk_alert, position_update, heartbeat
  handleOrderFill(), handleTrailingStopUpdate(), handleRiskAlert()
  handlePositionUpdate(), handleHeartbeat()
  placeAutoTPForLevel(symbol, qty, tpPrice)

PHASE 5: EXIT DECISION HELPER ......................... lines 3005-3163
  analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition)
  showExitDecisionHelper(symbol, ...) — shows when position in profit 30+ seconds
  closeExitHelper(), executeExitAction(action, symbol)

PHASE 5: TRADE JOURNAL ................................ lines 3165-3338
  startTrade(symbol, action, quantity, entryPrice)
  endTrade(exitPrice, pnl, exitReason)
  showTradeJournalEntry(trade), closeJournalModal(), saveJournalEntry()
  exportTradeJournal()

PHASE 5: LOSS AVERSION COUNTERMEASURES ................ lines 3340-3460
  checkLossAversion(currentPnl) — detects holding losers 2+ minutes
  showLossWarning(type, loss, countdown), hideLossWarning(), playAlertSound()

PART 9.3: RISK MANAGEMENT PANEL ....................... lines 3463-3595
  toggleRiskPanelExpand(), updateRiskPanelUI(), initRiskPanelListeners()

OPTION CHAIN & EXPIRY LOADING ......................... lines 3597-3692
  loadExpiries()       — fetches /api/v1/expiry → populates dropdown
  loadOptionChain()    — fetches /api/v1/optionchain → renders grid, subscribes WS

POSITION MANAGEMENT ................................... lines 3694-3778
  loadPositions()      — fetches /api/v1/positionbook → await fetchPositionPrices → renderPositions
  refreshPositions()   — manual refresh button handler

ORDER PLACEMENT ....................................... lines 3779-3842
  placeOrder(symbol, action, optionType, strike, offset)
    → /api/v1/placeorder → immediate virtualTPSL on success → loadPositions after 1s

PNL MONITORING & AUTO-CLOSE ........................... lines 3845-3995
  updateLivePnlDisplay(), checkPnlLimits()
  closePnlPositionsAuto(reason)
  updatePnlMonitoring(), updatePnlMonitorStatus()

PROFIT PROTECTION SYSTEM .............................. lines 3996-4210
  toggleProfitProtection(), updateProfitProtectionUI()
  checkProfitProtection() — tiered lockup (50%/60%/70%/80% at thresholds)
  resetProfitProtection()

AUTO TP/SL SYSTEM (VIRTUAL) ........................... lines 4117-4210
  toggleAutoTPSL()     — enables/disables auto TP/SL checkbox
  roundToTick(price)   — snap to 0.05
  placeAutoTPSL(symbol, entryPrice, quantity, action) — stores in virtualTPSL Map
  checkVirtualTPSLScalping(symbol, ltp) — called every tick, fires MARKET close
  executeVirtualTPSLScalping(type, symbol, tpsl)

PHASE 2: QUICK ENTRY PRESETS .......................... lines 4211-4290
  applyPreset(presetName) — Scalp (1 lot), Medium (2 lots), Full (5 lots)

PHASE 2: LADDER ORDER SYSTEM .......................... lines 4291-4498
  toggleLadderPanel(), getLadderLevels(), updateLadderSummary()
  autoFillLadder(), placeLadderOrder(action)
  saveLadderTemplate(), loadLadderTemplate()

PHASE 2: MARKET CONTEXT INDICATORS .................... lines 4500-4570
  updateMarketContext() — session time, expiry day, VIX, DTE

OPTION CHAIN RENDERING ................................ lines 4572-4668
  renderOptionChain(chain), moveStrikeSelection(direction)
  switchPositionTab(tab)

POSITION PRICE SOURCING & RENDERING ................... lines 4669-4824
  getPositionPrice(symbol) — WebSocket → option chain → null
  fetchPositionPrices()    — /api/v1/multiquotes API fallback for missing prices
  renderPositions()        — renders open/closed tabs with live PnL

PRICE UPDATES (WebSocket tick handler) ................ lines 4825-4875
  updatePrice(data)    — state.prices.set → checkVirtualTPSLScalping → renderPositions (throttled 500ms)

EVENT HANDLERS ........................................ lines 4878-5014
  handleConnect()      — fetches WS config, starts WS connection
  handleIndexChange(), handleExpiryChange(), adjustQuantity()
  toggleOrderType(), toggleHotkeys()
  handleHotkey(e)      — Arrow keys for BUY/SELL CE/PE, W/S for strike selection, F6 close all

ORDER & POSITION EXIT ................................. lines 5012-5235
  handleOrderClick(symbol, action, optionType, strike, offset)
  cancelOpenOrdersForSymbol(symbol) — cleans up TP/SL orders before exit
  exitPosition(symbol, quantity)    — multi-source price lookup → MARKET close → save PnL
  closeAllPositions()               — iterates all positions, exits each

UTILITIES ............................................. lines 5237-5320
  logToConsole(message, type) — filtered console logging
  clearConsole(), toggleConsole()
  showToast(message, type) — toast notifications (1s in performance mode)

PERIODIC TASKS & INIT ................................. lines 5322-5330
  setInterval(loadPositions, 5000) — periodic position refresh when connected
  init()               — called on page load

DATA FLOWS
─────────────────────────────────────────────────────
  Connect:        handleConnect → fetch /scalping/config → connectWebSocket → authenticate → loadExpiries → loadOptionChain → subscribeToOptions
  Price Tick:     WS message → handleWebSocketMessage → updatePrice → checkVirtualTPSLScalping → renderPositions (throttled)
  Order Place:    handleOrderClick → placeOrder → /api/v1/placeorder → immediate virtualTPSL → loadPositions (1s delay)
  Virtual TP/SL:  placeAutoTPSL → virtualTPSL Map → checkVirtualTPSLScalping (every tick) → executeVirtualTPSLScalping → MARKET close
  Position Exit:  exitPosition → cancelOpenOrdersForSymbol → calculate PnL → /api/v1/placeorder (reverse action) → save sessionClosedPnL entry
  PnL Monitor:    updatePnlMonitoring → checkPnlLimits → closePnlPositionsAuto (if SL/TP hit)
  Profit Protect: checkProfitProtection → tiered lockup → auto-exit if drops below secured level
  Chart Popup:    openChart → window.open(chart_window.html?params) → independent WS connection
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAlgo - Option Chain Scalping Interface</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0b0f14;
            --bg-secondary: #121821;
            --bg-card: rgba(18, 24, 33, 0.92);
            --panel-bg: rgba(14, 19, 26, 0.92);
            --bg-tertiary: rgba(255, 255, 255, 0.04);
            --accent-cyan: #53f2d6;
            --accent-magenta: #ffb443;
            --accent-yellow: #f7d774;
            --accent-purple: #6aa8ff;
            --accent-lime: #c7f55d;
            --text-primary: #f5f7fb;
            --text-secondary: #9aa8b6;
            --success: #57f59a;
            --danger: #ff6b6b;
            --warning: #ffb020;
            --itm-color: rgba(87, 245, 154, 0.12);
            --atm-color: rgba(255, 180, 67, 0.18);
            --otm-color: rgba(83, 242, 214, 0.12);
            --border-color: rgba(143, 162, 182, 0.2);
            --shadow-soft: 0 10px 24px rgba(6, 9, 14, 0.35);
            --shadow-tight: 0 6px 16px rgba(6, 9, 14, 0.28);
        }

        body {
            font-family: 'Space Grotesk', 'Bahnschrift', 'Segoe UI', sans-serif;
            background:
                radial-gradient(900px 600px at 5% -10%, rgba(83, 242, 214, 0.14), transparent 45%),
                radial-gradient(900px 600px at 95% 0%, rgba(255, 180, 67, 0.16), transparent 45%),
                linear-gradient(160deg, var(--bg-primary) 0%, #0f1723 100%);
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
            min-height: 100vh;
            padding: 16px;
            overflow: hidden;
        }

        .container {
            max-width: 1840px;
            margin: 0 auto;
            height: calc(100vh - 32px);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .layout {
            flex: 1 1 auto;
            min-height: 0;
            display: grid;
            grid-template-columns: 320px minmax(0, 1fr) 360px;
            gap: 14px;
        }

        .left-rail,
        .center-rail,
        .right-rail {
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .left-rail,
        .right-rail {
            overflow-y: auto;
            padding-right: 6px;
        }

        .center-rail {
            overflow: hidden;
        }

        .left-rail::-webkit-scrollbar,
        .right-rail::-webkit-scrollbar {
            width: 6px;
        }

        .left-rail::-webkit-scrollbar-thumb,
        .right-rail::-webkit-scrollbar-thumb {
            background: rgba(83, 242, 214, 0.25);
            border-radius: 999px;
        }

        /* Header */
        header {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px 16px;
            box-shadow: var(--shadow-tight);
            position: sticky;
            top: 12px;
            z-index: 50;
        }

        h1 {
            font-size: 18px;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scalp-radar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scalp-radar-bar {
            width: 140px;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .scalp-radar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(0, 255, 136, 0.4) 0%, rgba(255, 210, 63, 0.6) 60%, rgba(255, 107, 107, 0.6) 100%);
            transition: width 0.12s ease;
        }

        .scalp-radar-meta {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .radar-toggle-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .radar-toggle-btn.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.45);
            background: rgba(0, 255, 136, 0.12);
        }

        .scalp-radar.off .scalp-radar-fill {
            width: 0% !important;
        }

        .scalp-radar.off .scalp-radar-label {
            color: var(--text-secondary);
        }

        .scalp-radar-label {
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.6px;
            color: var(--text-secondary);
        }

        .scalp-radar-label.hot {
            color: var(--success);
        }

        .scalp-radar-label.warm {
            color: var(--warning);
        }

        .scalp-radar-label.cool {
            color: var(--text-secondary);
        }

        .scalp-radar-value {
            font-size: 10px;
            font-weight: 700;
            color: var(--text-primary);
        }

        input,
        select,
        button {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 10px;
            border-radius: 10px;
            font-size: 12px;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 2px rgba(83, 242, 214, 0.18);
        }

        button {
            cursor: pointer;
            font-weight: 600;
        }

        button:hover {
            border-color: rgba(83, 242, 214, 0.6);
            color: var(--text-primary);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-indicator.connected {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
        }

        .status-indicator.disconnected {
            background: rgba(255, 51, 102, 0.2);
            color: var(--danger);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .connected .status-dot {
            background: var(--success);
        }

        .disconnected .status-dot {
            background: var(--danger);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Index Card */
        .index-card {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px;
            box-shadow: var(--shadow-tight);
        }

        .index-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .index-title-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .index-chart-btn {
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--accent-cyan);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.12s ease, color 0.12s ease, border-color 0.12s ease;
        }

        .index-chart-btn:hover {
            background: var(--bg-primary);
        }

        .index-ltp {
            font-size: 30px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .index-change {
            font-size: 16px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .positive {
            color: var(--success);
        }

        .negative {
            color: var(--danger);
        }

        /* Controls Panel */
        .controls-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            box-shadow: var(--shadow-tight);
        }

        .qty-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .qty-btn {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--accent-cyan);
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.12s ease, color 0.12s ease, border-color 0.12s ease;
        }

        .qty-btn:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }

        .qty-display {
            font-size: 20px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            min-width: 80px;
            text-align: center;
        }

        .toggle-btn {
            padding: 8px 14px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .toggle-btn.active {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-lime));
            color: var(--bg-primary);
        }

        .connection-panel,
        .quick-presets-panel,
        .ladder-panel,
        .risk-panel,
        .pnl-management {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px;
            box-shadow: var(--shadow-tight);
        }

        .left-rail > *,
        .center-rail > *,
        .right-rail > * {
            margin-bottom: 0 !important;
        }

        /* Option Chain Table */
        .option-chain {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            overflow: auto;
            box-shadow: var(--shadow-tight);
            flex: 1 1 auto;
        }

        .option-chain::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .option-chain::-webkit-scrollbar-thumb {
            background: rgba(83, 242, 214, 0.25);
            border-radius: 999px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        thead {
            background: var(--bg-secondary);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 10px 6px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
        }

        td {
            padding: 8px 6px;
            text-align: center;
            font-size: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .option-chain th {
            padding: 6px 4px;
            font-size: 10px;
        }

        .option-chain td {
            padding: 4px 4px;
            font-size: 11px;
            line-height: 1.1;
        }

        .option-chain .price {
            font-size: 12px;
        }

        .option-chain .strike-price {
            font-size: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .option-chain .strike-main {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .option-chain .chart-launch {
            padding: 3px 6px;
            font-size: 10px;
        }

        .option-chain .auto-launch {
            border-color: rgba(83, 242, 214, 0.4);
            color: var(--accent-cyan);
            letter-spacing: 0.4px;
        }

        .option-chain .atm-label {
            font-size: 10px;
            color: #00ff88;
            display: block;
            margin-top: 2px;
        }

        .option-chain .action-btn {
            padding: 4px 6px;
            font-size: 10px;
            margin: 0;
        }

        tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        tr.itm {
            background: var(--itm-color);
        }

        tr.atm {
            background: var(--atm-color);
        }

        tr.otm {
            background: var(--otm-color);
        }

        /* Selected Row for Hotkey Trading */
        tr.selected {
            background: rgba(83, 242, 214, 0.18) !important;
            border-left: 4px solid var(--accent-cyan) !important;
            box-shadow: 0 0 12px rgba(83, 242, 214, 0.22);
        }

        tr.selected td {
            font-weight: 600;
        }

        .price {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 14px;
        }

        .label {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 700;
            background: var(--bg-secondary);
        }

        .label.atm-label {
            background: linear-gradient(135deg, var(--accent-yellow), #ffaa00);
            color: var(--bg-primary);
        }

        .strike {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 16px;
            color: var(--accent-yellow);
        }

        .action-btn {
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            margin: 1px;
        }

        .buy-btn,
        .action-btn.buy {
            background: rgba(87, 245, 154, 0.16);
            color: var(--success);
            border: 1px solid rgba(87, 245, 154, 0.35);
        }

        .sell-btn,
        .action-btn.sell {
            background: rgba(255, 107, 107, 0.16);
            color: var(--danger);
            border: 1px solid rgba(255, 107, 107, 0.35);
        }

        .action-btn.chart {
            background: rgba(90, 176, 255, 0.18);
            color: var(--text-primary);
            border: 1px solid rgba(90, 176, 255, 0.35);
        }

        .action-btn:hover {
            border-color: rgba(255, 255, 255, 0.4);
        }

        .action-btn:active {
        }

        /* Positions Panel */
        .positions-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px;
            box-shadow: var(--shadow-tight);
            display: flex;
            flex-direction: column;
            min-height: 260px;
        }

        #positionsContainer {
            flex: 1 1 auto;
            overflow-y: auto;
            padding-right: 4px;
        }

        /* Depth Scout Panel */
        .depth-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 14px;
            padding: 12px;
            box-shadow: var(--shadow-tight);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .depth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .depth-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .depth-meta {
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .depth-status {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-status.live {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-status.off {
            color: var(--text-secondary);
        }

        .depth-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .depth-symbol {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .depth-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .depth-side-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
        }

        .depth-side-btn.active {
            background: rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-color: var(--accent-cyan);
        }

        .depth-level-select {
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 10px;
            cursor: pointer;
        }

        .depth-toggle {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
        }

        .depth-toggle.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-summary {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .depth-summary span {
            display: block;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-table {
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
        }

        .depth-header-row,
        .depth-row {
            display: grid;
            grid-template-columns: 1.1fr 1fr 1fr 1.1fr;
            gap: 6px;
            padding: 6px 8px;
            font-size: 10px;
            font-variant-numeric: tabular-nums;
        }

        .depth-header-row {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-row {
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .depth-row.selected {
            background: rgba(0, 212, 255, 0.08);
        }

        .depth-bid {
            color: var(--success);
        }

        .depth-ask {
            color: var(--danger);
            text-align: right;
        }

        .depth-price-cell {
            cursor: pointer;
        }

        .depth-rows {
            max-height: 260px;
            overflow: auto;
        }

        .depth-quick {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .depth-selected {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .depth-selected span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .depth-quick-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .depth-modes {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .depth-mode-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-mode-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
        }

        .depth-mode-btn.active {
            background: rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-color: var(--accent-cyan);
        }

        .tooltip-target {
            position: relative;
        }

        .tooltip-target[data-tooltip]:hover::after,
        .tooltip-target.tooltip-show[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 6px);
            transform: translateX(-50%);
            background: rgba(15, 20, 27, 0.95);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 10px;
            padding: 6px 8px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .depth-reprice {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .depth-reprice-input {
            width: 70px;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 10px;
        }

        .depth-signals {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .signal-badge {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .signal-badge.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .signal-badge.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-score {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .depth-score-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-score-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-score-pill {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 700;
            border: 1px solid transparent;
        }

        .depth-score-pill.hot {
            background: rgba(0, 255, 136, 0.15);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-score-pill.warm {
            background: rgba(255, 210, 63, 0.12);
            color: var(--warning);
            border-color: rgba(255, 210, 63, 0.35);
        }

        .depth-score-pill.cool {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .greeks-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .greeks-panel span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .greeks-panel .hot {
            color: var(--success);
        }

        .greeks-panel .warm {
            color: var(--warning);
        }

        .depth-alert {
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid transparent;
        }

        .depth-alert.neutral {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .depth-alert.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-alert.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-footnote {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .positions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .positions-header h2 {
            font-size: 16px;
        }

        .position-tab {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            font-size: 12px;
            font-weight: 600;
        }

        .position-tab:hover {
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .position-tab.active {
            background: var(--accent-cyan);
            border-color: var(--accent-cyan);
            color: var(--bg-primary);
        }

        .position-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border-color 0.12s ease;
        }

        .position-item:hover {
            border-color: var(--accent-cyan);
        }

        .position-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .position-symbol {
            font-weight: 700;
            font-size: 14px;
        }

        .position-qty {
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
        }

        .position-pnl {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 16px;
        }

        .exit-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            background: var(--bg-primary);
            border: 1px solid var(--danger);
        }

        /* Quick Entry Presets */
        .preset-btn {
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            background: rgba(255,255,255,0.05);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .preset-btn:hover {
            background: rgba(83, 242, 214, 0.12);
            border-color: var(--accent-cyan);
        }

        .preset-btn.active {
            background: rgba(83, 242, 214, 0.2);
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .preset-btn--ladder {
            background: rgba(90, 176, 255, 0.2);
            border-color: rgba(90, 176, 255, 0.45);
            color: var(--text-primary);
        }

        /* Market Context Badges */
        .context-badge {
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 10px;
        }

        .context-badge.prime {
            background: rgba(0,255,136,0.15);
            color: var(--success);
        }

        .context-badge.caution {
            background: rgba(255,165,0,0.15);
            color: var(--warning);
        }

        .context-badge.danger {
            background: rgba(255,69,96,0.15);
            color: var(--danger);
        }

        /* Phase 3: Price Staleness Indicators */
        .price-live {
            position: relative;
        }
        
        .price-live::after {
            content: '●';
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 6px;
            color: var(--success);
        }
        
        .price-delayed {
            position: relative;
            opacity: 0.8;
        }
        
        .price-delayed::after {
            content: '●';
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 6px;
            color: var(--warning);
        }
        
        .price-stale {
            position: relative;
            opacity: 0.5;
        }
        
        .price-stale::after {
            content: '●';
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 6px;
            color: var(--danger);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        /* Phase 3: Connection Health Status */
        .connection-health {
            display: flex;
            gap: 10px;
            padding: 6px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            font-size: 10px;
        }
        
        .health-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .health-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .health-dot.warning {
            background: var(--warning);
        }
        
        .health-dot.error {
            background: var(--danger);
        }

        /* Phase 5: Exit Decision Helper Modal */
        .exit-helper-modal, .journal-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .exit-helper-content, .journal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .exit-helper-header, .journal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }
        
        .exit-helper-body, .journal-body {
            padding: 16px;
        }
        
        .exit-pnl {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
        }
        
        .exit-pnl.profit {
            background: rgba(0,255,136,0.15);
            color: var(--success);
        }
        
        .exit-pnl.loss {
            background: rgba(255,69,96,0.15);
            color: var(--danger);
        }
        
        .exit-analysis {
            margin-bottom: 12px;
        }
        
        .analysis-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .momentum-strong_up { color: var(--success); font-weight: 700; }
        .momentum-up { color: var(--success); }
        .momentum-neutral { color: var(--text-secondary); }
        .momentum-down { color: var(--warning); }
        .momentum-strong_down { color: var(--danger); font-weight: 700; }
        
        .exit-suggestion {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            background: var(--bg-tertiary);
        }
        
        .exit-suggestion.hold { border-left: 3px solid var(--success); }
        .exit-suggestion.trail { border-left: 3px solid var(--warning); }
        .exit-suggestion.exit { border-left: 3px solid var(--danger); }
        .exit-suggestion.consider_exit { border-left: 3px solid var(--warning); }
        .exit-suggestion.review { border-left: 3px solid var(--warning); }
        
        .exit-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .exit-action-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }
        
        .exit-action-btn:hover {
            background: rgba(83, 242, 214, 0.2);
            border-color: var(--accent-cyan);
        }
        
        /* Phase 5: Trade Journal Modal */
        .journal-summary {
            margin-bottom: 12px;
        }
        
        .journal-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .journal-row.pnl.profit strong { color: var(--success); }
        .journal-row.pnl.loss strong { color: var(--danger); }
        
        .journal-context {
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 12px;
        }
        
        .journal-exit-reason {
            margin-bottom: 12px;
        }
        
        .exit-reason-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .exit-reason-options label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .journal-notes textarea {
            width: 100%;
            height: 60px;
            margin-top: 8px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            resize: none;
        }
        
        .journal-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .save-btn {
            flex: 2;
            padding: 10px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        
        .skip-btn {
            flex: 1;
            padding: 10px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
        }
        
        /* Phase 5: Loss Warning Banner */
        .loss-warning-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 9999;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        .loss-warning-banner.warning {
            background: linear-gradient(90deg, rgba(255,165,0,0.9), rgba(255,140,0,0.9));
            color: white;
        }
        
        .loss-warning-banner.critical {
            background: linear-gradient(90deg, rgba(255,69,96,0.95), rgba(220,20,60,0.95));
            color: white;
            animation: slideDown 0.3s ease, pulse 1s infinite;
        }
        
        .loss-warning-banner.time {
            background: linear-gradient(90deg, rgba(255,193,7,0.9), rgba(255,152,0,0.9));
            color: #333;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .loss-warning-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .loss-message {
            font-weight: 700;
            font-size: 14px;
        }
        
        .loss-countdown {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .loss-actions {
            display: flex;
            gap: 8px;
        }
        
        .loss-exit-btn {
            padding: 8px 16px;
            background: white;
            color: var(--danger);
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
        }
        
        .loss-dismiss-btn {
            padding: 8px 12px;
            background: transparent;
            color: white;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 6px;
            cursor: pointer;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 0 8px;
        }
        
        .close-btn:hover {
            color: var(--text-primary);
        }

        .close-all-btn {
            background: var(--danger);
            color: white;
        }

        /* Live P&L Display */
        .live-pnl-display {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 12px;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .live-pnl-display.profit {
            border-color: var(--success);
            background: rgba(0, 255, 136, 0.1);
            color: var(--success);
        }

        .live-pnl-display.loss {
            border-color: var(--danger);
            background: rgba(255, 69, 96, 0.1);
            color: var(--danger);
        }

        /* P&L Management Panel */
        .pnl-management {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .pnl-input {
            width: 80px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: white;
            font-size: 12px;
            text-align: center;
        }

        .pnl-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .pnl-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .trail-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 100px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: slideIn 0.3s ease;
            max-width: 400px;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-cyan);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Hotkey Indicator */
        .hotkey-indicator {
            position: fixed;
            bottom: 20px;
            right: calc(360px + 20px);
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            font-size: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .hotkey-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .hotkey-key {
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .hidden {
            display: none;
        }

        /* Debug Console */
        .debug-console {
            position: fixed;
            bottom: 20px;
            left: calc(320px + 20px);
            width: 500px;
            max-height: 300px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 200;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }

        .console-title {
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .console-controls button {
            padding: 4px 8px;
            font-size: 10px;
            margin-left: 5px;
        }

        .console-log {
            max-height: 240px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .log-entry {
            padding: 3px 0;
            word-wrap: break-word;
        }

        .log-entry.info {
            color: var(--accent-cyan);
        }

        .log-entry.success {
            color: var(--success);
        }

        .log-entry.error {
            color: var(--danger);
        }

        .log-entry.warn {
            color: var(--accent-yellow);
        }

        .log-timestamp {
            color: var(--text-secondary);
            margin-right: 8px;
        }

        /* Price Update Animation */
        @keyframes priceUp {

            0%,
            100% {
                background: transparent;
            }

            50% {
                background: rgba(0, 255, 136, 0.3);
            }
        }

        @keyframes priceDown {

            0%,
            100% {
                background: transparent;
            }

            50% {
                background: rgba(255, 51, 102, 0.3);
            }
        }

        .price-up {
            animation: priceUp 0.5s ease;
        }

        .price-down {
            animation: priceDown 0.5s ease;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            body {
                overflow: auto;
            }

            .container {
                height: auto;
            }

            .layout {
                grid-template-columns: 1fr;
            }

            .left-rail,
            .right-rail {
                overflow: visible;
                padding-right: 0;
            }

            header {
                position: relative;
                top: auto;
            }

            .hotkey-indicator {
                right: 20px;
            }

            .debug-console {
                left: 20px;
                width: min(90vw, 520px);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            header {
                padding: 15px;
            }

            .header-controls {
                grid-template-columns: 1fr;
            }

            .index-info {
                flex-direction: column;
                gap: 10px;
            }

            table {
                font-size: 12px;
            }

            .action-btn {
                padding: 6px 12px;
                font-size: 11px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>⚡ Option Chain Scalping Interface</h1>
            <div class="header-controls">
                <div class="control-group">
                    <label>Index</label>
                    <select id="indexSelect">
                        <option value="NIFTY">NIFTY</option>
                        <option value="BANKNIFTY">BANKNIFTY</option>
                        <option value="SENSEX">SENSEX</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Expiry</label>
                    <select id="expirySelect">
                        <option value="">Loading...</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Status</label>
                    <div class="status-indicator disconnected" id="wsStatus">
                        <span class="status-dot"></span>
                        <span>Disconnected</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Scalp Radar</label>
                    <div class="scalp-radar" id="scalpRadar">
                        <div class="scalp-radar-bar">
                            <div id="scalpRadarFill" class="scalp-radar-fill"></div>
                        </div>
                        <div class="scalp-radar-meta">
                            <span id="scalpRadarLabel" class="scalp-radar-label cool">COOL</span>
                            <span id="scalpRadarValue" class="scalp-radar-value">--</span>
                        </div>
                        <button id="scalpRadarToggle" class="radar-toggle-btn">Radar Off</button>
                    </div>
                </div>
                <div class="control-group">
                    <button id="connectBtn" style="margin-top: 20px;">Connect</button>
                </div>
            </div>
        </header>

        <div class="layout">
            <section class="left-rail">

        <!-- Connection Panel -->
        <div class="connection-panel">
            <div class="panel-header">
                <h2>🔌 Connection</h2>
                <div class="connection-status" id="connectionStatus">
                    <span class="status-dot"></span>
                    <span>Disconnected</span>
                </div>
            </div>

            <!-- Broker Profile Manager (Hidden - Using Multi-Instance Setup) -->
            <div class="broker-profiles" style="margin-bottom: 15px; display: none;">
                <div style="display: flex; gap: 10px; align-items: flex-end;">
                    <div class="input-group" style="flex: 1;">
                        <label for="brokerProfile">🏦 Broker Profile</label>
                        <select id="brokerProfile"
                            style="padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; cursor: pointer;">
                            <option value="">-- Select Profile --</option>
                        </select>
                    </div>
                    <button onclick="showAddProfileModal()"
                        style="padding: 10px 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600; white-space: nowrap;">
                        ➕ Add Profile
                    </button>
                    <button onclick="deleteCurrentProfile()" id="deleteProfileBtn"
                        style="padding: 10px 15px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600; display: none;">
                        🗑️ Delete
                    </button>
                </div>
            </div>

            <div class="controls-grid">
                <div class="input-group">
                    <label for="apiKeyInput">API Key</label>
                    <input type="password" id="apiKeyInput"
                        placeholder="Enter your API key">
                </div>
            </div>
        </div>

        <!-- Index Card -->
        <div class="index-card">
            <div class="index-info">
                <div>
                    <div style="color: var(--text-secondary); font-size: 14px; margin-bottom: 5px;">
                        <div class="index-title-row">
                            <div><span id="indexName">NIFTY</span> | ATM: <span id="atmStrike">-</span></div>
                            <button class="index-chart-btn" id="indexChartBtn" title="Open index chart">📈</button>
                        </div>
                    </div>
                    <div class="index-ltp" id="indexLTP">-</div>
                </div>
                <div class="index-change" id="indexChange">- (--%)</div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <div class="qty-control">
                <button class="qty-btn" id="qtyMinus">−</button>
                <div class="qty-display"><span id="qtyValue">5</span> Lots</div>
                <button class="qty-btn" id="qtyPlus">+</button>
            </div>

            <div class="toggle-btn active" id="orderTypeToggle">MARKET</div>

            <div class="limit-price-container" id="limitPriceContainer" style="display: none;">
                <input type="number" id="limitPrice" placeholder="Limit Price" step="0.05" min="0"
                    style="width: 120px; padding: 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: white; font-size: 14px; text-align: center;">
            </div>

            <div class="toggle-btn" id="hotkeyToggle">Hotkeys: OFF</div>

            <!-- Live P&L Display -->
            <div class="live-pnl-display" id="livePnlDisplay">
                <span>Live P&L:</span>
                <span id="livePnlValue">₹0.00</span>
            </div>

            <button id="closeAllPositions" style="background: var(--danger); color: white;">Close All Positions
                (F6)</button>
        </div>

        <!-- Quick Entry Presets Panel -->
        <div class="quick-presets-panel">
            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                <span style="font-size: 12px; color: var(--text-secondary); font-weight: 600;">⚡ Quick Entry:</span>
                
                <button class="preset-btn preset-btn--ladder" onclick="toggleLadderPanel()" title="Multi-level limit orders">
                    📶 Ladder
                </button>
                
                <div class="divider" style="width: 1px; height: 25px; background: var(--border-color);"></div>
                
                <!-- Market Context Indicators -->
                <div id="marketContext" style="display: flex; gap: 8px; align-items: center; font-size: 11px;">
                    <span id="timeIndicator" class="context-badge">⏰ --:--</span>
                    <span id="dayIndicator" class="context-badge">📅 ---</span>
                    <span id="sessionIndicator" class="context-badge">🔴 Pre-Market</span>
                </div>
            </div>
        </div>
        
        <!-- Ladder Order Panel (Hidden by default) -->
        <div id="ladderPanel" class="ladder-panel" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <span style="font-size: 14px; font-weight: 700; color: var(--accent-purple);">📶 Ladder Order</span>
                <button onclick="toggleLadderPanel()" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px;">✕</button>
            </div>
            
            <div style="display: flex; gap: 15px; align-items: flex-start; flex-wrap: wrap;">
                <!-- Ladder Levels -->
                <div style="flex: 1; min-width: 300px;">
                    <div id="ladderLevels">
                        <div class="ladder-level" data-level="1" style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 11px; color: var(--text-secondary); width: 50px;">Level 1:</span>
                            <input type="number" class="ladder-price" placeholder="Price" step="0.05" style="width: 80px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <input type="number" class="ladder-qty" placeholder="Lots" value="2" min="1" style="width: 60px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-secondary);">
                                <input type="checkbox" class="ladder-auto-tp" checked style="width: 12px; height: 12px;">
                                Auto-TP
                            </label>
                        </div>
                        <div class="ladder-level" data-level="2" style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 11px; color: var(--text-secondary); width: 50px;">Level 2:</span>
                            <input type="number" class="ladder-price" placeholder="Price" step="0.05" style="width: 80px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <input type="number" class="ladder-qty" placeholder="Lots" value="3" min="1" style="width: 60px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-secondary);">
                                <input type="checkbox" class="ladder-auto-tp" checked style="width: 12px; height: 12px;">
                                Auto-TP
                            </label>
                        </div>
                        <div class="ladder-level" data-level="3" style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 11px; color: var(--text-secondary); width: 50px;">Level 3:</span>
                            <input type="number" class="ladder-price" placeholder="Price" step="0.05" style="width: 80px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <input type="number" class="ladder-qty" placeholder="Lots" value="5" min="1" style="width: 60px; padding: 6px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 6px; color: white; font-size: 12px;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-secondary);">
                                <input type="checkbox" class="ladder-auto-tp" checked style="width: 12px; height: 12px;">
                                Auto-TP
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Ladder Summary & Actions -->
                <div style="min-width: 200px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                        <div>Total Lots: <span id="ladderTotalLots" style="color: white; font-weight: 600;">10</span></div>
                        <div>Avg Entry: <span id="ladderAvgEntry" style="color: var(--success); font-weight: 600;">--</span></div>
                    </div>
                    
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button onclick="placeLadderOrder('BUY')" class="action-btn buy" style="flex: 1; min-width: 80px; padding: 8px;">
                            📈 BUY Ladder
                        </button>
                        <button onclick="placeLadderOrder('SELL')" class="action-btn sell" style="flex: 1; min-width: 80px; padding: 8px;">
                            📉 SELL Ladder
                        </button>
                    </div>
                    
                    <div style="margin-top: 8px; display: flex; gap: 6px;">
                        <button onclick="saveLadderTemplate()" style="flex: 1; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); font-size: 10px; cursor: pointer;">
                            💾 Save
                        </button>
                        <button onclick="loadLadderTemplate()" style="flex: 1; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); font-size: 10px; cursor: pointer;">
                            📂 Load
                        </button>
                        <button onclick="autoFillLadder()" style="flex: 1; padding: 6px; background: rgba(255,255,255,0.1); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); font-size: 10px; cursor: pointer;">
                            🔄 Auto
                        </button>
                    </div>
                </div>
            </div>
        </div>

            </section>

            <main class="center-rail">
        <!-- Option Chain Table -->
        <div class="option-chain">
            <table>
                <thead>
                    <tr>
                        <th colspan="2">CALL OPTIONS (CE)</th>
                        <th>STRIKE</th>
                        <th colspan="2">PUT OPTIONS (PE)</th>
                    </tr>
                    <tr>
                        <th>LTP</th>
                        <th>ACTIONS</th>
                        <th>PRICE</th>
                        <th>ACTIONS</th>
                        <th>LTP</th>
                    </tr>
                </thead>
                <tbody id="optionChainBody">
                    <tr>
                        <td colspan="5" style="padding: 40px; color: var(--text-secondary);">
                            Enter API key and click Connect to load option chain
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

            </main>

            <aside class="right-rail">
        <!-- Positions Panel -->
        <div class="positions-panel">
            <div class="positions-header">
                <div style="display: flex; gap: 15px; align-items: center;">
                    <button class="position-tab active" id="openTab" onclick="switchPositionTab('open')">📊 Open</button>
                    <button class="position-tab" id="closedTab" onclick="switchPositionTab('closed')">✅ Closed</button>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <div class="position-pnl">Total P&L: <span id="totalPnL">₹0</span></div>
                    <button onclick="refreshPositions()"
                            style="background: rgba(0, 212, 255, 0.2); border: 1px solid var(--accent-cyan); color: var(--accent-cyan); padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s;"
                            onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'"
                            onmouseout="this.style.background='rgba(0, 212, 255, 0.2)'"
                            title="Refresh positions and P&L">🔄 Refresh</button>
                </div>
            </div>
            <div id="positionsContainer">
                <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                    No open positions
                </div>
            </div>
        </div>

        <!-- Depth Scout Panel -->
        <div class="depth-panel" id="depthPanel">
            <div class="depth-header">
                <div class="depth-title">Depth Scout</div>
                <div class="depth-meta">
                    <span id="depthBroker">Broker: --</span>
                    <span id="depthStatus" class="depth-status off">Off</span>
                </div>
            </div>
            <div class="depth-controls">
                <div class="depth-symbol" id="depthSymbol">Select a strike</div>
                <div class="depth-actions">
                    <button class="depth-side-btn active" data-side="CE">CE</button>
                    <button class="depth-side-btn" data-side="PE">PE</button>
                    <select id="depthLevelSelect" class="depth-level-select">
                        <option value="5">5 Levels</option>
                        <option value="20">20 Levels</option>
                    </select>
                    <button id="depthToggleBtn" class="depth-toggle active">Depth On</button>
                </div>
            </div>
            <div class="depth-modes">
                <span class="depth-mode-label">Mode</span>
                <button class="depth-mode-btn tooltip-target active" data-mode="JOIN" data-tooltip="Join best bid/ask to queue without crossing">Join</button>
                <button class="depth-mode-btn tooltip-target" data-mode="STEP" data-tooltip="Step 1 tick inside spread for faster priority">Step-In</button>
                <button class="depth-mode-btn tooltip-target" data-mode="TAKE" data-tooltip="Cross spread for fastest fill (uses market if allowed)">Take</button>
                <label class="depth-reprice tooltip-target" data-tooltip="Auto-cancel/replace to stay near top of book">
                    <input type="checkbox" id="depthRepriceToggle" checked style="width: 12px; height: 12px;">
                    <span>Reprice</span>
                </label>
                <input type="number" id="depthRepriceMs" class="depth-reprice-input" min="100" step="50" value="400" title="Reprice after ms">
            </div>
            <div class="depth-signals">
                <span id="signalMomentum" class="signal-badge">Momentum --</span>
                <span id="signalSpread" class="signal-badge">Spread --</span>
                <span id="signalLiquidity" class="signal-badge">Liquidity --</span>
                <span id="signalGamma" class="signal-badge">Gamma Squeeze --</span>
            </div>
            <div class="depth-score">
                <span class="depth-score-label">Scalp Score</span>
                <span id="scalpScore" class="depth-score-value">--</span>
                <span id="scalpScoreLabel" class="depth-score-pill cool">COOL</span>
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAlertToggle" checked style="width: 12px; height: 12px;">
                    <span>Alerts</span>
                </label>
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAudioToggle" style="width: 12px; height: 12px;">
                    <span>Audio</span>
                </label>
                <label class="depth-reprice tooltip-target" data-tooltip="Block MARKET orders; force LIMIT for depth actions">
                    <input type="checkbox" id="depthLimitOnly" style="width: 12px; height: 12px;">
                    <span>No MKT</span>
                </label>
            </div>
            <div class="greeks-panel">
                <div>Gamma Proxy<span id="gammaProxy">--</span></div>
                <div>Vol Spike<span id="volProxy">--</span></div>
            </div>
            <div class="depth-summary">
                <div>Bid <span id="depthTopBid">--</span></div>
                <div>Ask <span id="depthTopAsk">--</span></div>
                <div>Spread <span id="depthSpread">--</span></div>
                <div>Imb <span id="depthImbalance">--</span></div>
            </div>
            <div class="depth-table">
                <div class="depth-header-row">
                    <div>Bid Qty</div>
                    <div>Bid</div>
                    <div style="text-align:right;">Ask</div>
                    <div style="text-align:right;">Ask Qty</div>
                </div>
                <div class="depth-rows" id="depthRows"></div>
            </div>
            <div class="depth-quick">
                <div class="depth-selected">Selected <span id="depthSelectedPrice">--</span></div>
                <div class="depth-quick-actions">
                    <button id="depthBuyBtn" class="action-btn buy">BUY @ --</button>
                    <button id="depthSellBtn" class="action-btn sell">SELL @ --</button>
                </div>
            </div>
            <div class="depth-alert neutral" id="depthAlert">Imbalance neutral</div>
            <div class="depth-footnote" id="depthHint">Read-only. Uses live depth feed when available.</div>
        </div>

        <!-- Part 9.3: Risk Management Panel -->
        <div id="riskManagementPanel" class="risk-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <span style="font-size: 14px; font-weight: 700; color: var(--warning);">⚠️ Risk Management</span>
                <button onclick="toggleRiskPanelExpand()" id="riskPanelToggle" style="background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px;">
                    ▼ Expand
                </button>
            </div>
            
            <!-- Daily P&L Progress Bar -->
            <div style="margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px;">
                    <span>Daily P&L: <span id="dailyPnlValue" style="font-weight: 700;">₹0</span></span>
                    <span>Limit: <span id="dailyLimitValue">₹10,000</span></span>
                </div>
                <div style="height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                    <div id="dailyPnlBar" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
                </div>
            </div>
            
            <!-- Current Position Risk (Collapsible) -->
            <div id="riskPanelExpanded" style="display: none;">
                <div style="background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">Current Position Risk</div>
                    <div id="positionRiskInfo" style="font-size: 11px; color: var(--text-secondary);">
                        No active position
                    </div>
                    <div id="positionRiskBar" style="display: none; margin-top: 8px;">
                        <div style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                            <div id="positionLossBar" style="height: 100%; width: 0%; background: var(--danger); transition: all 0.3s;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Risk Settings -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 11px;">
                    <div>
                        <label style="color: var(--text-secondary);">Per-trade Max Loss</label>
                        <input type="number" id="perTradeLossLimit" value="2000" style="width: 100%; padding: 6px; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); margin-top: 4px;">
                    </div>
                    <div>
                        <label style="color: var(--text-secondary);">Daily Max Loss</label>
                        <input type="number" id="dailyLossLimit" value="10000" style="width: 100%; padding: 6px; background: rgba(0,0,0,0.2); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); margin-top: 4px;">
                    </div>
                </div>
                
                <div style="margin-top: 10px; display: flex; gap: 10px; align-items: center;">
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 11px; cursor: pointer;">
                        <input type="checkbox" id="autoExitOnMaxLoss" checked style="width: 14px; height: 14px;">
                        <span>Auto-exit on max loss</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 11px; cursor: pointer;">
                        <input type="checkbox" id="dailyLossBlockEnabled" style="width: 14px; height: 14px;">
                        <span>Block on daily max loss</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 11px; cursor: pointer;">
                        <input type="checkbox" id="coolingOffEnabled" checked style="width: 14px; height: 14px;">
                        <span>30 min cooling-off</span>
                    </label>
                </div>
                
                <!-- Session Stats -->
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                    <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">📊 Session Stats</div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; font-size: 10px;">
                        <div style="text-align: center; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <div style="color: var(--text-secondary);">Trades</div>
                            <div id="statsTotalTrades" style="font-weight: 700; font-size: 14px;">0</div>
                        </div>
                        <div style="text-align: center; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <div style="color: var(--text-secondary);">Win Rate</div>
                            <div id="statsWinRate" style="font-weight: 700; font-size: 14px; color: var(--success);">0%</div>
                        </div>
                        <div style="text-align: center; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <div style="color: var(--text-secondary);">Profit Factor</div>
                            <div id="statsProfitFactor" style="font-weight: 700; font-size: 14px;">N/A</div>
                        </div>
                        <div style="text-align: center; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                            <div style="color: var(--text-secondary);">Net P&L</div>
                            <div id="statsNetPnL" style="font-weight: 700; font-size: 14px;">₹0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- P&L Management Panel -->
        <div class="pnl-management">
            <!-- Row 1: Basic SL/TP/Trail -->
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 12px;">
                <div>
                    <div class="pnl-label">Stop Loss (₹)</div>
                    <input type="number" id="stopLoss" class="pnl-input" placeholder="e.g., -500" step="50">
                </div>
                <div>
                    <div class="pnl-label">Target Profit (₹) <span style="font-size: 10px; opacity: 0.7;">*activates
                            trail</span></div>
                    <input type="number" id="targetProfit" class="pnl-input" placeholder="e.g., 1000" step="50">
                </div>
                <div>
                    <div class="pnl-label">Trail Points (₹)</div>
                    <input type="number" id="trailPoints" class="pnl-input" placeholder="e.g., 200" step="50" disabled>
                </div>
                <label class="trail-checkbox">
                    <input type="checkbox" id="enableTrailing" style="width: 18px; height: 18px;">
                    <span>Enable Trailing</span>
                </label>
                <div style="font-size: 11px; color: var(--text-secondary); max-width: 350px;">
                    <div id="pnlMonitorStatus">⚪ Monitoring: OFF</div>
                    <div style="opacity: 0.7; margin-top: 3px;">💡 With trailing: Target activates trail, not immediate
                        close</div>
                </div>
            </div>
            
            <!-- Row 2: Profit Protection System -->
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                <label class="trail-checkbox" style="min-width: 160px;">
                    <input type="checkbox" id="enableProfitProtection" style="width: 18px; height: 18px;" onchange="toggleProfitProtection()">
                    <span>🛡️ Profit Protection</span>
                </label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <div class="pnl-label" style="margin-bottom: 0;">Breakeven at:</div>
                    <input type="number" id="breakevenThreshold" class="pnl-input" value="300" step="50" style="width: 80px;" disabled>
                    <span style="font-size: 11px; color: var(--text-secondary);">₹</span>
                </div>
                
                <!-- Secured Profit Display -->
                <div id="securedProfitDisplay" style="display: none; background: linear-gradient(135deg, rgba(0,255,136,0.15) 0%, rgba(0,200,100,0.1) 100%); padding: 8px 15px; border-radius: 8px; border: 1px solid rgba(0,255,136,0.3);">
                    <div style="font-size: 10px; color: var(--success); text-transform: uppercase; letter-spacing: 1px;">🔒 Secured</div>
                    <div id="securedProfitValue" style="font-size: 18px; font-weight: 700; color: var(--success);">₹0</div>
                </div>
                
                <!-- Protection Level Indicator -->
                <div id="protectionLevelIndicator" style="display: none; font-size: 11px; color: var(--text-secondary);">
                    <div>Level: <span id="currentProtectionLevel" style="color: var(--success); font-weight: 600;">-</span></div>
                    <div style="opacity: 0.7;">Next: <span id="nextProtectionLevel">₹500 → 50%</span></div>
                </div>
                
                <!-- Breakeven Status -->
                <div id="breakevenStatus" style="display: none; padding: 6px 12px; border-radius: 6px; font-size: 11px; font-weight: 600;">
                    <span id="breakevenStatusText">⚪ Breakeven: Inactive</span>
                </div>
            </div>
            
            <!-- Row 3: Auto TP/SL Settings (for limit orders) -->
            <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; padding-top: 12px; margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                <label class="trail-checkbox" style="min-width: 140px;">
                    <input type="checkbox" id="enableAutoTPSL" style="width: 18px; height: 18px;" onchange="toggleAutoTPSL()">
                    <span>🎯 Auto TP/SL</span>
                </label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <div class="pnl-label" style="margin-bottom: 0; color: var(--success);">TP:</div>
                    <input type="number" id="autoTPPoints" class="pnl-input" value="5" step="0.5" min="0.5" style="width: 60px;" disabled onchange="state.autoTPPoints = parseFloat(this.value) || 5">
                    <span style="font-size: 11px; color: var(--text-secondary);">pts</span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <div class="pnl-label" style="margin-bottom: 0; color: var(--danger);">SL:</div>
                    <input type="number" id="autoSLPoints" class="pnl-input" value="8" step="0.5" min="0.5" style="width: 60px;" disabled onchange="state.autoSLPoints = parseFloat(this.value) || 8">
                    <span style="font-size: 11px; color: var(--text-secondary);">pts</span>
                </div>
                <div style="font-size: 10px; color: var(--text-secondary); opacity: 0.7; max-width: 250px;">
                    💡 Virtual TP/SL — monitors price, closes with market order
                </div>
            </div>
        </div>

            </aside>
        </div>

        <!-- Hotkey Indicator -->
        <div class="hotkey-indicator hidden" id="hotkeyIndicator">
            <div style="font-weight: 700; margin-bottom: 10px; color: var(--accent-cyan);">HOTKEYS ENABLED</div>
            <div class="hotkey-item"><span class="hotkey-key">↑</span> Buy CE</div>
            <div class="hotkey-item"><span class="hotkey-key">↓</span> Buy PE</div>
            <div class="hotkey-item"><span class="hotkey-key">←</span> Sell CE</div>
            <div class="hotkey-item"><span class="hotkey-key">→</span> Sell PE</div>
            <div class="hotkey-item"><span class="hotkey-key">W</span> Move Up Strike</div>
            <div class="hotkey-item"><span class="hotkey-key">S</span> Move Down Strike</div>
            <div class="hotkey-item"><span class="hotkey-key">F6</span> Close All Positions</div>
        </div>

        <!-- Debug Console -->
        <div class="debug-console" id="debugConsole">
            <div class="console-controls">
                <span style="font-weight: 600; font-size: 14px;">📋 Debug Console</span>
                <div style="display: flex; gap: 8px;">
                    <button onclick="clearConsole()"
                        style="padding: 5px 12px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 12px;">Clear</button>
                    <button onclick="toggleConsole()" id="consoleToggleBtn"
                        style="padding: 5px 12px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: white; cursor: pointer; font-size: 12px;">Hide</button>
                </div>
            </div>
            <div class="console-log" id="consoleLog"></div>
        </div>

        <!-- Add Profile Modal -->
        <div id="addProfileModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; align-items: center; justify-content: center;">
            <div
                style="background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%); padding: 30px; border-radius: 20px; max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <h2 style="margin: 0 0 20px 0; color: var(--accent-cyan);">🏦 Add Broker Profile</h2>

                <div style="margin-bottom: 15px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 14px;">Profile
                        Name</label>
                    <input type="text" id="newProfileName" placeholder="e.g., Kotak Primary, Dhan Backup"
                        style="width: 100%; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; box-sizing: border-box;">
                </div>

                <div style="margin-bottom: 20px;">
                    <label
                        style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 14px;">API
                        Key</label>
                    <input type="password" id="newProfileKey" placeholder="Enter OpenAlgo API key"
                        style="width: 100%; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white; font-size: 14px; box-sizing: border-box;">
                </div>

                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeAddProfileModal()"
                        style="padding: 10px 20px; background: rgba(255,255,255,0.1); border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600;">
                        Cancel
                    </button>
                    <button onclick="saveNewProfile()"
                        style="padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                        Save Profile
                    </button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Configuration - wsUrl fetched from server, with port-derived fallback
        const CONFIG = {
            wsUrl: `ws://${window.location.hostname}:${parseInt(window.location.port || '5000') + 3765}`,
            apiUrl: '',
            strikeCount: 10,
            positionUpdateInterval: 5000,
            depthRenderThrottleMs: 80,
            tickSize: 0.05,
            // Performance Mode (for scalping speed)
            performanceMode: {
                disableConsoleLog: true,    // Disable console logging for speed
                fastToasts: true,           // Faster toast animations (200ms instead of 3000ms)
                disablePriceAnimations: true, // No flash on price updates (saves ~50ms per tick)
                optimisticUI: true          // Assume orders succeed (instant feedback)
            }
        };

        // State
        const state = {
            ws: null,
            connected: false,
            apiKey: '',
            selectedIndex: 'NIFTY',
            selectedExpiry: '',
            expiryFormatted: '',
            optionChainData: [],
            positions: [],
            quantity: 5,
            orderType: 'MARKET',
            limitPrice: 0,
            hotkeysEnabled: false,
            prices: new Map(),
            brokerProfiles: [],
            currentProfile: null,
            selectedStrike: null,  // For hotkey trading on selected row
            currentBroker: null,
            optionExchange: null,
            depthEnabled: true,
            depthLevel: 5,
            depthSide: 'CE',
            depthSymbol: null,
            depthExchange: null,
            depthLastUpdate: 0,
            depthRequestedLevel: 5,
            depthStrike: null,
            depthSelectedPrice: null,
            depthSelectedSide: null,
            depthTopBidValue: null,
            depthTopAskValue: null,
            depthOrderMode: 'JOIN',
            depthRepriceEnabled: true,
            depthRepriceMs: 400,
            depthRepriceMaxRetries: 2,
            depthAlertEnabled: true,
            depthLimitOnly: false,
            depthLastScore: 0,
            depthLastAlertTs: 0,
            depthStepInTicks: 1,
            depthTakeMaxSpread: 0.1,
            depthMomentumWindow: 8,
            depthMomentumThreshold: 6,
            depthSpreadWide: 0.2,
            depthSpreadTight: 0.05,
            depthLiquidityDropPct: 40,
            depthImbalanceMomentum: 0,
            depthGammaAccelHigh: 12,
            depthGammaAccelMed: 6,
            depthVolHigh: 6,
            depthVolMed: 3,
            depthPriceHistorySize: 12,
            depthLastSpeed: 0,
            depthGammaLevel: 'LOW',
            depthVolLevel: 'LOW',
            depthAudioEnabled: true,
            depthLastAudioTs: 0,
            scalpRadarEnabled: false,
            chartSidePreference: 'CE',
            depthUnderlyingHistorySize: 8,
            depthUnderlyingSpeedHigh: 60,
            depthUnderlyingAccelHigh: 25,
            depthUnderlyingMovePts: 5,
            depthUnderlyingSpeed: 0,
            depthUnderlyingAccel: 0,
            depthUnderlyingMove: 0,
            depthGammaSqueezeActive: false,
            totalPnl: 0,
            openPnl: 0,
            autoExitOnMaxLoss: true,
            perTradeExitPending: new Set(),
            stopLoss: null,
            targetProfit: null,
            trailingEnabled: false,
            trailPoints: 0,
            highestPnl: 0,  // Track highest P&L for trailing
            pnlMonitoringActive: false,
            activePositionTab: 'open',  // Track which tab is active: 'open' or 'closed'
            sessionClosedPnL: [],  // Track closed trades this session [{symbol, pnl, timestamp, qty, entryPrice, exitPrice, source}]
            isClosingPositions: false,  // Prevent multiple simultaneous auto-close triggers
            // Phase 1: Profit Protection System
            profitProtectionEnabled: false,
            profitProtectionLevels: [
                { trigger: 500, lockPercent: 50 },   // At ₹500 profit, lock 50% (₹250)
                { trigger: 1000, lockPercent: 60 },  // At ₹1000 profit, lock 60% (₹600)
                { trigger: 2000, lockPercent: 70 },  // At ₹2000 profit, lock 70% (₹1400)
                { trigger: 3000, lockPercent: 80 }   // At ₹3000 profit, lock 80% (₹2400)
            ],
            currentProtectionLevel: -1,  // Index of current active protection level
            securedProfit: 0,  // Amount of profit that is "locked in"
            breakevenActivated: false,  // Whether breakeven mode is active
            breakevenThreshold: 300,  // Activate breakeven at this profit level
            autoTPEnabled: false,  // Auto take-profit on limit order fills
            autoTPPoints: 5,  // Points above entry for auto TP
            autoSLPoints: 8,   // Points below entry for auto SL
            virtualTPSL: new Map()  // Virtual TP/SL levels {symbol: {tpPrice, slPrice, entryPrice, action, quantity}}
        };

        // ========== PART 8.1: ENHANCED STATE MANAGEMENT ==========
        
        const tradingState = {
            // Position tracking (Map for O(1) lookups)
            positions: new Map(),      // symbol -> { qty, avgPrice, pnl, entryTime }
            orders: new Map(),         // orderId -> { symbol, action, qty, price, status, timestamp }
            pendingOrders: new Map(),  // orderId -> order data (for optimistic UI)
            
            // Risk management
            dailyPnL: 0,
            maxDailyLoss: 10000,
            perTradeLossLimit: 2000,
            dailyTradeCount: 0,
            maxDailyTrades: 50,
            coolingOffUntil: null,     // Timestamp when cooling-off ends
            coolingOffEnabled: true,
            dailyLossBlockEnabled: false,
            lastDailyLossWarnTs: 0,
            
            // Trailing stop state
            trailingStops: new Map(),  // symbol -> { active, triggerPrice, trailPoints, highestPrice }
            profitProtectionState: new Map(), // symbol -> { level, securedAmount, breakevenActive }
            
            // Ladder order state
            ladderOrders: new Map(),   // ladderGroupId -> { levels: [], status, totalFilled }
            ladderTemplates: [],       // Saved ladder configurations
            
            // Connection state
            wsConnected: false,
            wsLatency: 0,
            lastHeartbeat: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            apiHealthy: true,
            lastApiResponse: null,
            
            // UI state
            selectedStrike: null,
            orderPreset: 'medium',
            ladderConfig: null,
            riskPanelExpanded: false,
            
            // Session tracking
            sessionStart: new Date().toISOString(),
            sessionTrades: [],
            sessionStats: {
                totalTrades: 0,
                winners: 0,
                losers: 0,
                grossProfit: 0,
                grossLoss: 0,
                largestWin: 0,
                largestLoss: 0
            }
        };
        
        // Make tradingState globally accessible
        window.tradingState = tradingState;
        
        // ========== PART 8.1: STATE MANAGEMENT FUNCTIONS ==========
        
        function updatePosition(symbol, data) {
            tradingState.positions.set(symbol, {
                ...tradingState.positions.get(symbol),
                ...data,
                lastUpdate: Date.now()
            });
            updateRiskPanelUI();
        }
        
        function removePosition(symbol) {
            const pos = tradingState.positions.get(symbol);
            if (pos) {
                // Update session stats
                if (pos.pnl >= 0) {
                    tradingState.sessionStats.winners++;
                    tradingState.sessionStats.grossProfit += pos.pnl;
                    tradingState.sessionStats.largestWin = Math.max(tradingState.sessionStats.largestWin, pos.pnl);
                } else {
                    tradingState.sessionStats.losers++;
                    tradingState.sessionStats.grossLoss += Math.abs(pos.pnl);
                    tradingState.sessionStats.largestLoss = Math.max(tradingState.sessionStats.largestLoss, Math.abs(pos.pnl));
                }
                tradingState.sessionStats.totalTrades++;
                tradingState.dailyPnL += pos.pnl;
            }
            tradingState.positions.delete(symbol);
            tradingState.trailingStops.delete(symbol);
            tradingState.profitProtectionState.delete(symbol);
            updateRiskPanelUI();
        }
        
        function addOrder(orderId, orderData) {
            tradingState.orders.set(orderId, {
                ...orderData,
                timestamp: Date.now(),
                status: 'pending'
            });
            tradingState.dailyTradeCount++;
        }
        
        function updateOrderStatus(orderId, status, fillData = null) {
            const order = tradingState.orders.get(orderId);
            if (order) {
                order.status = status;
                if (fillData) {
                    order.fillPrice = fillData.price;
                    order.fillQty = fillData.qty;
                    order.fillTime = Date.now();
                }
            }
        }
        
        function setTrailingStop(symbol, config) {
            tradingState.trailingStops.set(symbol, {
                active: true,
                triggerPrice: config.triggerPrice,
                trailPoints: config.trailPoints,
                highestPrice: config.currentPrice,
                createdAt: Date.now()
            });
        }
        
        function checkDailyLimits() {
            // If user disabled cooling-off, clear any active cooldown
            if (!tradingState.coolingOffEnabled && tradingState.coolingOffUntil) {
                tradingState.coolingOffUntil = null;
            }

            // Check if cooling off
            if (tradingState.coolingOffEnabled && tradingState.coolingOffUntil && Date.now() < tradingState.coolingOffUntil) {
                const remaining = Math.ceil((tradingState.coolingOffUntil - Date.now()) / 60000);
                return { allowed: false, reason: `Cooling off - ${remaining} min remaining` };
            }
            
            // Check daily loss limit
            const dailyPnl = Number.isFinite(state.totalPnl) ? state.totalPnl : (tradingState.dailyPnL || 0);
            if (dailyPnl <= -tradingState.maxDailyLoss) {
                const baseReason = `Daily loss limit reached (₹${tradingState.maxDailyLoss.toLocaleString()})`;

                if (!tradingState.dailyLossBlockEnabled) {
                    return { allowed: true, reason: baseReason, warnOnly: true };
                }

                if (tradingState.coolingOffEnabled && !tradingState.coolingOffUntil) {
                    tradingState.coolingOffUntil = Date.now() + (30 * 60 * 1000); // 30 min cooling off
                }
                const suffix = tradingState.coolingOffEnabled ? ' - cooling off' : '';
                return { allowed: false, reason: `${baseReason}${suffix}` };
            }
            
            // Check daily trade count
            if (tradingState.dailyTradeCount >= tradingState.maxDailyTrades) {
                return { allowed: false, reason: 'Daily trade limit reached' };
            }
            
            return { allowed: true };
        }

        function enforceRiskGate(contextLabel = 'Order') {
            const gate = checkDailyLimits();
            if (gate.warnOnly) {
                const now = Date.now();
                if (!tradingState.lastDailyLossWarnTs || now - tradingState.lastDailyLossWarnTs > 15000) {
                    tradingState.lastDailyLossWarnTs = now;
                    showToast(`⚠️ ${gate.reason}`, 'warning');
                    logToConsole(`${contextLabel} warning: ${gate.reason}`, 'warn');
                }
                return true;
            }
            if (!gate.allowed) {
                const message = `🚫 ${gate.reason}`;
                showToast(message, 'error');
                logToConsole(`${contextLabel} blocked: ${gate.reason}`, 'warn');
                return false;
            }
            return true;
        }
        
        function getSessionStats() {
            const closedPnls = [];

            const sessionEntries = Array.isArray(state.sessionClosedPnL)
                ? state.sessionClosedPnL
                : (state.sessionClosedPnL && typeof state.sessionClosedPnL === 'object')
                    ? Object.entries(state.sessionClosedPnL).map(([symbol, pnlVal]) => ({
                        symbol,
                        pnl: parseFloat(pnlVal)
                    }))
                    : [];

            if (sessionEntries.length > 0) {
                sessionEntries.forEach(entry => {
                    const pnl = typeof entry === 'number' ? entry : parseFloat(entry?.pnl);
                    if (!Number.isFinite(pnl)) return;
                    closedPnls.push(pnl);
                });
            } else if (Array.isArray(state.positions)) {
                // Fallback: use broker-reported closed positions if no session trades recorded
                state.positions.forEach(position => {
                    const qty = parseInt(position.quantity) || 0;
                    if (qty !== 0) return;
                    const pnl = parseFloat(position.pnl);
                    if (!Number.isFinite(pnl)) return;
                    closedPnls.push(pnl);
                });
            }

            let winners = 0;
            let losers = 0;
            let grossProfit = 0;
            let grossLoss = 0;
            let largestWin = 0;
            let largestLoss = 0;
            let zeroTrades = 0;

            closedPnls.forEach(pnl => {
                if (pnl > 0) {
                    winners++;
                    grossProfit += pnl;
                    if (pnl > largestWin) largestWin = pnl;
                } else if (pnl < 0) {
                    losers++;
                    const loss = Math.abs(pnl);
                    grossLoss += loss;
                    if (loss > largestLoss) largestLoss = loss;
                } else {
                    zeroTrades++;
                }
            });

            const totalTrades = winners + losers + zeroTrades;
            const winRate = totalTrades > 0 ? (winners / totalTrades * 100).toFixed(1) : 0;
            const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss).toFixed(2) : 'N/A';
            const avgWin = winners > 0 ? (grossProfit / winners).toFixed(0) : 0;
            const avgLoss = losers > 0 ? (grossLoss / losers).toFixed(0) : 0;

            return {
                totalTrades,
                winners,
                losers,
                grossProfit,
                grossLoss,
                largestWin,
                largestLoss,
                winRate,
                profitFactor,
                avgWin,
                avgLoss,
                netPnL: grossProfit - grossLoss
            };
        }

        // Make state globally accessible for chart windows
        window.state = state;


        // Broker Profile Management
        function loadBrokerProfiles() {
            const saved = localStorage.getItem('broker_profiles');
            state.brokerProfiles = saved ? JSON.parse(saved) : [];
            updateProfileDropdown();
        }

        function updateProfileDropdown() {
            const select = document.getElementById('brokerProfile');
            select.innerHTML = '<option value="">-- Select Profile --</option>';

            state.brokerProfiles.forEach((profile, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = profile.name;
                select.appendChild(option);
            });

            // Show/hide delete button
            const deleteBtn = document.getElementById('deleteProfileBtn');
            if (state.currentProfile !== null) {
                deleteBtn.style.display = 'block';
            } else {
                deleteBtn.style.display = 'none';
            }
        }

        function showAddProfileModal() {
            document.getElementById('addProfileModal').style.display = 'flex';
            document.getElementById('newProfileName').value = '';
            document.getElementById('newProfileKey').value = '';
            document.getElementById('newProfileName').focus();
        }

        function closeAddProfileModal() {
            document.getElementById('addProfileModal').style.display = 'none';
        }

        function saveNewProfile() {
            const name = document.getElementById('newProfileName').value.trim();
            const apiKey = document.getElementById('newProfileKey').value.trim();

            if (!name) {
                showToast('Please enter a profile name', 'error');
                return;
            }

            if (!apiKey || apiKey.length < 32) {
                showToast('Please enter a valid API key', 'error');
                return;
            }

            // Check for duplicate names
            if (state.brokerProfiles.some(p => p.name === name)) {
                showToast('Profile name already exists', 'error');
                return;
            }

            // Add new profile
            state.brokerProfiles.push({ name, apiKey });
            localStorage.setItem('broker_profiles', JSON.stringify(state.brokerProfiles));

            updateProfileDropdown();
            closeAddProfileModal();

            // Auto-select the new profile
            const select = document.getElementById('brokerProfile');
            select.value = state.brokerProfiles.length - 1;
            handleProfileChange();

            showToast(`✓ Profile "${name}" saved!`, 'success');
            logToConsole(`Saved broker profile: ${name}`, 'success');
        }

        function handleProfileChange() {
            const select = document.getElementById('brokerProfile');
            const index = parseInt(select.value);

            if (isNaN(index)) {
                state.currentProfile = null;
                state.apiKey = '';
                elements.apiKeyInput.value = '';
                document.getElementById('deleteProfileBtn').style.display = 'none';
                return;
            }

            state.currentProfile = index;
            const profile = state.brokerProfiles[index];
            state.apiKey = profile.apiKey;
            elements.apiKeyInput.value = profile.apiKey;

            document.getElementById('deleteProfileBtn').style.display = 'block';

            logToConsole(`Switched to profile: ${profile.name}`, 'info');
            showToast(`Switched to ${profile.name}`, 'success');
        }

        function deleteCurrentProfile() {
            if (state.currentProfile === null) return;

            const profile = state.brokerProfiles[state.currentProfile];

            if (!confirm(`Delete profile "${profile.name}"?`)) return;

            // Remove profile
            state.brokerProfiles.splice(state.currentProfile, 1);
            localStorage.setItem('broker_profiles', JSON.stringify(state.brokerProfiles));

            // Reset selection
            state.currentProfile = null;
            state.apiKey = '';
            elements.apiKeyInput.value = '';

            updateProfileDropdown();
            document.getElementById('brokerProfile').value = '';

            showToast(`Deleted profile "${profile.name}"`, 'success');
            logToConsole(`Deleted broker profile: ${profile.name}`, 'info');
        }

        // DOM Elements
        const elements = {
            apiKeyInput: document.getElementById('apiKeyInput'),
            indexSelect: document.getElementById('indexSelect'),
            expirySelect: document.getElementById('expirySelect'),
            connectBtn: document.getElementById('connectBtn'),
            wsStatus: document.getElementById('wsStatus'),
            scalpRadar: document.getElementById('scalpRadar'),
            scalpRadarFill: document.getElementById('scalpRadarFill'),
            scalpRadarLabel: document.getElementById('scalpRadarLabel'),
            scalpRadarValue: document.getElementById('scalpRadarValue'),
            scalpRadarToggle: document.getElementById('scalpRadarToggle'),
            indexName: document.getElementById('indexName'),
            indexLTP: document.getElementById('indexLTP'),
            indexChange: document.getElementById('indexChange'),
            atmStrike: document.getElementById('atmStrike'),
            indexChartBtn: document.getElementById('indexChartBtn'),
            qtyValue: document.getElementById('qtyValue'),
            qtyMinus: document.getElementById('qtyMinus'),
            qtyPlus: document.getElementById('qtyPlus'),
            orderTypeToggle: document.getElementById('orderTypeToggle'),
            hotkeyToggle: document.getElementById('hotkeyToggle'),
            optionChainBody: document.getElementById('optionChainBody'),
            positionsContainer: document.getElementById('positionsContainer'),
            totalPnL: document.getElementById('totalPnL'),
            hotkeyIndicator: document.getElementById('hotkeyIndicator'),
            closeAllPositions: document.getElementById('closeAllPositions'),
            depthPanel: document.getElementById('depthPanel'),
            depthSymbol: document.getElementById('depthSymbol'),
            depthStatus: document.getElementById('depthStatus'),
            depthBroker: document.getElementById('depthBroker'),
            depthLevelSelect: document.getElementById('depthLevelSelect'),
            depthToggleBtn: document.getElementById('depthToggleBtn'),
            depthRows: document.getElementById('depthRows'),
            depthTopBid: document.getElementById('depthTopBid'),
            depthTopAsk: document.getElementById('depthTopAsk'),
            depthSpread: document.getElementById('depthSpread'),
            depthImbalance: document.getElementById('depthImbalance'),
            depthSelectedPrice: document.getElementById('depthSelectedPrice'),
            depthBuyBtn: document.getElementById('depthBuyBtn'),
            depthSellBtn: document.getElementById('depthSellBtn'),
            depthAlert: document.getElementById('depthAlert'),
            depthHint: document.getElementById('depthHint'),
            depthRepriceToggle: document.getElementById('depthRepriceToggle'),
            depthRepriceMs: document.getElementById('depthRepriceMs'),
            depthAlertToggle: document.getElementById('depthAlertToggle'),
            depthAudioToggle: document.getElementById('depthAudioToggle'),
            depthLimitOnly: document.getElementById('depthLimitOnly'),
            scalpScore: document.getElementById('scalpScore'),
            scalpScoreLabel: document.getElementById('scalpScoreLabel'),
            gammaProxy: document.getElementById('gammaProxy'),
            volProxy: document.getElementById('volProxy'),
            signalMomentum: document.getElementById('signalMomentum'),
            signalSpread: document.getElementById('signalSpread'),
            signalLiquidity: document.getElementById('signalLiquidity'),
            signalGamma: document.getElementById('signalGamma')
        };

        // Option chain DOM caches (performance)
        const optionChainDomCache = {
            priceCells: [],
            priceCellMap: new Map(), // symbol -> [cell, ...]
            rows: []
        };
        const optionChainPriceMap = new Map(); // symbol -> ltp
        let selectedRowEl = null;
        let optionChainClickBound = false;

        const depthDomCache = {
            rows: [],
            bidQty: [],
            bidPrice: [],
            askPrice: [],
            askQty: [],
            maxRows: 20
        };

        const depthRenderState = {
            scheduled: false,
            lastRender: 0,
            pending: null
        };

        const depthAnalytics = {
            imbalanceHistory: [],
            spreadHistory: [],
            bidQtyHistory: [],
            askQtyHistory: [],
            priceHistory: [],
            underlyingHistory: []
        };

        function rebuildOptionChainCache(chain) {
            optionChainDomCache.priceCells = Array.from(elements.optionChainBody.querySelectorAll('td.price'));
            optionChainDomCache.priceCellMap.clear();
            for (const cell of optionChainDomCache.priceCells) {
                const symbol = cell.dataset.symbol;
                if (!symbol) continue;
                const list = optionChainDomCache.priceCellMap.get(symbol);
                if (list) {
                    list.push(cell);
                } else {
                    optionChainDomCache.priceCellMap.set(symbol, [cell]);
                }
            }
            optionChainDomCache.rows = Array.from(elements.optionChainBody.querySelectorAll('tr'));
            optionChainPriceMap.clear();
            if (Array.isArray(chain)) {
                for (const item of chain) {
                    const ce = item.ce || {};
                    const pe = item.pe || {};
                    if (ce.symbol && ce.ltp != null) {
                        const p = parseFloat(ce.ltp);
                        if (Number.isFinite(p)) optionChainPriceMap.set(ce.symbol, p);
                    }
                    if (pe.symbol && pe.ltp != null) {
                        const p = parseFloat(pe.ltp);
                        if (Number.isFinite(p)) optionChainPriceMap.set(pe.symbol, p);
                    }
                }
            }
            selectedRowEl = null;
        }

        function bindOptionChainSelection() {
            if (optionChainClickBound || !elements.optionChainBody) return;
            elements.optionChainBody.addEventListener('click', (e) => {
                if (e.target.closest('button')) return;
                const row = e.target.closest('tr');
                if (!row) return;
                const priceCell = e.target.closest('td.price');
                if (priceCell && priceCell.dataset.type) {
                    setDepthSide(priceCell.dataset.type.toUpperCase());
                }
                if (selectedRowEl && selectedRowEl !== row) {
                    selectedRowEl.classList.remove('selected');
                }
                row.classList.add('selected');
                selectedRowEl = row;
                const strike = parseFloat(row.dataset.strike);
                if (Number.isFinite(strike)) {
                    state.selectedStrike = strike;
                    logToConsole(`Selected strike: ${state.selectedStrike}`, 'info');
                }
                syncDepthTarget();
            });
            optionChainClickBound = true;
        }

        function isDhanBroker() {
            const broker = state.currentBroker ? state.currentBroker.toLowerCase() : '';
            if (broker.includes('dhan')) return true;
            return window.location.port === '5001';
        }

        // Depth Scout UI
        function initDepthPanel() {
            if (!elements.depthPanel) return;

            buildDepthRows();
            if (elements.depthRows) {
                elements.depthRows.addEventListener('click', handleDepthRowClick);
            }

            const sideButtons = Array.from(elements.depthPanel.querySelectorAll('.depth-side-btn'));
            sideButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const side = btn.dataset.side;
                    setDepthSide(side);
                });
            });

            const modeButtons = Array.from(elements.depthPanel.querySelectorAll('.depth-mode-btn'));
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setDepthOrderMode(mode);
                });
            });

            if (elements.depthLevelSelect) {
                elements.depthLevelSelect.value = String(state.depthLevel);
                elements.depthLevelSelect.addEventListener('change', (e) => {
                    const level = parseInt(e.target.value, 10);
                    setDepthLevel(level);
                });
            }

            if (elements.depthToggleBtn) {
                elements.depthToggleBtn.addEventListener('click', () => {
                    setDepthEnabled(!state.depthEnabled);
                });
            }
            if (elements.depthRepriceToggle) {
                elements.depthRepriceToggle.checked = state.depthRepriceEnabled;
                elements.depthRepriceToggle.addEventListener('change', (e) => {
                    state.depthRepriceEnabled = e.target.checked;
                });
            }
            if (elements.depthRepriceMs) {
                elements.depthRepriceMs.value = String(state.depthRepriceMs);
                elements.depthRepriceMs.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value, 10);
                    if (Number.isFinite(val) && val >= 100) {
                        state.depthRepriceMs = val;
                    }
                    elements.depthRepriceMs.value = String(state.depthRepriceMs);
                });
            }
            if (elements.depthAlertToggle) {
                elements.depthAlertToggle.checked = state.depthAlertEnabled;
                elements.depthAlertToggle.addEventListener('change', (e) => {
                    state.depthAlertEnabled = e.target.checked;
                });
            }
            if (elements.depthAudioToggle) {
                elements.depthAudioToggle.checked = state.depthAudioEnabled;
                elements.depthAudioToggle.addEventListener('change', (e) => {
                    state.depthAudioEnabled = e.target.checked;
                    if (state.depthAudioEnabled) {
                        initDepthAudio();
                    }
                });
            }
            if (elements.depthLimitOnly) {
                elements.depthLimitOnly.checked = state.depthLimitOnly;
                elements.depthLimitOnly.addEventListener('change', (e) => {
                    state.depthLimitOnly = e.target.checked;
                    updateDepthQuickUI();
                });
            }
            if (elements.depthBuyBtn) {
                elements.depthBuyBtn.addEventListener('click', () => placeDepthOrder('BUY'));
            }
            if (elements.depthSellBtn) {
                elements.depthSellBtn.addEventListener('click', () => placeDepthOrder('SELL'));
            }

            updateDepthBrokerUI();
            updateDepthSideUI();
            updateDepthModeUI();
            updateDepthStatusUI();
            updateDepthSymbolUI();
            updateDepthQuickUI();
            if (state.depthAudioEnabled) {
                initDepthAudio();
            }
        }

        let tooltipHintsBound = false;

        function initTooltipHints() {
            if (tooltipHintsBound) return;
            tooltipHintsBound = true;
            const targets = Array.from(document.querySelectorAll('.tooltip-target[data-tooltip]'));
            targets.forEach(el => {
                let timer;
                el.addEventListener('touchstart', () => {
                    el.classList.add('tooltip-show');
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1600);
                }, { passive: true });
                el.addEventListener('touchend', () => {
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1200);
                }, { passive: true });
            });
        }

        function buildDepthRows() {
            if (!elements.depthRows) return;
            elements.depthRows.innerHTML = '';
            depthDomCache.rows = [];
            depthDomCache.bidQty = [];
            depthDomCache.bidPrice = [];
            depthDomCache.askPrice = [];
            depthDomCache.askQty = [];

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = document.createElement('div');
                row.className = 'depth-row';
                row.dataset.index = String(i);

                const bidQty = document.createElement('div');
                const bidPrice = document.createElement('div');
                const askPrice = document.createElement('div');
                const askQty = document.createElement('div');

                bidPrice.classList.add('depth-bid', 'depth-price-cell');
                askPrice.classList.add('depth-ask', 'depth-price-cell');
                askQty.classList.add('depth-ask');
                bidPrice.dataset.side = 'bid';
                askPrice.dataset.side = 'ask';
                bidPrice.dataset.index = String(i);
                askPrice.dataset.index = String(i);

                row.appendChild(bidQty);
                row.appendChild(bidPrice);
                row.appendChild(askPrice);
                row.appendChild(askQty);

                elements.depthRows.appendChild(row);
                depthDomCache.rows.push(row);
                depthDomCache.bidQty.push(bidQty);
                depthDomCache.bidPrice.push(bidPrice);
                depthDomCache.askPrice.push(askPrice);
                depthDomCache.askQty.push(askQty);
            }
        }

        function setDepthSide(side) {
            if (!side) return;
            const normalized = side.toUpperCase();
            if (normalized !== 'CE' && normalized !== 'PE') return;
            if (state.depthSide === normalized) return;
            state.depthSide = normalized;
            state.chartSidePreference = normalized;
            updateDepthSideUI();
            syncDepthTarget();
        }

        function setDepthOrderMode(mode) {
            if (!mode) return;
            const normalized = mode.toUpperCase();
            if (!['JOIN', 'STEP', 'TAKE'].includes(normalized)) return;
            if (state.depthOrderMode === normalized) return;
            state.depthOrderMode = normalized;
            updateDepthModeUI();
            updateDepthQuickUI();
        }

        function setDepthLevel(level) {
            if (!Number.isFinite(level)) return;
            const requested = Math.max(1, Math.min(20, level));
            let normalized = requested;
            const allow20 = isDhanBroker() && (state.depthExchange ? state.depthExchange !== 'BFO' : true);
            if (!allow20 && normalized > 5) {
                normalized = 5;
            }
            state.depthRequestedLevel = requested;
            if (state.depthLevel === normalized) return;
            state.depthLevel = normalized;
            if (elements.depthLevelSelect) {
                elements.depthLevelSelect.value = String(normalized);
            }
            if (state.depthEnabled && state.depthSymbol && state.depthExchange) {
                unsubscribeDepth(state.depthSymbol, state.depthExchange);
                subscribeDepth(state.depthSymbol, state.depthExchange);
            }
            updateDepthHint();
        }

        function setDepthEnabled(enabled) {
            state.depthEnabled = !!enabled;
            updateDepthStatusUI();
            if (state.depthEnabled) {
                syncDepthTarget();
            } else if (state.depthSymbol && state.depthExchange) {
                unsubscribeDepth(state.depthSymbol, state.depthExchange);
            }
            clearDepthUI();
            updateDepthHint();
        }

        function updateDepthSideUI() {
            if (!elements.depthPanel) return;
            elements.depthPanel.querySelectorAll('.depth-side-btn').forEach(btn => {
                const active = btn.dataset.side === state.depthSide;
                btn.classList.toggle('active', active);
            });
        }

        function updateDepthModeUI() {
            if (!elements.depthPanel) return;
            elements.depthPanel.querySelectorAll('.depth-mode-btn').forEach(btn => {
                const active = btn.dataset.mode === state.depthOrderMode;
                btn.classList.toggle('active', active);
            });
        }

        function updateDepthBrokerUI() {
            if (!elements.depthBroker) return;
            const broker = state.currentBroker ? state.currentBroker.toUpperCase() : '--';
            elements.depthBroker.textContent = `Broker: ${broker}`;

            if (elements.depthLevelSelect) {
                const allow20 = isDhanBroker() && (state.depthExchange ? state.depthExchange !== 'BFO' : true);
                const opt20 = elements.depthLevelSelect.querySelector('option[value="20"]');
                if (opt20) {
                    opt20.disabled = !allow20;
                }
                if (!allow20 && state.depthLevel > 5) {
                    state.depthLevel = 5;
                    elements.depthLevelSelect.value = '5';
                }
            }
            updateDepthHint();
        }

        function updateDepthStatusUI() {
            if (!elements.depthStatus) return;
            const status = elements.depthStatus;
            if (!state.depthEnabled) {
                status.textContent = 'Off';
                status.classList.remove('live');
                status.classList.add('off');
            } else if (!state.connected || !state.depthSymbol) {
                status.textContent = 'On';
                status.classList.remove('live');
                status.classList.add('off');
            } else {
                const age = Date.now() - (state.depthLastUpdate || 0);
                if (state.depthLastUpdate && age < 5000) {
                    status.textContent = 'Live';
                    status.classList.add('live');
                    status.classList.remove('off');
                } else {
                    status.textContent = 'On';
                    status.classList.remove('live');
                    status.classList.add('off');
                }
            }

            if (elements.depthToggleBtn) {
                elements.depthToggleBtn.textContent = state.depthEnabled ? 'Depth On' : 'Depth Off';
                elements.depthToggleBtn.classList.toggle('active', state.depthEnabled);
            }

            const disableOrders = !state.depthEnabled || !state.depthSymbol;
            if (elements.depthBuyBtn) elements.depthBuyBtn.disabled = disableOrders;
            if (elements.depthSellBtn) elements.depthSellBtn.disabled = disableOrders;
        }

        function updateDepthSymbolUI(symbol, strike) {
            if (!elements.depthSymbol) return;
            if (!symbol) {
                elements.depthSymbol.textContent = 'Select a strike';
                return;
            }
            if (strike) {
                elements.depthSymbol.textContent = `${state.selectedIndex} ${strike} ${state.depthSide}`;
            } else {
                elements.depthSymbol.textContent = symbol;
            }
        }

        function updateDepthQuickUI() {
            const selectedPrice = state.depthSelectedPrice;
            if (elements.depthSelectedPrice) {
                elements.depthSelectedPrice.textContent = selectedPrice ? formatDepthPrice(selectedPrice) : '--';
            }
            const buySpec = getDepthOrderSpec('BUY');
            const sellSpec = getDepthOrderSpec('SELL');
            if (elements.depthBuyBtn) {
                elements.depthBuyBtn.textContent = buySpec.pricetype === 'MARKET'
                    ? 'BUY @ MKT'
                    : `BUY @ ${buySpec.price ? formatDepthPrice(buySpec.price) : '--'}`;
            }
            if (elements.depthSellBtn) {
                elements.depthSellBtn.textContent = sellSpec.pricetype === 'MARKET'
                    ? 'SELL @ MKT'
                    : `SELL @ ${sellSpec.price ? formatDepthPrice(sellSpec.price) : '--'}`;
            }
        }

        function updateDepthAlert(imbalance) {
            if (!elements.depthAlert) return;
            if (!Number.isFinite(imbalance)) {
                elements.depthAlert.className = 'depth-alert neutral';
                elements.depthAlert.textContent = 'Imbalance neutral';
                return;
            }
            if (imbalance >= 25) {
                elements.depthAlert.className = 'depth-alert buy';
                elements.depthAlert.textContent = `Buy pressure +${imbalance.toFixed(0)}%`;
            } else if (imbalance <= -25) {
                elements.depthAlert.className = 'depth-alert sell';
                elements.depthAlert.textContent = `Sell pressure ${imbalance.toFixed(0)}%`;
            } else {
                elements.depthAlert.className = 'depth-alert neutral';
                elements.depthAlert.textContent = `Imbalance ${imbalance >= 0 ? '+' : ''}${imbalance.toFixed(0)}%`;
            }
        }

        function updateSignalBadge(el, text, type) {
            if (!el) return;
            el.textContent = text;
            el.classList.remove('buy', 'sell');
            if (type === 'buy') el.classList.add('buy');
            if (type === 'sell') el.classList.add('sell');
        }

        let depthAudioContext = null;

        function initDepthAudio() {
            if (depthAudioContext) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return;
            try {
                depthAudioContext = new AudioCtx();
            } catch (err) {
                depthAudioContext = null;
            }
        }

        function playDepthAlertTone() {
            if (!state.depthAudioEnabled) return;
            if (!depthAudioContext) {
                initDepthAudio();
            }
            if (!depthAudioContext) return;
            if (depthAudioContext.state === 'suspended') {
                depthAudioContext.resume().catch(() => {});
            }
            const now = depthAudioContext.currentTime;
            const osc = depthAudioContext.createOscillator();
            const gain = depthAudioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
            osc.connect(gain);
            gain.connect(depthAudioContext.destination);
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function setScalpRadarEnabled(enabled) {
            state.scalpRadarEnabled = !!enabled;
            if (elements.scalpRadarToggle) {
                elements.scalpRadarToggle.textContent = state.scalpRadarEnabled ? 'Radar On' : 'Radar Off';
                elements.scalpRadarToggle.classList.toggle('active', state.scalpRadarEnabled);
            }
            if (elements.scalpRadar) {
                elements.scalpRadar.classList.toggle('off', !state.scalpRadarEnabled);
            }
            if (!state.scalpRadarEnabled) {
                if (elements.scalpRadarFill) elements.scalpRadarFill.style.width = '0%';
                if (elements.scalpRadarLabel) {
                    elements.scalpRadarLabel.textContent = 'OFF';
                    elements.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    elements.scalpRadarLabel.classList.add('cool');
                }
                if (elements.scalpRadarValue) elements.scalpRadarValue.textContent = '--';
            } else {
                updateScalpScore(state.depthLastScore || 0);
            }
        }

        function updateScalpScore(score) {
            if (!elements.scalpScore || !elements.scalpScoreLabel) return;
            const clipped = Math.max(0, Math.min(100, Math.round(score)));
            elements.scalpScore.textContent = clipped.toString();
            elements.scalpScoreLabel.classList.remove('hot', 'warm', 'cool');
            let label = 'COOL';
            let cls = 'cool';
            if (clipped >= 75) {
                label = 'HOT';
                cls = 'hot';
            } else if (clipped >= 50) {
                label = 'WARM';
                cls = 'warm';
            }
            elements.scalpScoreLabel.textContent = label;
            elements.scalpScoreLabel.classList.add(cls);

            if (state.scalpRadarEnabled) {
                if (elements.scalpRadarFill) {
                    elements.scalpRadarFill.style.width = `${clipped}%`;
                }
                if (elements.scalpRadarLabel) {
                    elements.scalpRadarLabel.textContent = label;
                    elements.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    elements.scalpRadarLabel.classList.add(cls);
                }
                if (elements.scalpRadarValue) {
                    elements.scalpRadarValue.textContent = clipped.toString();
                }
            }

            if (state.scalpRadarEnabled && clipped >= 75 && state.depthLastScore < 75) {
                const now = Date.now();
                if (state.depthAlertEnabled && now - state.depthLastAlertTs > 5000) {
                    state.depthLastAlertTs = now;
                    showToast(`Scalp Radar HOT (${clipped})`, 'success');
                }
                if (state.depthAudioEnabled && now - state.depthLastAudioTs > 5000) {
                    state.depthLastAudioTs = now;
                    playDepthAlertTone();
                }
            }
            state.depthLastScore = clipped;
        }

        function updateGreeksProxyUI(el, level) {
            if (!el) return;
            el.textContent = level;
            el.classList.remove('hot', 'warm');
            if (level === 'HIGH') el.classList.add('hot');
            if (level === 'MED') el.classList.add('warm');
        }

        function updateGreeksProxy(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.priceHistory;
            history.push({ price, ts });
            const maxSize = state.depthPriceHistorySize || 12;
            if (history.length > maxSize) history.shift();
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (state.depthLastSpeed || 0);
            state.depthLastSpeed = speed;

            const diffs = [];
            for (let i = 1; i < history.length; i++) {
                diffs.push(history[i].price - history[i - 1].price);
            }
            const mean = diffs.reduce((a, b) => a + b, 0) / diffs.length;
            const variance = diffs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / diffs.length;
            const std = Math.sqrt(variance);

            const tick = CONFIG.tickSize || 0.05;
            const accelTicks = Math.abs(accel) / tick;
            const volTicks = std / tick;

            let gammaLevel = 'LOW';
            if (accelTicks >= state.depthGammaAccelHigh) gammaLevel = 'HIGH';
            else if (accelTicks >= state.depthGammaAccelMed) gammaLevel = 'MED';

            let volLevel = 'LOW';
            if (volTicks >= state.depthVolHigh) volLevel = 'HIGH';
            else if (volTicks >= state.depthVolMed) volLevel = 'MED';

            state.depthGammaLevel = gammaLevel;
            state.depthVolLevel = volLevel;

            updateGreeksProxyUI(elements.gammaProxy, gammaLevel);
            updateGreeksProxyUI(elements.volProxy, volLevel);
        }

        function updateUnderlyingMetrics(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.underlyingHistory;
            history.push({ price, ts });
            const maxSize = state.depthUnderlyingHistorySize || 8;
            if (history.length > maxSize) history.shift();
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (state.depthUnderlyingSpeed || 0);
            state.depthUnderlyingSpeed = speed;
            state.depthUnderlyingAccel = accel;

            const base = history[0].price;
            state.depthUnderlyingMove = price - base;
        }

        function pushDepthHistory(list, value, maxLen) {
            if (!Number.isFinite(value)) return;
            list.push(value);
            if (list.length > maxLen) list.shift();
        }

        function computeMomentum(history) {
            if (!history || history.length < 2) return 0;
            return history[history.length - 1] - history[0];
        }

        function updateDepthSignals(imbalance, spread, bestBidQty, bestAskQty) {
            const windowSize = state.depthMomentumWindow || 8;
            pushDepthHistory(depthAnalytics.imbalanceHistory, imbalance, windowSize);
            pushDepthHistory(depthAnalytics.spreadHistory, spread, Math.max(windowSize, 6));
            pushDepthHistory(depthAnalytics.bidQtyHistory, bestBidQty, 2);
            pushDepthHistory(depthAnalytics.askQtyHistory, bestAskQty, 2);

            const momentum = computeMomentum(depthAnalytics.imbalanceHistory);
            state.depthImbalanceMomentum = momentum;
            if (momentum >= state.depthMomentumThreshold) {
                updateSignalBadge(elements.signalMomentum, `Momentum ↑ ${momentum.toFixed(0)}%`, 'buy');
            } else if (momentum <= -state.depthMomentumThreshold) {
                updateSignalBadge(elements.signalMomentum, `Momentum ↓ ${momentum.toFixed(0)}%`, 'sell');
            } else {
                updateSignalBadge(elements.signalMomentum, `Momentum ${momentum >= 0 ? '+' : ''}${momentum.toFixed(0)}%`, 'neutral');
            }

            let spreadSignal = 'Spread stable';
            let spreadType = 'neutral';
            const spreadDirection = Number.isFinite(imbalance) ? (imbalance >= 0 ? 'buy' : 'sell') : 'neutral';
            if (Number.isFinite(spread) && depthAnalytics.spreadHistory.length >= 4) {
                const prev = depthAnalytics.spreadHistory.slice(0, -1);
                const prevAvg = prev.reduce((a, b) => a + b, 0) / prev.length;
                if (prevAvg >= state.depthSpreadWide && spread <= state.depthSpreadTight) {
                    spreadSignal = 'Spread compress';
                    spreadType = spreadDirection;
                } else if (spread >= state.depthSpreadWide) {
                    spreadSignal = 'Spread wide';
                } else if (spread <= state.depthSpreadTight) {
                    spreadSignal = 'Spread tight';
                } else {
                    spreadSignal = `Spread ${spread.toFixed(2)}`;
                }
            }
            updateSignalBadge(elements.signalSpread, spreadSignal, spreadType);

            let liquiditySignal = 'Liquidity stable';
            let liquidityType = 'neutral';
            const prevBidQty = depthAnalytics.bidQtyHistory.length > 1 ? depthAnalytics.bidQtyHistory[0] : null;
            const prevAskQty = depthAnalytics.askQtyHistory.length > 1 ? depthAnalytics.askQtyHistory[0] : null;
            if (Number.isFinite(prevBidQty) && Number.isFinite(bestBidQty) && prevBidQty > 0) {
                const drop = ((prevBidQty - bestBidQty) / prevBidQty) * 100;
                if (drop >= state.depthLiquidityDropPct) {
                    liquiditySignal = `Bid pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'sell';
                }
            }
            if (Number.isFinite(prevAskQty) && Number.isFinite(bestAskQty) && prevAskQty > 0) {
                const drop = ((prevAskQty - bestAskQty) / prevAskQty) * 100;
                if (drop >= state.depthLiquidityDropPct) {
                    liquiditySignal = `Ask pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'buy';
                }
            }
            updateSignalBadge(elements.signalLiquidity, liquiditySignal, liquidityType);

            // Scalp score (0-100)
            const momentumScore = Math.min(30, Math.abs(momentum) / state.depthMomentumThreshold * 30);
            const imbalanceScore = Number.isFinite(imbalance) ? Math.min(20, Math.abs(imbalance) / 100 * 20) : 0;
            let spreadScore = 10;
            if (Number.isFinite(spread)) {
                if (spread <= state.depthSpreadTight) spreadScore = 20;
                else if (spread >= state.depthSpreadWide) spreadScore = 5;
                else if (spreadSignal === 'Spread compress') spreadScore = 18;
            }
            let liquidityScore = 8;
            if (liquidityType !== 'neutral') liquidityScore = 15;
            let gammaScore = 0;
            if (state.depthGammaLevel === 'HIGH') gammaScore = 10;
            else if (state.depthGammaLevel === 'MED') gammaScore = 6;
            let volScore = 0;
            if (state.depthVolLevel === 'HIGH') volScore = 10;
            else if (state.depthVolLevel === 'MED') volScore = 6;

            let gammaSqueezeScore = 0;
            let gammaSignal = 'Gamma Squeeze --';
            let gammaType = 'neutral';
            const speed = state.depthUnderlyingSpeed || 0;
            const accel = state.depthUnderlyingAccel || 0;
            const move = state.depthUnderlyingMove || 0;
            const tick = CONFIG.tickSize || 0.05;
            const speedTicks = Math.abs(speed) / tick;
            const accelTicks = Math.abs(accel) / tick;
            const squeezeActive = state.depthGammaLevel === 'HIGH'
                && state.depthVolLevel === 'HIGH'
                && Math.abs(move) >= state.depthUnderlyingMovePts
                && speedTicks >= state.depthUnderlyingSpeedHigh
                && accelTicks >= state.depthUnderlyingAccelHigh;
            if (squeezeActive) {
                const direction = speed >= 0 ? 'buy' : 'sell';
                gammaSignal = `Gamma Squeeze ${direction === 'buy' ? 'Up' : 'Down'}`;
                gammaType = direction;
                gammaSqueezeScore = 12;
            }
            state.depthGammaSqueezeActive = squeezeActive;
            updateSignalBadge(elements.signalGamma, gammaSignal, gammaType);

            const score = momentumScore + imbalanceScore + spreadScore + liquidityScore + gammaScore + volScore + gammaSqueezeScore;
            updateScalpScore(score);
        }

        function updateDepthHint() {
            if (!elements.depthHint) return;
            if (!state.depthEnabled) {
                elements.depthHint.textContent = 'Depth disabled.';
                return;
            }
            const requested = state.depthRequestedLevel || state.depthLevel || 5;
            const actual = state.depthLevel || requested;
            if (actual !== requested) {
                elements.depthHint.textContent = `Requested ${requested}L, broker delivered ${actual}L (fallback).`;
            } else {
                elements.depthHint.textContent = 'Read-only. Proxies are experimental.';
            }
        }

        function clearDepthUI() {
            setDepthText(elements.depthTopBid, '--');
            setDepthText(elements.depthTopAsk, '--');
            setDepthText(elements.depthSpread, '--');
            setDepthText(elements.depthImbalance, '--');
            updateDepthAlert(null);
            updateGreeksProxyUI(elements.gammaProxy, '--');
            updateGreeksProxyUI(elements.volProxy, '--');
            updateScalpScore(0);
            depthDomCache.rows.forEach(row => {
                row.style.display = 'grid';
                row.style.background = 'transparent';
            });
            for (let i = 0; i < depthDomCache.maxRows; i++) {
                setDepthText(depthDomCache.bidQty[i], '--');
                setDepthText(depthDomCache.bidPrice[i], '--');
                setDepthText(depthDomCache.askPrice[i], '--');
                setDepthText(depthDomCache.askQty[i], '--');
            }
            updateSignalBadge(elements.signalGamma, 'Gamma Squeeze --', 'neutral');
            clearDepthSelection();
            updateDepthQuickUI();
        }

        function syncDepthTarget() {
            const row = selectedRowEl || optionChainDomCache.rows.find(r => r.classList.contains('atm')) || optionChainDomCache.rows[0];
            if (!row) return;
            const strike = row.dataset ? row.dataset.strike : null;
            const symbol = getDepthSymbolFromRow(row);
            if (!symbol) {
                updateDepthSymbolUI(null);
                return;
            }
            state.depthStrike = strike ? parseFloat(strike) : null;
            const exchange = state.optionExchange || (state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO');
            updateDepthSymbolUI(symbol, strike);
            clearDepthSelection();
            if (!state.depthEnabled) return;
            if (state.depthSymbol === symbol && state.depthExchange === exchange) return;
            if (state.depthSymbol && state.depthExchange) {
                unsubscribeDepth(state.depthSymbol, state.depthExchange);
            }
            state.depthSymbol = symbol;
            state.depthExchange = exchange;
            subscribeDepth(symbol, exchange);
            updateDepthStatusUI();
            updateDepthBrokerUI();
            resetDepthAnalytics();
            updateDepthQuickUI();
        }

        function resetDepthAnalytics() {
            depthAnalytics.imbalanceHistory = [];
            depthAnalytics.spreadHistory = [];
            depthAnalytics.bidQtyHistory = [];
            depthAnalytics.askQtyHistory = [];
            depthAnalytics.priceHistory = [];
            depthAnalytics.underlyingHistory = [];
            state.depthLastSpeed = 0;
            state.depthGammaLevel = 'LOW';
            state.depthVolLevel = 'LOW';
            state.depthUnderlyingSpeed = 0;
            state.depthUnderlyingAccel = 0;
            state.depthUnderlyingMove = 0;
            state.depthGammaSqueezeActive = false;
            updateGreeksProxyUI(elements.gammaProxy, '--');
            updateGreeksProxyUI(elements.volProxy, '--');
            updateSignalBadge(elements.signalMomentum, 'Momentum --', 'neutral');
            updateSignalBadge(elements.signalSpread, 'Spread --', 'neutral');
            updateSignalBadge(elements.signalLiquidity, 'Liquidity --', 'neutral');
            updateSignalBadge(elements.signalGamma, 'Gamma Squeeze --', 'neutral');
            updateScalpScore(0);
        }

        function getDepthSymbolFromRow(row) {
            if (!row) return null;
            const targetType = state.depthSide.toLowerCase();
            const cell = row.querySelector(`td.price[data-type="${targetType}"]`);
            return cell ? cell.dataset.symbol : null;
        }

        function subscribeDepth(symbol, exchange) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            if (!symbol || !exchange) return;
            state.ws.send(JSON.stringify({
                action: 'subscribe',
                symbols: [{ symbol: symbol, exchange: exchange }],
                mode: 'Depth',
                depth: state.depthLevel
            }));
        }

        function unsubscribeDepth(symbol, exchange) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            if (!symbol || !exchange) return;
            state.ws.send(JSON.stringify({
                action: 'unsubscribe',
                symbols: [{ symbol: symbol, exchange: exchange }],
                mode: 'Depth'
            }));
        }

        function handleDepthUpdate(message) {
            if (!state.depthEnabled) return;
            const symbol = message.symbol;
            if (!symbol || symbol !== state.depthSymbol) return;
            const depth = message.data?.depth || message.depth || {};
            const bids = depth.buy || depth.bids || [];
            const asks = depth.sell || depth.asks || [];
            const level = message.data?.depth_level || message.depth_level || state.depthLevel;
            const timestamp = message.data?.timestamp || message.timestamp || Date.now();

            depthRenderState.pending = { bids, asks, level, timestamp };
            scheduleDepthRender();
        }

        function scheduleDepthRender() {
            if (depthRenderState.scheduled) return;
            depthRenderState.scheduled = true;
            requestAnimationFrame(() => {
                depthRenderState.scheduled = false;
                const now = performance.now();
                const elapsed = now - depthRenderState.lastRender;
                if (elapsed < CONFIG.depthRenderThrottleMs) {
                    setTimeout(scheduleDepthRender, CONFIG.depthRenderThrottleMs - elapsed);
                    return;
                }
                depthRenderState.lastRender = now;
                const payload = depthRenderState.pending;
                if (!payload) return;
                renderDepth(payload);
            });
        }

        function renderDepth(payload) {
            const bids = Array.isArray(payload.bids) ? payload.bids : [];
            const asks = Array.isArray(payload.asks) ? payload.asks : [];
            let level = Math.min(depthDomCache.maxRows, parseInt(payload.level, 10) || state.depthLevel || 5);
            state.depthLastUpdate = payload.timestamp || Date.now();
            if (Number.isFinite(level) && level > 0 && level !== state.depthLevel) {
                state.depthLevel = level;
                if (elements.depthLevelSelect) {
                    elements.depthLevelSelect.value = String(level);
                }
                updateDepthHint();
            }

            let bestBid = null;
            let bestAsk = null;
            let bestBidQty = null;
            let bestAskQty = null;
            let bidTotal = 0;
            let askTotal = 0;

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = depthDomCache.rows[i];
                if (!row) continue;
                const visible = i < level;
                if (visible) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                    continue;
                }

                const bid = parseDepthEntry(bids[i]);
                const ask = parseDepthEntry(asks[i]);

                const bidQty = bid ? formatDepthQty(bid.qty) : '--';
                const bidPrice = bid ? formatDepthPrice(bid.price) : '--';
                const askPrice = ask ? formatDepthPrice(ask.price) : '--';
                const askQty = ask ? formatDepthQty(ask.qty) : '--';

                setDepthText(depthDomCache.bidQty[i], bidQty);
                setDepthText(depthDomCache.bidPrice[i], bidPrice);
                setDepthText(depthDomCache.askPrice[i], askPrice);
                setDepthText(depthDomCache.askQty[i], askQty);
                depthDomCache.bidPrice[i].dataset.price = bid && bid.price ? String(bid.price) : '';
                depthDomCache.askPrice[i].dataset.price = ask && ask.price ? String(ask.price) : '';

                const bidQtyVal = bid && Number.isFinite(bid.qty) ? bid.qty : 0;
                const askQtyVal = ask && Number.isFinite(ask.qty) ? ask.qty : 0;
                const qtyTotal = bidQtyVal + askQtyVal;
                if (qtyTotal > 0) {
                    const bidPct = (bidQtyVal / qtyTotal) * 100;
                    row.style.background = `linear-gradient(90deg, rgba(0, 255, 136, 0.12) 0% ${bidPct}%, rgba(255, 107, 107, 0.12) ${bidPct}% 100%)`;
                } else {
                    row.style.background = 'transparent';
                }

                if (bid && Number.isFinite(bid.price) && bestBid === null) {
                    bestBid = bid.price;
                    bestBidQty = bid.qty;
                }
                if (ask && Number.isFinite(ask.price) && bestAsk === null) {
                    bestAsk = ask.price;
                    bestAskQty = ask.qty;
                }
                if (bid && Number.isFinite(bid.qty)) bidTotal += bid.qty;
                if (ask && Number.isFinite(ask.qty)) askTotal += ask.qty;
            }

            state.depthTopBidValue = bestBid;
            state.depthTopAskValue = bestAsk;

            setDepthText(elements.depthTopBid, bestBid !== null ? formatDepthPrice(bestBid) : '--');
            setDepthText(elements.depthTopAsk, bestAsk !== null ? formatDepthPrice(bestAsk) : '--');

            if (bestBid !== null && bestAsk !== null) {
                const spread = bestAsk - bestBid;
                setDepthText(elements.depthSpread, formatDepthPrice(spread));
            } else {
                setDepthText(elements.depthSpread, '--');
            }

            const total = bidTotal + askTotal;
            if (total > 0) {
                const imbalance = ((bidTotal - askTotal) / total) * 100;
                const sign = imbalance >= 0 ? '+' : '';
                setDepthText(elements.depthImbalance, `${sign}${imbalance.toFixed(0)}%`);
                updateDepthAlert(imbalance);
                updateDepthSignals(imbalance, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            } else {
                setDepthText(elements.depthImbalance, '--');
                updateDepthAlert(null);
                updateDepthSignals(null, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            }

            updateDepthStatusUI();
            updateDepthQuickUI();
        }

        function parseDepthEntry(entry) {
            if (!entry) return null;
            const price = parseFloat(
                entry.price ?? entry.rate ?? entry.prc ?? (Array.isArray(entry) ? entry[0] : undefined)
            );
            const qty = parseFloat(
                entry.quantity ?? entry.qty ?? entry.size ?? entry.volume ?? (Array.isArray(entry) ? entry[1] : undefined)
            );
            return {
                price: Number.isFinite(price) ? price : null,
                qty: Number.isFinite(qty) ? qty : null
            };
        }

        function formatDepthPrice(value) {
            if (!Number.isFinite(value)) return '--';
            return value.toFixed(2);
        }

        function formatDepthQty(value) {
            if (!Number.isFinite(value)) return '--';
            return Math.round(value).toString();
        }

        function setDepthText(element, value) {
            if (!element) return;
            if (element.textContent !== value) {
                element.textContent = value;
            }
        }

        function handleDepthRowClick(e) {
            const cell = e.target.closest('.depth-price-cell');
            if (!cell) return;
            const price = parseFloat(cell.dataset.price || cell.textContent);
            if (!Number.isFinite(price)) return;
            const index = parseInt(cell.dataset.index, 10);
            selectDepthPrice(price, Number.isFinite(index) ? index : null, cell.dataset.side || null);
        }

        function selectDepthPrice(price, rowIndex, side) {
            state.depthSelectedPrice = price;
            state.depthSelectedSide = side;
            depthDomCache.rows.forEach(row => row.classList.remove('selected'));
            if (Number.isFinite(rowIndex) && depthDomCache.rows[rowIndex]) {
                depthDomCache.rows[rowIndex].classList.add('selected');
                depthDomCache.rows[rowIndex].style.boxShadow = 'inset 0 0 0 1px rgba(0, 212, 255, 0.6)';
            }
            updateDepthQuickUI();
        }

        function clearDepthSelection() {
            state.depthSelectedPrice = null;
            state.depthSelectedSide = null;
            depthDomCache.rows.forEach(row => {
                row.classList.remove('selected');
                row.style.boxShadow = '';
            });
        }

        function isMomentumFavorable(action) {
            const m = state.depthImbalanceMomentum;
            if (!Number.isFinite(m)) return false;
            if (action === 'BUY') return m >= state.depthMomentumThreshold;
            return m <= -state.depthMomentumThreshold;
        }

        function getDepthOrderSpec(action, modeOverride) {
            if (Number.isFinite(state.depthSelectedPrice)) {
                return { pricetype: 'LIMIT', price: state.depthSelectedPrice };
            }

            let mode = modeOverride || state.depthOrderMode;
            if (mode === 'TAKE' && state.depthLimitOnly) {
                mode = 'JOIN';
            }
            const bestBid = state.depthTopBidValue;
            const bestAsk = state.depthTopAskValue;
            const spread = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? bestAsk - bestBid : null;

            if (mode === 'TAKE') {
                if (Number.isFinite(spread) && spread <= state.depthTakeMaxSpread && isMomentumFavorable(action)) {
                    return { pricetype: 'MARKET', price: null };
                }
            }

            if (mode === 'STEP') {
                if (Number.isFinite(bestBid) && Number.isFinite(bestAsk)) {
                    const tick = CONFIG.tickSize || 0.05;
                    if (action === 'BUY') {
                        let price = roundToTick(bestBid + (tick * state.depthStepInTicks), tick);
                        if (price >= bestAsk) price = bestAsk;
                        return { pricetype: 'LIMIT', price };
                    }
                    let price = roundToTick(bestAsk - (tick * state.depthStepInTicks), tick);
                    if (price <= bestBid) price = bestBid;
                    return { pricetype: 'LIMIT', price };
                }
            }

            // JOIN fallback
            if (action === 'BUY') {
                return { pricetype: 'LIMIT', price: bestAsk };
            }
            return { pricetype: 'LIMIT', price: bestBid };
        }

        async function placeDepthOrder(action, options = {}) {
            if (!enforceRiskGate('Depth order')) {
                return;
            }
            if (!state.depthSymbol || !state.depthStrike) {
                showToast('Select a strike for depth orders', 'error');
                return;
            }
            if (!state.apiKey) {
                showToast('Enter your API key first', 'error');
                return;
            }
            const mode = options.modeOverride || state.depthOrderMode;
            let spec = getDepthOrderSpec(action, mode);
            if (options.reprice && spec.pricetype === 'MARKET') {
                spec = getDepthOrderSpec(action, 'JOIN');
            }
            if (spec.pricetype === 'LIMIT' && (!Number.isFinite(spec.price) || spec.price <= 0)) {
                showToast('Depth price not available', 'error');
                return;
            }

            try {
                const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';
                const chainItem = state.optionChainData.find(x => x.strike === Number(state.depthStrike));
                const lotsize = state.depthSide === 'CE'
                    ? (chainItem?.ce?.lotsize || 15)
                    : (chainItem?.pe?.lotsize || 15);

                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'scalping',
                    symbol: state.depthSymbol,
                    action: action,
                    exchange: exchange,
                    pricetype: spec.pricetype,
                    product: 'MIS',
                    quantity: String(state.quantity * lotsize),
                    price: spec.pricetype === 'LIMIT' ? spec.price.toFixed(2) : '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const result = await apiCall('/api/v1/placeorder', orderData);

                if (result.status === 'success') {
                    const priceLabel = spec.pricetype === 'MARKET' ? 'MKT' : `₹${spec.price.toFixed(2)}`;
                    logToConsole(`✅ Depth ${action} ${state.depthSide} @ ${priceLabel}`, 'success');
                    showToast(`✓ Depth ${action} @ ${priceLabel} placed!`, 'success');

                    if (!options.disableAutoTPSL && state.autoTPEnabled && !state.virtualTPSL.has(state.depthSymbol)) {
                        const totalQty = state.quantity * lotsize;
                        if (spec.pricetype === 'LIMIT') {
                            placeAutoTPSL(state.depthSymbol, spec.price, action === 'BUY' ? totalQty : -totalQty, action);
                        }
                    }

                    const orderId = result.orderid || result.order_id;
                    if (spec.pricetype === 'LIMIT' && state.depthRepriceEnabled && !options.disableReprice && !Number.isFinite(state.depthSelectedPrice)) {
                        const retriesLeft = Number.isFinite(options.retriesLeft) ? options.retriesLeft : state.depthRepriceMaxRetries;
                        if (orderId) {
                            scheduleDepthReprice(orderId, action, mode, retriesLeft);
                        }
                    }

                    setTimeout(() => loadPositions(), 1000);
                } else {
                    logToConsole(`❌ Depth order failed: ${result.message}`, 'error');
                    showToast(`Order failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error placing depth order:', error);
                logToConsole(`❌ Error placing depth order: ${error.message}`, 'error');
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        async function isOrderOpen(orderId) {
            try {
                const result = await apiCall('/api/v1/orderbook', { apikey: state.apiKey });
                if (result.status !== 'success' || !result.data || !result.data.orders) {
                    return false;
                }
                const order = result.data.orders.find(o => String(o.orderid) === String(orderId));
                if (!order) return false;
                const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();
                return status === 'OPEN' ||
                    status === 'PENDING' ||
                    status === 'TRIGGER PENDING' ||
                    status === 'PENDING ORDER' ||
                    status === 'NOT EXECUTED';
            } catch (error) {
                console.error('Error checking order status:', error);
                return false;
            }
        }

        async function cancelDepthOrder(orderId) {
            try {
                const res = await apiCall('/api/v1/cancelorder', {
                    apikey: state.apiKey,
                    strategy: 'scalping',
                    orderid: String(orderId)
                });
                return res.status === 'success';
            } catch (error) {
                console.error('Error cancelling order:', error);
                return false;
            }
        }

        function scheduleDepthReprice(orderId, action, mode, retriesLeft) {
            if (!state.depthRepriceEnabled || !state.depthEnabled) return;
            if (!Number.isFinite(retriesLeft) || retriesLeft <= 0) return;

            setTimeout(async () => {
                if (!state.depthRepriceEnabled || !state.depthEnabled) return;
                const stillOpen = await isOrderOpen(orderId);
                if (!stillOpen) return;

                const cancelled = await cancelDepthOrder(orderId);
                if (!cancelled) return;

                placeDepthOrder(action, {
                    reprice: true,
                    modeOverride: mode,
                    retriesLeft: retriesLeft - 1,
                    disableAutoTPSL: true
                });
            }, Math.max(100, state.depthRepriceMs));
        }

        // Session P&L Management
        function getTodayKey() {
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            return `session_pnl_${today}`;
        }

        function loadSessionPnL() {
            const key = getTodayKey();
            const saved = localStorage.getItem(key);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        state.sessionClosedPnL = parsed;
                    } else if (parsed && typeof parsed === 'object') {
                        state.sessionClosedPnL = Object.entries(parsed).map(([symbol, pnl]) => ({
                            symbol,
                            pnl: parseFloat(pnl) || 0,
                            timestamp: null,
                            qty: null,
                            entryPrice: null,
                            exitPrice: null,
                            source: 'legacy'
                        }));
                    } else {
                        state.sessionClosedPnL = [];
                    }
                    console.log('Loaded session P&L:', state.sessionClosedPnL);
                } catch (e) {
                    console.error('Error loading session P&L:', e);
                    state.sessionClosedPnL = [];
                }
            } else {
                state.sessionClosedPnL = [];
            }
        }

        function saveSessionPnL() {
            const key = getTodayKey();
            localStorage.setItem(key, JSON.stringify(state.sessionClosedPnL));
            console.log('Saved session P&L:', state.sessionClosedPnL);
        }

        // Initialization
        function init() {
            // Load broker profiles
            loadBrokerProfiles();

            // Load today's session P&L
            loadSessionPnL();

            // If profiles exist, select the first one
            if (state.brokerProfiles.length > 0) {
                document.getElementById('brokerProfile').value = 0;
                handleProfileChange();
            } else {
                // No profiles - check for legacy API key
                const savedKey = localStorage.getItem('openalgo_api_key');
                if (savedKey) {
                    elements.apiKeyInput.value = savedKey;
                    state.apiKey = savedKey;
                    // Load positions if API key exists
                    loadPositions();
                }
            }

            // Event listeners
            document.getElementById('brokerProfile').addEventListener('change', handleProfileChange);

            // Allow manual API key input (updates state when typing)
            elements.apiKeyInput.addEventListener('input', (e) => {
                state.apiKey = e.target.value;
                localStorage.setItem('openalgo_api_key', e.target.value);
            });

            elements.connectBtn.addEventListener('click', handleConnect);
            elements.indexSelect.addEventListener('change', handleIndexChange);
            elements.expirySelect.addEventListener('change', handleExpiryChange);
            if (elements.indexChartBtn) {
                elements.indexChartBtn.addEventListener('click', openIndexChart);
            }
            elements.qtyMinus.addEventListener('click', () => adjustQuantity(-1));
            elements.qtyPlus.addEventListener('click', () => adjustQuantity(1));
            elements.orderTypeToggle.addEventListener('click', toggleOrderType);
            elements.hotkeyToggle.addEventListener('click', toggleHotkeys);
            elements.closeAllPositions.addEventListener('click', closeAllPositions);
            if (elements.scalpRadarToggle) {
                elements.scalpRadarToggle.addEventListener('click', () => {
                    setScalpRadarEnabled(!state.scalpRadarEnabled);
                });
            }

            // P&L Management event listeners
            document.getElementById('stopLoss').addEventListener('input', updatePnlMonitoring);
            document.getElementById('targetProfit').addEventListener('input', updatePnlMonitoring);
            document.getElementById('enableTrailing').addEventListener('change', function (e) {
                state.trailingEnabled = e.target.checked;
                document.getElementById('trailPoints').disabled = !e.target.checked;
                if (e.target.checked) {
                    const basePnl = Number.isFinite(state.openPnl) ? state.openPnl : state.totalPnl;
                    state.highestPnl = basePnl || 0;  // Initialize trailing from current open P&L
                }
                updatePnlMonitoring();
            });
            document.getElementById('trailPoints').addEventListener('input', updatePnlMonitoring);

            // Hotkey listener
            document.addEventListener('keydown', handleHotkey);

            // Depth scout UI
            initDepthPanel();
            setScalpRadarEnabled(false);
            initTooltipHints();

            console.log('Scalping interface initialized');
            logToConsole('⚡ Scalping interface initialized', 'success');
            logToConsole('Enter your API key and click Connect to start', 'info');
        }

        // Event Handlers
        function handleIndexChange() {
            state.selectedIndex = elements.indexSelect.value;
            logToConsole(`Index changed to ${state.selectedIndex}`, 'info');

            // Reload expiries for the new index
            if (state.connected) {
                loadExpiries();
            }
        }

        function handleExpiryChange() {
            state.selectedExpiry = elements.expirySelect.value;
            logToConsole(`Expiry changed to ${state.selectedExpiry}`, 'info');
            loadOptionChain();
        }

        // Chart Window Functions
        function openChartSplit(ceSymbol, peSymbol, strike) {
            const width = 1400;
            const height = 900;
            const left = (screen.width - width) / 2;
            const top = (screen.height - height) / 2;

            const optionData = state.optionChainData?.find(x => x.strike === strike);
            const lotSize = optionData?.ce?.lotsize || optionData?.pe?.lotsize || 65;

            const initialSide = state.chartSidePreference || state.depthSide || 'CE';
            const safeCe = ceSymbol || optionData?.ce?.symbol || '';
            const safePe = peSymbol || optionData?.pe?.symbol || '';
            const initialSymbol = initialSide === 'PE' ? safePe : safeCe;

            if (!initialSymbol) {
                showToast('Chart symbol unavailable for this strike', 'error');
                return;
            }

            const params = new URLSearchParams({
                symbol: initialSymbol,
                ceSymbol: safeCe,
                peSymbol: safePe,
                initialSide: initialSide,
                underlying: state.selectedIndex,
                exchange: state.selectedIndex === 'SENSEX' ? 'BSE_INDEX' : 'NSE_INDEX',
                optionType: initialSide,
                strike: strike,
                expiry: state.selectedExpiry,
                lotSize: lotSize
            });

            const chartWindow = window.open(
                `/chart_window.html?${params.toString()}`,
                `chart_${safeCe || safePe}`,
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no`
            );

            if (chartWindow) {
                logToConsole(`Opened split chart for strike ${strike}`, 'info');
            } else {
                showToast('Please allow popups for chart windows', 'error');
            }
        }

        function openIndexChart() {
            const width = 1200;
            const height = 800;
            const left = (screen.width - width) / 2;
            const top = (screen.height - height) / 2;

            const indexSymbol = state.selectedIndex || 'NIFTY';
            const exchange = indexSymbol === 'SENSEX' ? 'BSE_INDEX' : 'NSE_INDEX';
            const params = new URLSearchParams({
                symbol: indexSymbol,
                underlying: indexSymbol,
                exchange: exchange,
                indexOnly: '1'
            });

            const chartWindow = window.open(
                `/chart_window.html?${params.toString()}`,
                `index_${indexSymbol}`,
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no`
            );

            if (!chartWindow) {
                showToast('Please allow popups for chart windows', 'error');
            }
        }

        // Auto Trading Window (split)
        function openAutoTradeSplit(ceSymbol, peSymbol, strike) {
            const width = 1400;
            const height = 900;
            const left = (screen.width - width) / 2;
            const top = (screen.height - height) / 2;

            const optionData = state.optionChainData?.find(x => x.strike === strike);
            const lotSize = optionData?.ce?.lotsize || optionData?.pe?.lotsize || 65;

            const initialSide = state.chartSidePreference || state.depthSide || 'CE';
            const safeCe = ceSymbol || optionData?.ce?.symbol || '';
            const safePe = peSymbol || optionData?.pe?.symbol || '';
            const initialSymbol = initialSide === 'PE' ? safePe : safeCe;

            if (!initialSymbol) {
                showToast('Auto trade symbol unavailable for this strike', 'error');
                return;
            }

            const params = new URLSearchParams({
                symbol: initialSymbol,
                ceSymbol: safeCe,
                peSymbol: safePe,
                initialSide: initialSide,
                underlying: state.selectedIndex,
                exchange: state.selectedIndex === 'SENSEX' ? 'BSE_INDEX' : 'NSE_INDEX',
                optionType: initialSide,
                strike: strike,
                expiry: state.selectedExpiry,
                lotSize: lotSize
            });

            const autoWindow = window.open(
                `/auto_trading_window.html?${params.toString()}`,
                `auto_${safeCe || safePe}`,
                `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=no,status=no`
            );

            if (autoWindow) {
                logToConsole(`Opened auto trade window for strike ${strike}`, 'info');
            } else {
                showToast('Please allow popups for auto trade windows', 'error');
            }
        }

        // Backward-compatible single chart call
        function openChart(symbol, optionType, strike) {
            const optionData = state.optionChainData?.find(x => x.strike === strike);
            const ceSymbol = optionType === 'CE' ? symbol : optionData?.ce?.symbol;
            const peSymbol = optionType === 'PE' ? symbol : optionData?.pe?.symbol;
            state.chartSidePreference = optionType?.toUpperCase() || state.chartSidePreference;
            openChartSplit(ceSymbol, peSymbol, strike);
        }

        // WebSocket Functions
        function connectWebSocket() {
            if (state.ws) {
                state.ws.close();
            }

            logToConsole('🔌 Connecting to WebSocket...', 'info');
            showToast('Connecting to WebSocket...', 'info');
            state.ws = new WebSocket(CONFIG.wsUrl);

            state.ws.onopen = () => {
                console.log('WebSocket connected');
                logToConsole('✅ WebSocket connected', 'success');
                authenticate();
            };

            state.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // Don't log every WebSocket message - too noisy
                handleWebSocketMessage(data);
            };

            state.ws.onclose = () => {
                console.log('WebSocket disconnected');
                logToConsole('❌ WebSocket disconnected', 'error');
                updateConnectionStatus(false);
                showToast('WebSocket disconnected', 'error');
            };

            state.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                logToConsole('❌ WebSocket connection error', 'error');
                showToast('WebSocket connection error', 'error');
            };
        }

        function authenticate() {
            const authMsg = {
                action: 'authenticate',
                api_key: state.apiKey
            };
            logToConsole(`🔐 Sending authentication...`, 'info');
            state.ws.send(JSON.stringify(authMsg));
        }

        function subscribeToOptions(symbols) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
                logToConsole('⚠️ Cannot subscribe: WebSocket not ready', 'warn');
                return;
            }

            logToConsole(`📡 Subscribing to ${symbols.length} symbols...`, 'info');
            state.ws.send(JSON.stringify({
                action: 'subscribe',
                symbols: symbols,
                mode: 'LTP'
            }));
        }

        function handleWebSocketMessage(data) {
            if (!CONFIG.performanceMode.disableConsoleLog) {
                console.log('WebSocket message received:', data);
            }

            // Handle authentication response (server sends: type='auth', status='success')
            if (data.type === 'auth' && data.status === 'success') {
                if (!CONFIG.performanceMode.disableConsoleLog) {
                    console.log('Authenticated successfully');
                }
                logToConsole(`✅ Authenticated as ${data.user_id} (${data.broker})`, 'success');
                state.currentBroker = data.broker || state.currentBroker;
                updateDepthBrokerUI();
                updateConnectionStatus(true);
                showToast('Connected successfully!', 'success');
                loadExpiries();
                loadPositions(); // Load existing positions on connect
                syncDepthTarget();
            }
            // Also support legacy format if present
            else if (data.status === 'authenticated') {
                if (!CONFIG.performanceMode.disableConsoleLog) {
                    console.log('Authenticated successfully (legacy)');
                }
                logToConsole('✅ Authenticated successfully', 'success');
                if (data.broker) {
                    state.currentBroker = data.broker;
                    updateDepthBrokerUI();
                }
                updateConnectionStatus(true);
                showToast('Connected successfully!', 'success');
                loadExpiries();
                loadPositions(); // Load existing positions on connect
                syncDepthTarget();
            }
            // Handle market data updates
            else if (data.type === 'market_data') {
                if (data.mode === 3 || data.data?.depth) {
                    handleDepthUpdate(data);
                }
                if (data.data?.ltp != null || data.ltp != null) {
                    updatePrice(data);
                }
            }
            // Handle subscribe response (depth level fallback)
            else if (data.type === 'subscribe' && Array.isArray(data.subscriptions)) {
                const depthSub = data.subscriptions.find(sub =>
                    (sub.mode === 'Depth' || sub.mode === 3) &&
                    sub.symbol === state.depthSymbol
                );
                if (depthSub && depthSub.depth) {
                    state.depthLevel = parseInt(depthSub.depth, 10) || state.depthLevel;
                    if (elements.depthLevelSelect) {
                        elements.depthLevelSelect.value = String(state.depthLevel);
                    }
                    updateDepthHint();
                }
                if (!CONFIG.performanceMode.disableConsoleLog) {
                    console.log('Subscribed to symbols:', data.subscriptions.length);
                }
            }
            // Handle subscription confirmation
            else if (data.status === 'subscribed') {
                if (!CONFIG.performanceMode.disableConsoleLog) {
                    console.log('Subscribed to symbols:', data.count);
                }
                logToConsole(`✅ Subscribed to ${data.count} symbols`, 'success');
            }
            // Handle errors
            else if (data.status === 'error') {
                console.error('Server error:', data.message);
                logToConsole(`❌ Server error: ${data.message}`, 'error');
                showToast(`Error: ${data.message}`, 'error');
            }
        }

        function updateConnectionStatus(connected) {
            state.connected = connected;
            elements.wsStatus.className = `status-indicator ${connected ? 'connected' : 'disconnected'}`;
            elements.wsStatus.querySelector('span:last-child').textContent = connected ? 'Connected' : 'Disconnected';
            updateDepthStatusUI();
        }

        // ========== PHASE 3: CONNECTION HEALTH MONITOR ==========
        
        const connectionHealth = {
            wsConnected: false,
            wsLatency: 0,
            apiLatency: 0,
            lastApiResponse: 0,
            lastWsMessage: 0,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5
        };
        
        function updateConnectionHealth(type, latency) {
            if (type === 'ws') {
                connectionHealth.wsLatency = latency;
                connectionHealth.lastWsMessage = Date.now();
            } else if (type === 'api') {
                connectionHealth.apiLatency = latency;
                connectionHealth.lastApiResponse = Date.now();
            }
            updateConnectionStatusUI();
        }
        
        function updateConnectionStatusUI() {
            const wsStatus = document.getElementById('wsStatus');
            if (!wsStatus) return;
            
            const wsLatencyText = connectionHealth.wsLatency > 0 ? ` (${connectionHealth.wsLatency}ms)` : '';
            const wsStatusText = connectionHealth.wsConnected ? `Connected${wsLatencyText}` : 'Disconnected';
            
            wsStatus.querySelector('span:last-child').textContent = wsStatusText;
            
            // Color code based on latency
            if (connectionHealth.wsConnected) {
                if (connectionHealth.wsLatency < 100) {
                    wsStatus.style.color = 'var(--success)';
                } else if (connectionHealth.wsLatency < 300) {
                    wsStatus.style.color = 'var(--warning)';
                } else {
                    wsStatus.style.color = 'var(--danger)';
                }
            } else {
                wsStatus.style.color = 'var(--danger)';
            }
        }
        
        // ========== PHASE 3: ORDER RETRY MECHANISM ==========
        
        async function apiCallWithRetry(endpoint, data, maxRetries = 3) {
            let lastError;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                const startTime = Date.now();
                
                try {
                    const response = await fetch(`${CONFIG.apiUrl}${endpoint}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ ...data, apikey: state.apiKey })
                    });
                    
                    const latency = Date.now() - startTime;
                    updateConnectionHealth('api', latency);
                    
                    const result = await response.json();
                    
                    // If successful or a business logic error (not network), return
                    if (result.status === 'success' || response.ok) {
                        return result;
                    }
                    
                    // If it's a retryable error, continue
                    lastError = new Error(result.message || 'API error');
                    
                } catch (error) {
                    lastError = error;
                    console.error(`API call attempt ${attempt}/${maxRetries} failed:`, error);
                    
                    if (attempt < maxRetries) {
                        // Exponential backoff: 100ms, 200ms, 400ms
                        const delay = 100 * Math.pow(2, attempt - 1);
                        logToConsole(`⚠️ Retrying in ${delay}ms... (Attempt ${attempt + 1}/${maxRetries})`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            // All retries failed
            logToConsole(`❌ API call failed after ${maxRetries} attempts`, 'error');
            throw lastError;
        }
        
        // Original API call (for backward compatibility)
        async function apiCall(endpoint, data) {
            return apiCallWithRetry(endpoint, data, 1);
        }
        
        // ========== PHASE 3: PRICE STALENESS DETECTION ==========
        
        const priceTimestamps = new Map(); // symbol -> lastUpdateTime
        
        function updatePriceTimestamp(symbol) {
            priceTimestamps.set(symbol, Date.now());
        }
        
        function getPriceStaleness(symbol) {
            const lastUpdate = priceTimestamps.get(symbol);
            if (!lastUpdate) return 'unknown';
            
            const staleness = Date.now() - lastUpdate;
            if (staleness > 10000) return 'stale';      // > 10 seconds
            if (staleness > 5000) return 'delayed';     // > 5 seconds
            return 'live';
        }
        
        function isPriceStale(symbol) {
            return getPriceStaleness(symbol) === 'stale';
        }
        
        function showStalePriceWarning(symbol, callback) {
            const staleness = getPriceStaleness(symbol);
            if (staleness === 'stale') {
                const lastUpdate = priceTimestamps.get(symbol);
                const secondsAgo = Math.round((Date.now() - lastUpdate) / 1000);
                
                if (confirm(`⚠️ Price data is ${secondsAgo}s old. Continue with order?`)) {
                    callback();
                }
            } else {
                callback();
            }
        }
        
        // Update price staleness indicator in UI
        function updatePriceStalenessUI() {
            const cells = optionChainDomCache.priceCells.length
                ? optionChainDomCache.priceCells
                : document.querySelectorAll('td.price');
            for (const cell of cells) {
                const symbol = cell.dataset.symbol;
                if (!symbol) continue;
                
                const staleness = getPriceStaleness(symbol);
                cell.classList.remove('price-live', 'price-delayed', 'price-stale');
                cell.classList.add(`price-${staleness}`);
            }
        }
        
        // Check staleness every second
        setInterval(updatePriceStalenessUI, 1000);

        // ========== PHASE 4: POSITION RECONCILIATION ==========
        
        const localPositions = new Map(); // symbol -> { qty, avgPrice, lastSync }
        let lastReconciliation = 0;
        
        async function reconcilePositions() {
            try {
                const result = await apiCall('/api/v1/positionbook', {});
                
                if (result.status !== 'success' || !result.data) {
                    return;
                }
                
                const brokerPositions = new Map();
                result.data.forEach(pos => {
                    const qty = parseInt(pos.quantity) || 0;
                    if (qty !== 0) {
                        brokerPositions.set(pos.symbol, {
                            qty: qty,
                            avgPrice: parseFloat(pos.averageprice) || 0,
                            pnl: parseFloat(pos.pnl) || 0
                        });
                    }
                });
                
                // Find discrepancies
                const discrepancies = [];
                
                // Check local positions against broker
                localPositions.forEach((localPos, symbol) => {
                    const brokerPos = brokerPositions.get(symbol);
                    if (!brokerPos) {
                        discrepancies.push({
                            symbol,
                            type: 'missing_at_broker',
                            local: localPos.qty,
                            broker: 0
                        });
                    } else if (localPos.qty !== brokerPos.qty) {
                        discrepancies.push({
                            symbol,
                            type: 'qty_mismatch',
                            local: localPos.qty,
                            broker: brokerPos.qty
                        });
                    }
                });
                
                // Check broker positions not in local
                brokerPositions.forEach((brokerPos, symbol) => {
                    if (!localPositions.has(symbol)) {
                        discrepancies.push({
                            symbol,
                            type: 'missing_locally',
                            local: 0,
                            broker: brokerPos.qty
                        });
                    }
                });
                
                // Handle discrepancies
                if (discrepancies.length > 0) {
                    logToConsole(`⚠️ Position discrepancy detected: ${discrepancies.length} issues`, 'warning');
                    
                    discrepancies.forEach(d => {
                        logToConsole(`  ${d.symbol}: Local=${d.local}, Broker=${d.broker} (${d.type})`, 'warning');
                    });
                    
                    // Auto-sync to broker state
                    brokerPositions.forEach((pos, symbol) => {
                        localPositions.set(symbol, {
                            qty: pos.qty,
                            avgPrice: pos.avgPrice,
                            lastSync: Date.now()
                        });
                    });
                    
                    // Remove positions that don't exist at broker
                    localPositions.forEach((_, symbol) => {
                        if (!brokerPositions.has(symbol)) {
                            localPositions.delete(symbol);
                        }
                    });
                    
                    showToast('Positions synced with broker', 'info');
                }
                
                lastReconciliation = Date.now();
                
            } catch (error) {
                logToConsole(`❌ Reconciliation failed: ${error.message}`, 'error');
            }
        }
        
        // Run reconciliation every 30 seconds
        setInterval(reconcilePositions, 30000);

        // Refresh position prices every 30 seconds via multiquotes API fallback
        setInterval(async () => {
            await fetchPositionPrices();
            renderPositions();
        }, 30000);

        // ========== PHASE 4: ORDER VALIDATION ==========
        
        const ORDER_LIMITS = {
            maxQuantity: 50,           // Max lots per order
            maxDailyLoss: 10000,       // Max daily loss in rupees
            maxOrderValue: 500000,     // Max order value in rupees
            priceDeviationLimit: 0.5,  // Max 50% deviation from current price
            minPrice: 0.5,             // Minimum option price
            maxPrice: 50000            // Maximum option price
        };
        
        let dailyPnL = 0;
        
        function validateOrder(orderData, currentPrice) {
            const errors = [];
            const warnings = [];
            
            // 1. Quantity validation
            const lots = parseInt(orderData.quantity) / (orderData.lotsize || 15);
            if (lots > ORDER_LIMITS.maxQuantity) {
                errors.push(`Quantity ${lots} lots exceeds max ${ORDER_LIMITS.maxQuantity} lots`);
            }
            
            // 2. Price validation for limit orders
            if (orderData.pricetype === 'LIMIT') {
                const price = parseFloat(orderData.price);
                
                if (price < ORDER_LIMITS.minPrice) {
                    errors.push(`Price ₹${price} below minimum ₹${ORDER_LIMITS.minPrice}`);
                }
                
                if (price > ORDER_LIMITS.maxPrice) {
                    errors.push(`Price ₹${price} exceeds maximum ₹${ORDER_LIMITS.maxPrice}`);
                }
                
                // Check deviation from current price
                if (currentPrice > 0) {
                    const deviation = Math.abs(price - currentPrice) / currentPrice;
                    if (deviation > ORDER_LIMITS.priceDeviationLimit) {
                        warnings.push(`Price ₹${price} is ${(deviation * 100).toFixed(0)}% away from current ₹${currentPrice}`);
                    }
                }
            }
            
            // 3. Daily loss limit check
            const dailyPnl = Number.isFinite(state.totalPnl) ? state.totalPnl : dailyPnL;
            if (dailyPnl < -ORDER_LIMITS.maxDailyLoss) {
                errors.push(`Daily loss limit (₹${ORDER_LIMITS.maxDailyLoss}) exceeded`);
            }
            
            // 4. Stale price check
            const symbol = orderData.symbol;
            if (isPriceStale(symbol)) {
                warnings.push('Price data is stale (>10s old)');
            }
            
            return { errors, warnings, isValid: errors.length === 0 };
        }
        
        function showOrderValidationDialog(validation, onConfirm, onCancel) {
            if (validation.errors.length > 0) {
                const errorMsg = '❌ Order Validation Failed:\n\n' + validation.errors.join('\n');
                showToast(errorMsg, 'error');
                logToConsole(errorMsg, 'error');
                if (onCancel) onCancel();
                return;
            }
            
            if (validation.warnings.length > 0) {
                const warningMsg = '⚠️ Warnings:\n' + validation.warnings.join('\n') + '\n\nProceed anyway?';
                if (confirm(warningMsg)) {
                    onConfirm();
                } else {
                    if (onCancel) onCancel();
                }
            } else {
                onConfirm();
            }
        }
        
        // ========== PHASE 4: AUDIT TRAIL ==========
        
        const auditTrail = [];
        const MAX_AUDIT_ENTRIES = 500;

        const manualLogQueue = [];
        const manualLogIds = new Set();
        const MAX_MANUAL_LOG_QUEUE = 400;
        const MANUAL_LOG_FLUSH_MS = 1200;
        let manualLogFlushTimer = null;

        function generateManualEventId() {
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return window.crypto.randomUUID();
            }
            return `manual_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        }

        function queueManualTradeLog(entry) {
            if (!entry) return;
            manualLogQueue.push(entry);
            if (manualLogQueue.length > MAX_MANUAL_LOG_QUEUE) {
                manualLogQueue.shift();
            }
            if (!manualLogFlushTimer) {
                manualLogFlushTimer = setTimeout(flushManualTradeLogs, MANUAL_LOG_FLUSH_MS);
            }
        }

        function flushManualTradeLogs() {
            manualLogFlushTimer = null;
            if (!manualLogQueue.length) return;
            const batch = manualLogQueue.splice(0, 60);
            const payload = JSON.stringify({ events: batch });
            try {
                if (navigator.sendBeacon) {
                    const ok = navigator.sendBeacon('/manual_trades/logs', new Blob([payload], { type: 'application/json' }));
                    if (!ok) {
                        throw new Error('Beacon failed');
                    }
                } else {
                    fetch('/manual_trades/logs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: payload,
                        keepalive: true
                    }).catch(() => {});
                }
            } catch (e) {
                manualLogQueue.unshift(...batch);
                if (manualLogQueue.length > MAX_MANUAL_LOG_QUEUE) {
                    manualLogQueue.length = MAX_MANUAL_LOG_QUEUE;
                }
            }
            if (manualLogQueue.length) {
                manualLogFlushTimer = setTimeout(flushManualTradeLogs, MANUAL_LOG_FLUSH_MS);
            }
        }

        function logManualTrade(event) {
            if (!event) return;
            const entry = {
                ts: new Date().toISOString(),
                ...event
            };
            if (!entry.eventId) entry.eventId = generateManualEventId();
            if (manualLogIds.has(entry.eventId)) return;
            manualLogIds.add(entry.eventId);
            if (!entry.source) entry.source = 'scalping';
            if (!entry.mode) entry.mode = 'LIVE';
            if (!entry.underlying && state.selectedIndex) entry.underlying = state.selectedIndex;
            if (!entry.exchange) {
                entry.exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';
            }
            queueManualTradeLog(entry);
        }
        
        function logAuditEntry(action, details) {
            const entry = {
                timestamp: new Date().toISOString(),
                action: action,
                details: details,
                sessionId: state.sessionId || 'unknown'
            };
            
            auditTrail.push(entry);
            
            // Keep only last N entries
            if (auditTrail.length > MAX_AUDIT_ENTRIES) {
                auditTrail.shift();
            }
            
            // Persist to localStorage
            try {
                localStorage.setItem('scalping_audit_trail', JSON.stringify(auditTrail.slice(-100)));
            } catch (e) {
                // Storage full, clear old entries
                localStorage.removeItem('scalping_audit_trail');
            }
            
            return entry;
        }
        
        function logOrderPlaced(orderData, result) {
            return logAuditEntry('ORDER_PLACED', {
                symbol: orderData.symbol,
                action: orderData.action,
                quantity: orderData.quantity,
                pricetype: orderData.pricetype,
                price: orderData.price,
                orderId: result.orderid,
                status: result.status,
                message: result.message
            });
        }
        
        function logOrderCancelled(orderId, reason) {
            return logAuditEntry('ORDER_CANCELLED', {
                orderId: orderId,
                reason: reason
            });
        }
        
        function logPositionClosed(symbol, qty, pnl, reason) {
            return logAuditEntry('POSITION_CLOSED', {
                symbol: symbol,
                quantity: qty,
                pnl: pnl,
                reason: reason
            });
        }
        
        function logProfitProtectionTriggered(symbol, level, securedProfit) {
            return logAuditEntry('PROFIT_PROTECTION', {
                symbol: symbol,
                level: level,
                securedProfit: securedProfit
            });
        }
        
        function exportAuditTrail() {
            const data = JSON.stringify(auditTrail, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `scalping_audit_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('Audit trail exported', 'success');
        }
        
        function exportAuditTrailCSV() {
            const headers = ['Timestamp', 'Action', 'Symbol', 'Quantity', 'Price', 'P&L', 'Status', 'Details'];
            const rows = auditTrail.map(entry => {
                const d = entry.details || {};
                return [
                    entry.timestamp,
                    entry.action,
                    d.symbol || '',
                    d.quantity || '',
                    d.price || '',
                    d.pnl || '',
                    d.status || '',
                    JSON.stringify(d)
                ].join(',');
            });
            
            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `scalping_audit_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            
            URL.revokeObjectURL(url);
            showToast('Audit trail exported as CSV', 'success');
        }
        
        // Load audit trail from localStorage on startup
        function loadAuditTrail() {
            try {
                const saved = localStorage.getItem('scalping_audit_trail');
                if (saved) {
                    const entries = JSON.parse(saved);
                    auditTrail.push(...entries);
                }
            } catch (e) {
                console.error('Failed to load audit trail:', e);
            }
        }
        
        // Initialize audit trail
        loadAuditTrail();

        // ========== PART 8.2: NEW API ENDPOINT WRAPPERS ==========
        
        // Ladder Order API - Places multiple limit orders at different prices
        async function placeLadderOrderAPI(symbol, levels, options = {}) {
            if (!enforceRiskGate('Ladder order')) {
                return { status: 'blocked', results: [] };
            }
            const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';
            const results = [];
            const ladderGroupId = Date.now();
            
            // Store ladder order group
            tradingState.ladderOrders.set(ladderGroupId, {
                symbol,
                levels: levels.map(l => ({ ...l, status: 'pending', orderId: null })),
                status: 'placing',
                totalFilled: 0,
                options
            });
            
            for (let i = 0; i < levels.length; i++) {
                const level = levels[i];
                try {
                    const orderData = {
                        apikey: state.apiKey,
                        strategy: 'scalping_ladder',
                        exchange: exchange,
                        symbol: symbol,
                        action: options.action || 'BUY',
                        quantity: String(level.qty * (options.lotsize || 15)),
                        pricetype: 'LIMIT',
                        product: 'MIS',
                        price: level.price.toFixed(2),
                        trigger_price: '0',
                        disclosed_quantity: '0'
                    };
                    
                    const result = await apiCallWithRetry('/api/v1/placeorder', orderData);
                    
                    results.push({
                        level: i + 1,
                        price: level.price,
                        qty: level.qty,
                        status: result.status,
                        orderId: result.orderid
                    });
                    
                    // Update ladder state
                    const ladder = tradingState.ladderOrders.get(ladderGroupId);
                    ladder.levels[i].status = result.status === 'success' ? 'placed' : 'failed';
                    ladder.levels[i].orderId = result.orderid;
                    
                    // Small delay between orders
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    results.push({
                        level: i + 1,
                        price: level.price,
                        qty: level.qty,
                        status: 'error',
                        error: error.message
                    });
                }
            }
            
            // Update final status
            const ladder = tradingState.ladderOrders.get(ladderGroupId);
            ladder.status = results.every(r => r.status === 'success') ? 'placed' : 'partial';
            
            return { ladderGroupId, results };
        }
        
        // Trailing Stop API - Sets/modifies trailing stop for a position
        async function setTrailingStopAPI(symbol, config) {
            // Store trailing stop configuration
            setTrailingStop(symbol, config);
            
            logToConsole(`📈 Trailing stop set for ${symbol}: Trail ${config.trailPoints} pts from ${config.currentPrice}`, 'info');
            logAuditEntry('TRAILING_STOP_SET', {
                symbol,
                trailPoints: config.trailPoints,
                triggerPrice: config.triggerPrice,
                currentPrice: config.currentPrice
            });
            
            return { status: 'success', symbol, config };
        }
        
        // Profit Protection API - Configures profit protection levels
        async function setProfitProtectionAPI(symbol, levels) {
            tradingState.profitProtectionState.set(symbol, {
                levels: levels,
                currentLevel: -1,
                securedAmount: 0,
                breakevenActive: false
            });
            
            logToConsole(`🛡️ Profit protection configured for ${symbol}`, 'info');
            
            return { status: 'success', symbol, levels };
        }
        
        // Trade Journal API - Fetches trade history
        function getTradeJournalAPI(filters = {}) {
            try {
                const saved = JSON.parse(localStorage.getItem('trade_journal') || '[]');
                let trades = saved;
                
                // Apply filters
                if (filters.symbol) {
                    trades = trades.filter(t => t.symbol.includes(filters.symbol));
                }
                if (filters.startDate) {
                    trades = trades.filter(t => new Date(t.entryTime) >= new Date(filters.startDate));
                }
                if (filters.endDate) {
                    trades = trades.filter(t => new Date(t.entryTime) <= new Date(filters.endDate));
                }
                if (filters.profitable !== undefined) {
                    trades = trades.filter(t => filters.profitable ? t.pnl >= 0 : t.pnl < 0);
                }
                
                return { status: 'success', data: trades, count: trades.length };
            } catch (e) {
                return { status: 'error', message: e.message };
            }
        }
        
        // Position Reconciliation API - Forces sync with broker
        async function reconcilePositionsAPI() {
            await reconcilePositions();
            return { status: 'success', lastReconciliation: lastReconciliation };
        }
        
        // ========== PART 8.3: WEBSOCKET MESSAGE EXTENSIONS ==========
        
        function handleExtendedWSMessage(message) {
            switch (message.type) {
                case 'order_fill':
                    handleOrderFill(message);
                    break;
                case 'trailing_stop_update':
                    handleTrailingStopUpdate(message);
                    break;
                case 'risk_alert':
                    handleRiskAlert(message);
                    break;
                case 'position_update':
                    handlePositionUpdate(message);
                    break;
                case 'heartbeat':
                    handleHeartbeat(message);
                    break;
            }
        }
        
        function handleOrderFill(message) {
            const { orderId, fillPrice, fillQty, timestamp } = message;
            
            updateOrderStatus(orderId, 'filled', { price: fillPrice, qty: fillQty });
            
            const order = tradingState.orders.get(orderId);
            if (order && (order.strategy === 'scalping' || !order.strategy)) {
                const tradeId = `scalp_${orderId}_${Date.now()}`;
                logManualTrade({
                    type: 'ENTRY',
                    tradeId,
                    symbol: order.symbol || '',
                    side: (order.symbol || '').includes('PE') ? 'PE' : ((order.symbol || '').includes('CE') ? 'CE' : undefined),
                    action: order.action || 'BUY',
                    qty: fillQty,
                    price: fillPrice
                });
            }
            
            logToConsole(`✅ Order ${orderId} filled: ${fillQty} @ ₹${fillPrice}`, 'success');
            showToast(`Order filled @ ₹${fillPrice}`, 'success');
            
            // Check if this is part of a ladder order
            tradingState.ladderOrders.forEach((ladder, groupId) => {
                const level = ladder.levels.find(l => l.orderId === orderId);
                if (level) {
                    level.status = 'filled';
                    level.fillPrice = fillPrice;
                    ladder.totalFilled += fillQty;
                    
                    // Place auto-TP if configured
                    if (level.autoTP && level.autoTPPrice) {
                        placeAutoTPForLevel(ladder.symbol, fillQty, level.autoTPPrice);
                    }
                }
            });
            
            logAuditEntry('ORDER_FILLED', { orderId, fillPrice, fillQty, timestamp });
        }
        
        function handleTrailingStopUpdate(message) {
            const { symbol, newStopPrice, securedProfit } = message;
            
            const trailing = tradingState.trailingStops.get(symbol);
            if (trailing) {
                trailing.triggerPrice = newStopPrice;
            }
            
            logToConsole(`📈 Trailing stop updated for ${symbol}: SL @ ₹${newStopPrice}, Secured: ₹${securedProfit}`, 'info');
            
            // Update UI
            updateTrailingStopUI(symbol, newStopPrice, securedProfit);
        }
        
        function handleRiskAlert(message) {
            const { alertType, currentLoss, maxLoss, action } = message;
            
            switch (alertType) {
                case 'approaching_max_loss':
                    showLossWarning('warning', currentLoss);
                    break;
                case 'max_loss_reached':
                    showLossWarning('critical', currentLoss);
                    break;
                case 'daily_limit_warning':
                    showToast(`⚠️ Approaching daily loss limit: ₹${currentLoss}/${maxLoss}`, 'warning');
                    break;
            }
            
            logAuditEntry('RISK_ALERT', message);
        }
        
        function handlePositionUpdate(message) {
            const { symbol, qty, avgPrice, pnl, ltp } = message;
            
            if (qty === 0) {
                removePosition(symbol);
            } else {
                updatePosition(symbol, { qty, avgPrice, pnl, ltp });
            }
        }
        
        function handleHeartbeat(message) {
            tradingState.lastHeartbeat = Date.now();
            tradingState.wsLatency = message.latency || 0;
            updateConnectionHealth('ws', tradingState.wsLatency);
        }
        
        function updateTrailingStopUI(symbol, stopPrice, securedProfit) {
            // Update any UI elements showing trailing stop info
            const securedDisplay = document.getElementById('securedProfitValue');
            if (securedDisplay) {
                securedDisplay.textContent = `₹${securedProfit.toFixed(0)}`;
            }
        }
        
        async function placeAutoTPForLevel(symbol, qty, tpPrice) {
            const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';
            
            try {
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'scalping_auto_tp',
                    exchange: exchange,
                    symbol: symbol,
                    action: 'SELL',
                    quantity: String(qty),
                    pricetype: 'LIMIT',
                    product: 'MIS',
                    price: tpPrice.toFixed(2)
                };
                
                await apiCallWithRetry('/api/v1/placeorder', orderData);
                logToConsole(`🎯 Auto-TP placed for ${symbol} @ ₹${tpPrice}`, 'success');
            } catch (error) {
                logToConsole(`❌ Failed to place auto-TP: ${error.message}`, 'error');
            }
        }

        // ========== PHASE 5: EXIT DECISION HELPER ==========
        
        function analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition) {
            const analysis = {
                momentum: 'neutral',
                suggestion: 'HOLD',
                reason: '',
                actions: []
            };
            
            // Calculate momentum based on price movement
            const priceChange = ((currentPrice - entryPrice) / entryPrice) * 100;
            
            if (priceChange > 5) {
                analysis.momentum = 'strong_up';
            } else if (priceChange > 2) {
                analysis.momentum = 'up';
            } else if (priceChange < -5) {
                analysis.momentum = 'strong_down';
            } else if (priceChange < -2) {
                analysis.momentum = 'down';
            }
            
            // Time-based analysis
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const day = now.getDay();
            
            const isExpiryDay = day === 4; // Thursday
            const isLateSession = hours >= 14;
            const isClosingHour = hours >= 15;
            
            // Generate suggestion based on conditions
            if (currentPnl > 0) {
                // Profitable position
                if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing soon - book profits';
                    analysis.actions = ['Exit Now', 'Trail Tight'];
                } else if (isExpiryDay && isLateSession) {
                    analysis.suggestion = 'TRAIL';
                    analysis.reason = 'Expiry day gamma - use tight trailing stop';
                    analysis.actions = ['Trail +3', 'Trail +5', 'Exit 50%'];
                } else if (analysis.momentum === 'strong_up') {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Strong momentum - let it ride with trailing SL';
                    analysis.actions = ['Trail +5', 'Trail +10', 'Exit 50%'];
                } else if (timeInPosition > 15 * 60 * 1000) { // > 15 minutes
                    analysis.suggestion = 'CONSIDER_EXIT';
                    analysis.reason = 'Position held long - consider booking';
                    analysis.actions = ['Exit Now', 'Trail +5', 'Hold'];
                } else {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Position in profit - monitor closely';
                    analysis.actions = ['Trail +5', 'Exit 50%', 'Hold'];
                }
            } else {
                // Losing position
                if (currentPnl < -2000) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Significant loss - cut position';
                    analysis.actions = ['Exit Now', 'Exit 50%'];
                } else if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing - avoid overnight risk';
                    analysis.actions = ['Exit Now'];
                } else if (timeInPosition > 10 * 60 * 1000) { // > 10 minutes in loss
                    analysis.suggestion = 'REVIEW';
                    analysis.reason = 'Extended time in loss - review thesis';
                    analysis.actions = ['Exit Now', 'Add Position', 'Set Tighter SL'];
                } else {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Give position time to work';
                    analysis.actions = ['Hold', 'Set SL', 'Exit'];
                }
            }
            
            return analysis;
        }
        
        function showExitDecisionHelper(symbol, currentPnl, entryPrice, currentPrice) {
            const timeInPosition = Date.now() - (state.positionEntryTime || Date.now());
            const analysis = analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition);
            
            const helperHtml = `
                <div class="exit-helper-modal" id="exitHelperModal">
                    <div class="exit-helper-content">
                        <div class="exit-helper-header">
                            <span>💡 Exit Decision Helper</span>
                            <button onclick="closeExitHelper()" class="close-btn">×</button>
                        </div>
                        <div class="exit-helper-body">
                            <div class="exit-pnl ${currentPnl >= 0 ? 'profit' : 'loss'}">
                                Current P&L: ₹${currentPnl.toFixed(0)} (${((currentPrice - entryPrice) / entryPrice * 100).toFixed(1)}%)
                            </div>
                            <div class="exit-analysis">
                                <div class="analysis-row">
                                    <span>📊 Momentum:</span>
                                    <span class="momentum-${analysis.momentum}">${analysis.momentum.replace('_', ' ').toUpperCase()}</span>
                                </div>
                                <div class="analysis-row">
                                    <span>⏱️ Time in Position:</span>
                                    <span>${Math.floor(timeInPosition / 60000)} min</span>
                                </div>
                            </div>
                            <div class="exit-suggestion ${analysis.suggestion.toLowerCase()}">
                                <strong>💡 Suggestion: ${analysis.suggestion}</strong>
                                <p>${analysis.reason}</p>
                            </div>
                            <div class="exit-actions">
                                ${analysis.actions.map(action => `
                                    <button class="exit-action-btn" onclick="executeExitAction('${action}', '${symbol}')">${action}</button>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if any
            const existing = document.getElementById('exitHelperModal');
            if (existing) existing.remove();
            
            document.body.insertAdjacentHTML('beforeend', helperHtml);
        }
        
        function closeExitHelper() {
            const modal = document.getElementById('exitHelperModal');
            if (modal) modal.remove();
        }
        
        function executeExitAction(action, symbol) {
            closeExitHelper();
            
            switch (action) {
                case 'Exit Now':
                    // Trigger close position
                    closeAllPositions();
                    break;
                case 'Exit 50%':
                    showToast('Exit 50% - reduce position manually', 'info');
                    break;
                case 'Trail +3':
                case 'Trail +5':
                case 'Trail +10':
                    const points = parseInt(action.replace('Trail +', ''));
                    showToast(`Set trailing stop +${points} points`, 'info');
                    break;
                case 'Add Position':
                    showToast('Consider adding to position', 'info');
                    break;
                case 'Set Tighter SL':
                    showToast('Set a tighter stop loss', 'info');
                    break;
                default:
                    showToast(action, 'info');
            }
        }
        
        // ========== PHASE 5: TRADE JOURNAL INTEGRATION ==========
        
        const tradeJournal = [];
        let currentTrade = null;
        
        function startTrade(symbol, action, quantity, entryPrice) {
            const now = new Date();
            currentTrade = {
                id: Date.now(),
                symbol: symbol,
                action: action,
                quantity: quantity,
                entryPrice: entryPrice,
                entryTime: now.toISOString(),
                context: {
                    day: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][now.getDay()],
                    time: `${now.getHours()}:${now.getMinutes().toString().padStart(2, '0')}`,
                    isExpiry: now.getDay() === 4,
                    session: now.getHours() >= 14 ? 'Late' : now.getHours() < 10 ? 'Opening' : 'Mid'
                }
            };
            
            state.positionEntryTime = Date.now();
            logToConsole(`📝 Trade started: ${symbol} ${action} ${quantity}`, 'info');
        }
        
        function endTrade(exitPrice, pnl, exitReason) {
            if (!currentTrade) return null;
            
            const now = new Date();
            const duration = Date.now() - new Date(currentTrade.entryTime).getTime();
            
            const completedTrade = {
                ...currentTrade,
                exitPrice: exitPrice,
                exitTime: now.toISOString(),
                pnl: pnl,
                duration: Math.floor(duration / 60000), // minutes
                exitReason: exitReason,
                notes: ''
            };
            
            tradeJournal.push(completedTrade);
            
            // Persist to localStorage
            try {
                const saved = JSON.parse(localStorage.getItem('trade_journal') || '[]');
                saved.push(completedTrade);
                // Keep last 100 trades
                localStorage.setItem('trade_journal', JSON.stringify(saved.slice(-100)));
            } catch (e) {
                console.error('Failed to save trade journal:', e);
            }
            
            // Show journal entry dialog
            showTradeJournalEntry(completedTrade);
            
            currentTrade = null;
            state.positionEntryTime = null;
            
            return completedTrade;
        }
        
        function showTradeJournalEntry(trade) {
            const journalHtml = `
                <div class="journal-modal" id="journalModal">
                    <div class="journal-content">
                        <div class="journal-header">
                            <span>📔 Trade Journal Entry</span>
                            <button onclick="closeJournalModal()" class="close-btn">×</button>
                        </div>
                        <div class="journal-body">
                            <div class="journal-summary">
                                <div class="journal-row">
                                    <span>Symbol:</span>
                                    <strong>${trade.symbol}</strong>
                                </div>
                                <div class="journal-row">
                                    <span>Entry:</span>
                                    <span>${trade.context.time} | ₹${trade.entryPrice}</span>
                                </div>
                                <div class="journal-row">
                                    <span>Exit:</span>
                                    <span>${new Date(trade.exitTime).toLocaleTimeString()} | ₹${trade.exitPrice}</span>
                                </div>
                                <div class="journal-row">
                                    <span>Duration:</span>
                                    <span>${trade.duration} min</span>
                                </div>
                                <div class="journal-row pnl ${trade.pnl >= 0 ? 'profit' : 'loss'}">
                                    <span>P&L:</span>
                                    <strong>₹${trade.pnl.toFixed(0)}</strong>
                                </div>
                            </div>
                            <div class="journal-context">
                                <strong>Context:</strong>
                                <span>${trade.context.day} ${trade.context.isExpiry ? '(Expiry)' : ''} | ${trade.context.session} Session</span>
                            </div>
                            <div class="journal-exit-reason">
                                <strong>Exit Reason:</strong>
                                <div class="exit-reason-options">
                                    <label><input type="radio" name="exitReason" value="target" ${trade.exitReason === 'target' ? 'checked' : ''}> Target Hit</label>
                                    <label><input type="radio" name="exitReason" value="stoploss" ${trade.exitReason === 'stoploss' ? 'checked' : ''}> Stop Loss</label>
                                    <label><input type="radio" name="exitReason" value="trailing" ${trade.exitReason === 'trailing' ? 'checked' : ''}> Trailing SL</label>
                                    <label><input type="radio" name="exitReason" value="manual" ${trade.exitReason === 'manual' ? 'checked' : ''}> Manual</label>
                                    <label><input type="radio" name="exitReason" value="protection" ${trade.exitReason === 'protection' ? 'checked' : ''}> Profit Protection</label>
                                </div>
                            </div>
                            <div class="journal-notes">
                                <strong>Notes:</strong>
                                <textarea id="tradeNotes" placeholder="What did you learn from this trade?">${trade.notes}</textarea>
                            </div>
                            <div class="journal-actions">
                                <button onclick="saveJournalEntry(${trade.id})" class="save-btn">💾 Save</button>
                                <button onclick="closeJournalModal()" class="skip-btn">Skip</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', journalHtml);
        }
        
        function closeJournalModal() {
            const modal = document.getElementById('journalModal');
            if (modal) modal.remove();
        }
        
        function saveJournalEntry(tradeId) {
            const notes = document.getElementById('tradeNotes')?.value || '';
            const exitReason = document.querySelector('input[name="exitReason"]:checked')?.value || 'manual';
            
            // Update the trade in journal
            const trade = tradeJournal.find(t => t.id === tradeId);
            if (trade) {
                trade.notes = notes;
                trade.exitReason = exitReason;
                
                // Update localStorage
                try {
                    const saved = JSON.parse(localStorage.getItem('trade_journal') || '[]');
                    const idx = saved.findIndex(t => t.id === tradeId);
                    if (idx >= 0) {
                        saved[idx] = trade;
                        localStorage.setItem('trade_journal', JSON.stringify(saved));
                    }
                } catch (e) {
                    console.error('Failed to update trade journal:', e);
                }
            }
            
            closeJournalModal();
            showToast('Trade journal entry saved', 'success');
        }
        
        function exportTradeJournal() {
            try {
                const saved = JSON.parse(localStorage.getItem('trade_journal') || '[]');
                const data = JSON.stringify(saved, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `trade_journal_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                showToast('Trade journal exported', 'success');
            } catch (e) {
                showToast('Failed to export journal', 'error');
            }
        }
        
        // ========== PHASE 5: LOSS AVERSION COUNTERMEASURES ==========
        
        const LOSS_LIMITS = {
            warningThreshold: 1000,    // Show warning at -₹1000
            criticalThreshold: 2000,   // Critical warning at -₹2000
            autoExitThreshold: Infinity,   // Auto-exit handled by risk engine
            maxTimeInLoss: 10 * 60 * 1000  // 10 minutes max in loss
        };
        
        let lossWarningShown = false;
        let lossTimerStarted = null;
        let autoExitTimer = null;
        let lossPositionKey = null;

        function resetLossAversionState() {
            lossWarningShown = false;
            lossTimerStarted = null;
            if (autoExitTimer) {
                clearTimeout(autoExitTimer);
                autoExitTimer = null;
            }
            hideLossWarning();
        }
        
        function checkLossAversion(currentPnl) {
            if (currentPnl >= 0) {
                // Reset loss tracking when profitable
                resetLossAversionState();
                return;
            }
            
            const loss = Math.abs(currentPnl);
            
            // Start loss timer if not started
            if (!lossTimerStarted) {
                lossTimerStarted = Date.now();
            }
            
            const timeInLoss = Date.now() - lossTimerStarted;
            
            // Auto-exit threshold
            if (loss >= LOSS_LIMITS.autoExitThreshold) {
                showLossWarning('critical', loss, 0);
                if (!autoExitTimer) {
                    autoExitTimer = setTimeout(() => {
                        logToConsole('🚨 AUTO-EXIT: Loss limit reached', 'error');
                        showToast('🚨 Auto-exit triggered - loss limit reached', 'error');
                        closeAllPositions();
                        logAuditEntry('AUTO_EXIT', { reason: 'loss_limit', loss: loss });
                    }, 5000); // 5 second grace period
                }
                return;
            }
            
            // Critical warning
            if (loss >= LOSS_LIMITS.criticalThreshold) {
                showLossWarning('critical', loss, 30);
                return;
            }
            
            // Warning threshold
            if (loss >= LOSS_LIMITS.warningThreshold && !lossWarningShown) {
                lossWarningShown = true;
                showLossWarning('warning', loss, 120);
            }
            
            // Time-based warning
            if (timeInLoss >= LOSS_LIMITS.maxTimeInLoss && loss > 500) {
                showLossWarning('time', loss, 60);
            }
        }
        
        function showLossWarning(type, loss, countdown) {
            let existing = document.getElementById('lossWarningBanner');
            
            const messages = {
                warning: `⚠️ Position at -₹${loss.toFixed(0)} | Review your thesis`,
                critical: `🚨 CRITICAL: -₹${loss.toFixed(0)} | Consider exiting NOW`,
                time: `⏱️ Extended time in loss (-₹${loss.toFixed(0)}) | Decision required`
            };
            
            const bannerHtml = `
                <div class="loss-warning-banner ${type}" id="lossWarningBanner">
                    <div class="loss-warning-content">
                        <span class="loss-message">${messages[type]}</span>
                        ${countdown > 0 ? `<span class="loss-countdown" id="lossCountdown">Auto-action in: ${countdown}s</span>` : ''}
                    </div>
                    <div class="loss-actions">
                        <button onclick="executeExitAction('Exit Now')" class="loss-exit-btn">Exit Now</button>
                        <button onclick="hideLossWarning()" class="loss-dismiss-btn">Dismiss</button>
                    </div>
                </div>
            `;
            
            if (existing) {
                existing.outerHTML = bannerHtml;
            } else {
                document.body.insertAdjacentHTML('afterbegin', bannerHtml);
            }
            
            // Play alert sound for critical
            if (type === 'critical') {
                playAlertSound();
            }
        }
        
        function hideLossWarning() {
            const banner = document.getElementById('lossWarningBanner');
            if (banner) banner.remove();
        }
        
        function playAlertSound() {
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleQAA');
                audio.volume = 0.3;
                audio.play().catch(() => {}); // Ignore autoplay errors
            } catch (e) {
                // Audio not supported
            }
        }
        
        function calculateOpenPnl() {
            if (!state.positions || state.positions.length === 0) return null;

            let openPnl = 0;
            let hasOpen = false;
            let pricedCount = 0;

            state.positions.forEach(position => {
                const qty = parseInt(position.quantity) || 0;
                if (qty === 0) return;
                hasOpen = true;

                const avgPrice = parseFloat(position.average_price) || 0;
                const currentPrice = getPositionPrice(position.symbol);

                if (currentPrice && currentPrice > 0) {
                    pricedCount++;
                    openPnl += (currentPrice - avgPrice) * qty;
                } else if (avgPrice > 0) {
                    // Missing price: treat as flat to avoid false loss warnings
                    openPnl += 0;
                }
            });

            if (!hasOpen || pricedCount === 0) return null;
            return openPnl;
        }

        function getOpenPositionKey() {
            if (!state.positions || state.positions.length === 0) return null;
            const parts = state.positions
                .filter(p => (parseInt(p.quantity) || 0) !== 0)
                .map(p => {
                    const qty = parseInt(p.quantity) || 0;
                    const avg = parseFloat(p.average_price) || 0;
                    return `${p.symbol}:${qty}:${avg.toFixed(2)}`;
                })
                .sort();
            return parts.length ? parts.join('|') : null;
        }

        // Check loss aversion every second when in position
        setInterval(() => {
            const key = getOpenPositionKey();
            if (!key) {
                if (lossPositionKey) {
                    lossPositionKey = null;
                    resetLossAversionState();
                }
                return;
            }

            if (lossPositionKey !== key) {
                lossPositionKey = key;
                resetLossAversionState();
            }

            const openPnl = calculateOpenPnl();
            if (openPnl === null) return;
            state.openPnl = openPnl;
            checkLossAversion(openPnl);
        }, 1000);

        // ========== PART 9.3: RISK MANAGEMENT PANEL FUNCTIONS ==========
        
        function toggleRiskPanelExpand() {
            const expanded = document.getElementById('riskPanelExpanded');
            const toggle = document.getElementById('riskPanelToggle');
            
            if (expanded.style.display === 'none') {
                expanded.style.display = 'block';
                toggle.textContent = '▲ Collapse';
                tradingState.riskPanelExpanded = true;
            } else {
                expanded.style.display = 'none';
                toggle.textContent = '▼ Expand';
                tradingState.riskPanelExpanded = false;
            }
        }
        
        function updateRiskPanelUI() {
            // Update daily P&L
            const dailyPnlValue = document.getElementById('dailyPnlValue');
            const dailyPnlBar = document.getElementById('dailyPnlBar');
            const dailyLimitValue = document.getElementById('dailyLimitValue');
            const dailyPnl = Number.isFinite(state.totalPnl) ? state.totalPnl : (tradingState.dailyPnL || 0);
            
            if (dailyPnlValue) {
                dailyPnlValue.textContent = `₹${dailyPnl.toFixed(0)}`;
                dailyPnlValue.style.color = dailyPnl >= 0 ? 'var(--success)' : 'var(--danger)';
            }
            
            if (dailyPnlBar) {
                const maxLoss = tradingState.maxDailyLoss;
                const lossPercent = maxLoss > 0 ? Math.min(100, Math.abs(dailyPnl) / maxLoss * 100) : 0;
                dailyPnlBar.style.width = `${lossPercent}%`;
                dailyPnlBar.style.background = dailyPnl >= 0 ? 'var(--success)' :
                    (lossPercent > 75 ? 'var(--danger)' : 'var(--warning)');
            }
            
            if (dailyLimitValue) {
                dailyLimitValue.textContent = `₹${tradingState.maxDailyLoss.toLocaleString()}`;
            }
            
            // Update position risk info
            const positionRiskInfo = document.getElementById('positionRiskInfo');
            const positionRiskBar = document.getElementById('positionRiskBar');
            const positionLossBar = document.getElementById('positionLossBar');

            const openPositions = Array.isArray(state.positions)
                ? state.positions.filter(p => (parseInt(p.quantity) || 0) !== 0)
                : [];

            if (openPositions.length > 0) {
                let totalUnrealized = 0;
                let positionText = '';

                openPositions.forEach(pos => {
                    const qty = parseInt(pos.quantity) || 0;
                    const avgPrice = parseFloat(pos.average_price) || 0;
                    const currentPrice = getPositionPrice(pos.symbol) || avgPrice;
                    const pnl = (currentPrice - avgPrice) * qty;
                    totalUnrealized += pnl;
                    const sideLabel = qty > 0 ? 'LONG' : 'SHORT';
                    positionText += `${pos.symbol}: ${sideLabel} ${Math.abs(qty)} | P&L: ₹${pnl.toFixed(0)}\n`;
                });

                if (positionRiskInfo) {
                    positionRiskInfo.innerHTML = positionText.replace(/\n/g, '<br>');
                }

                if (positionRiskBar && positionLossBar) {
                    positionRiskBar.style.display = 'block';
                    const lossLimit = tradingState.perTradeLossLimit || 0;
                    const lossPercent = lossLimit > 0 ? Math.min(100, Math.abs(totalUnrealized) / lossLimit * 100) : 0;
                    positionLossBar.style.width = `${lossPercent}%`;
                }
            } else {
                if (positionRiskInfo) {
                    positionRiskInfo.textContent = 'No active position';
                }
                if (positionRiskBar) {
                    positionRiskBar.style.display = 'none';
                }
            }
            
            // Update session stats
            const stats = getSessionStats();
            
            const statsTotalTrades = document.getElementById('statsTotalTrades');
            const statsWinRate = document.getElementById('statsWinRate');
            const statsProfitFactor = document.getElementById('statsProfitFactor');
            const statsNetPnL = document.getElementById('statsNetPnL');
            
            if (statsTotalTrades) statsTotalTrades.textContent = stats.totalTrades;
            if (statsWinRate) {
                statsWinRate.textContent = `${stats.winRate}%`;
                statsWinRate.style.color = parseFloat(stats.winRate) >= 50 ? 'var(--success)' : 'var(--danger)';
            }
            if (statsProfitFactor) {
                statsProfitFactor.textContent = stats.profitFactor;
                statsProfitFactor.style.color = parseFloat(stats.profitFactor) >= 1 ? 'var(--success)' : 'var(--danger)';
            }
            if (statsNetPnL) {
                statsNetPnL.textContent = `₹${stats.netPnL.toFixed(0)}`;
                statsNetPnL.style.color = stats.netPnL >= 0 ? 'var(--success)' : 'var(--danger)';
            }
        }
        
        // Update risk panel settings from inputs
        function initRiskPanelListeners() {
            const perTradeLossInput = document.getElementById('perTradeLossLimit');
            const dailyLossInput = document.getElementById('dailyLossLimit');
            const autoExitCheckbox = document.getElementById('autoExitOnMaxLoss');
            const coolingOffCheckbox = document.getElementById('coolingOffEnabled');
            const dailyLossBlockCheckbox = document.getElementById('dailyLossBlockEnabled');
            
            if (perTradeLossInput) {
                perTradeLossInput.addEventListener('change', (e) => {
                    tradingState.perTradeLossLimit = parseInt(e.target.value) || 2000;
                    logToConsole(`Per-trade loss limit set to ₹${tradingState.perTradeLossLimit}`, 'info');
                });
            }
            
            if (dailyLossInput) {
                dailyLossInput.addEventListener('change', (e) => {
                    tradingState.maxDailyLoss = parseInt(e.target.value) || 10000;
                    if (typeof ORDER_LIMITS !== 'undefined') {
                        ORDER_LIMITS.maxDailyLoss = tradingState.maxDailyLoss;
                    }
                    updateRiskPanelUI();
                    logToConsole(`Daily loss limit set to ₹${tradingState.maxDailyLoss}`, 'info');
                });
            }
            
            if (autoExitCheckbox) {
                autoExitCheckbox.addEventListener('change', (e) => {
                    state.autoExitOnMaxLoss = e.target.checked;
                    logToConsole(`Auto-exit on max loss: ${e.target.checked ? 'Enabled' : 'Disabled'}`, 'info');
                });
            }

            if (dailyLossBlockCheckbox) {
                tradingState.dailyLossBlockEnabled = dailyLossBlockCheckbox.checked;
                dailyLossBlockCheckbox.addEventListener('change', (e) => {
                    tradingState.dailyLossBlockEnabled = e.target.checked;
                    logToConsole(`Daily loss block: ${e.target.checked ? 'Enabled' : 'Warn only'}`, 'info');
                });
            }

            if (coolingOffCheckbox) {
                tradingState.coolingOffEnabled = coolingOffCheckbox.checked;
                coolingOffCheckbox.addEventListener('change', (e) => {
                    tradingState.coolingOffEnabled = e.target.checked;
                    logToConsole(`Cooling-off: ${e.target.checked ? 'Enabled' : 'Disabled'}`, 'info');
                });
            }

            if (autoExitCheckbox) {
                state.autoExitOnMaxLoss = autoExitCheckbox.checked;
            }
        }
        
        // Initialize risk panel on load
        document.addEventListener('DOMContentLoaded', () => {
            initRiskPanelListeners();
            updateRiskPanelUI();
        });
        
        // Update risk panel every 2 seconds
        setInterval(updateRiskPanelUI, 2000);

        async function loadExpiries() {
            try {
                logToConsole(`Loading expiries for ${state.selectedIndex}...`, 'info');
                // BFO for SENSEX, NFO for NIFTY/BANKNIFTY
                const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';

                const requestData = {
                    symbol: state.selectedIndex,
                    exchange: exchange,
                    instrumenttype: 'options'
                };

                logToConsole(`API Request: ${JSON.stringify(requestData)}`, 'info');
                const result = await apiCall('/api/v1/expiry', requestData);
                logToConsole(`API Response: ${JSON.stringify(result)}`, 'info');

                if (result.status === 'success' && result.data && result.data.length > 0) {
                    const expiries = result.data;

                    // Populate dropdown
                    elements.expirySelect.innerHTML = expiries.map((exp, idx) => {
                        let label = exp;
                        if (idx === 0) label += ' (Current Week)';
                        else if (idx === 1) label += ' (Next Week)';
                        return `<option value="${exp}">${label}</option>`;
                    }).join('');

                    state.selectedExpiry = expiries[0];
                    logToConsole(`✓ Loaded ${expiries.length} expiries, selected: ${state.selectedExpiry}`, 'success');
                    loadOptionChain();
                } else {
                    const errorMsg = result.message || JSON.stringify(result);
                    logToConsole(`❌ Failed to load expiries: ${errorMsg}`, 'error');
                    showToast(`Failed to load expiries: ${errorMsg}`, 'error');
                }
            } catch (error) {
                console.error('Error loading expiries:', error);
                const errorMsg = error.message || String(error);
                logToConsole(`❌ Error loading expiries: ${errorMsg}`, 'error');
                showToast(`Error loading expiries: ${errorMsg}`, 'error');
            }
        }

        async function loadOptionChain() {
            try {
                logToConsole(`Loading option chain for ${state.selectedIndex} expiry ${state.selectedExpiry}...`, 'info');
                const exchange = state.selectedIndex === 'SENSEX' ? 'BSE_INDEX' : 'NSE_INDEX';

                // Remove hyphens from expiry date (e.g., "03-FEB-26" -> "03FEB26")
                const expiryFormatted = state.selectedExpiry.replace(/-/g, '');
                logToConsole(`Formatted expiry: ${state.selectedExpiry} -> ${expiryFormatted}`, 'info');

                const requestData = {
                    underlying: state.selectedIndex,
                    exchange: exchange,
                    expiry_date: expiryFormatted,
                    strike_count: CONFIG.strikeCount
                };

                logToConsole(`API Request: ${JSON.stringify(requestData)}`, 'info');
                const result = await apiCall('/api/v1/optionchain', requestData);
                logToConsole(`API Response: ${JSON.stringify(result).substring(0, 200)}...`, 'info');

                if (result.status === 'success') {
                    state.optionChainData = result.chain;

                    // Store formatted expiry for order placement
                    state.expiryFormatted = expiryFormatted;

                    updateIndexInfo(result);
                    renderOptionChain(result.chain);

                    logToConsole(`✓ Loaded ${result.chain.length} strikes, ATM: ${result.atm_strike}`, 'success');

                    // Subscribe to all option symbols
                    const symbols = [];
                    const optionExchange = exchange === 'BSE_INDEX' ? 'BFO' : 'NFO';
                    state.optionExchange = optionExchange;
                    result.chain.forEach(item => {
                        if (item.ce) symbols.push({ symbol: item.ce.symbol, exchange: optionExchange });
                        if (item.pe) symbols.push({ symbol: item.pe.symbol, exchange: optionExchange });
                    });

                    // Also subscribe to index
                    symbols.push({ symbol: state.selectedIndex, exchange: exchange });

                    subscribeToOptions(symbols);
                    syncDepthTarget();
                } else {
                    logToConsole(`❌ Failed to load option chain: ${result.message}`, 'error');
                    showToast('Failed to load option chain', 'error');
                }
            } catch (error) {
                console.error('Error loading option chain:', error);
                logToConsole(`❌ Error loading option chain: ${error.message}`, 'error');
                showToast('Error loading option chain', 'error');
            }
        }

        async function loadPositions() {
            try {
                const result = await apiCall('/api/v1/positionbook', {});

                if (result.status === 'success') {
                    const previousPositions = new Map(state.positions.map(p => [p.symbol, p]));
                    state.positions = result.data || [];

                    // Debug: Log position data with price sources
                    console.log('=== POSITIONS LOADED ===');
                    console.log('Total positions:', state.positions.length);
                    state.positions.forEach((pos, i) => {
                        const wsPrice = state.prices.get(pos.symbol);
                        const bestPrice = getPositionPrice(pos.symbol);
                        console.log(`Position ${i + 1}:`, {
                            symbol: pos.symbol,
                            quantity: pos.quantity,
                            average_price: pos.average_price,
                            wsPrice: wsPrice || 'none',
                            bestPrice: bestPrice || 'none',
                            pricesMapSize: state.prices.size
                        });
                    });

                    // Check for new positions and place auto TP/SL
                    if (state.autoTPEnabled) {
                        for (const pos of state.positions) {
                            const qty = parseInt(pos.quantity) || 0;
                            const symbol = pos.symbol;
                            const avgPrice = parseFloat(pos.average_price) || 0;
                            
                            // Skip if no position or already placed TP/SL
                            if (qty === 0 || state.virtualTPSL.has(symbol)) continue;
                            
                            // Check if this is a new position (wasn't in previous load or had 0 qty)
                            const prevPos = previousPositions.get(symbol);
                            const prevQty = prevPos ? parseInt(prevPos.quantity) || 0 : 0;
                            
                            if (prevQty === 0 && qty !== 0 && avgPrice > 0) {
                                // New position detected - place auto TP/SL
                                const action = qty > 0 ? 'BUY' : 'SELL';
                                logToConsole(`🎯 New position detected: ${symbol} @ ₹${avgPrice.toFixed(2)} - placing auto TP/SL`, 'info');
                                
                                // Set virtual TP/SL levels (stored in state.virtualTPSL Map)
                                placeAutoTPSL(symbol, avgPrice, qty, action);
                            }
                        }
                        
                        // Clean up closed positions from virtual TP/SL tracking
                        for (const symbol of [...state.virtualTPSL.keys()]) {
                            const pos = state.positions.find(p => p.symbol === symbol);
                            if (!pos || parseInt(pos.quantity) === 0) {
                                state.virtualTPSL.delete(symbol);
                            }
                        }
                    }

                    // Subscribe position symbols to WebSocket for real-time updates
                    const openPositions = state.positions.filter(p => parseInt(p.quantity) !== 0);
                    if (openPositions.length > 0 && state.ws && state.ws.readyState === WebSocket.OPEN) {
                        const posSymbols = openPositions.map(p => ({ symbol: p.symbol, exchange: p.exchange || 'NFO' }));
                        subscribeToOptions(posSymbols);
                    }

                    // Fetch prices via API for symbols missing WebSocket data, then render
                    await fetchPositionPrices();
                    renderPositions();
                }
            } catch (error) {
                console.error('Error loading positions:', error);
            }
        }

        // Manual refresh positions function
        async function refreshPositions() {
            try {
                showToast('🔄 Refreshing positions...', 'info');
                await loadPositions();
                showToast('✅ Positions refreshed', 'success');
            } catch (error) {
                console.error('Error refreshing positions:', error);
                showToast('❌ Failed to refresh positions', 'error');
            }
        }

        async function placeOrder(symbol, action, optionType, strike, offset) {
            try {
                if (!enforceRiskGate('Order')) {
                    return;
                }
                // Determine exchange for options (NFO for NIFTY, BFO for SENSEX)
                const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';

                // Get lot size for this strike
                const chainItem = state.optionChainData.find(x => x.strike === strike);
                const lotsize = optionType === 'CE' ? (chainItem?.ce?.lotsize || 15) : (chainItem?.pe?.lotsize || 15);

                // Use DIRECT SYMBOL-BASED API (no offset calculation!)
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'scalping',
                    symbol: symbol,  // ✅ Use actual symbol directly - no more offset bugs!
                    action: action,
                    exchange: exchange,
                    pricetype: state.orderType,
                    product: 'MIS',
                    quantity: String(state.quantity * lotsize),
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                // Add price for LIMIT orders
                if (state.orderType === 'LIMIT') {
                    const limitPrice = parseFloat(document.getElementById('limitPrice').value);
                    if (!limitPrice || limitPrice <= 0) {
                        showToast('⚠️ Enter limit price', 'error');
                        return;
                    }
                    orderData.price = limitPrice.toString();
                }

                console.log('📤 DIRECT ORDER:', {symbol, strike, action, exchange});

                const result = await apiCall('/api/v1/placeorder', orderData);  // ✅ Changed to direct API!

                console.log('📥 RESPONSE:', result);

                if (result.status === 'success') {
                    const orderId = result.orderid || result.order_id;
                    if (orderId) {
                        addOrder(orderId, { symbol, action, exchange, strategy: 'scalping', quantity: String(state.quantity * lotsize) });
                    }
                    logToConsole(`✅ ${action} ${optionType} @ ${strike} (${symbol})`, 'success');
                    showToast(`✓ ${action} ${optionType} @ ${strike} placed!`, 'success');

                    // Set virtual TP/SL IMMEDIATELY using current LTP (don't wait for positionbook)
                    if (state.autoTPEnabled && !state.virtualTPSL.has(symbol)) {
                        const entryEstimate = state.prices.get(symbol) || 0;
                        if (entryEstimate > 0) {
                            const totalQty = state.quantity * lotsize;
                            placeAutoTPSL(symbol, entryEstimate, action === 'BUY' ? totalQty : -totalQty, action);
                        }
                    }

                    setTimeout(() => loadPositions(), 1000);
                } else {
                    logToConsole(`❌ ${action} ${optionType} @ ${strike} FAILED: ${result.message}`, 'error');
                    showToast(`✗ Order failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error placing order:', error);
                logToConsole(`❌ Error placing order: ${error.message}`, 'error');
                showToast(`Error: ${error.message}`, 'error');
            }
        }

        // P&L Management Functions
        function updateLivePnlDisplay() {
            const pnlElement = document.getElementById('livePnlValue');
            const displayElement = document.getElementById('livePnlDisplay');

            pnlElement.textContent = `₹${state.totalPnl.toFixed(2)}`;

            // Update styling
            displayElement.classList.remove('profit', 'loss');
            if (state.totalPnl > 0) {
                displayElement.classList.add('profit');
            } else if (state.totalPnl < 0) {
                displayElement.classList.add('loss');
            }
        }

        function checkPnlLimits() {
            // Prevent multiple simultaneous triggers
            if (state.isClosingPositions) return;

            const currentPnl = Number.isFinite(state.openPnl) ? state.openPnl : state.totalPnl;
            if (!Number.isFinite(currentPnl)) return;

            const autoExitEnabled = state.autoExitOnMaxLoss;
            const openPositions = Array.isArray(state.positions)
                ? state.positions.filter(p => (parseInt(p.quantity) || 0) !== 0)
                : [];

            if (autoExitEnabled) {
                const dailyLimit = tradingState.maxDailyLoss || 0;
                const dailyPnl = Number.isFinite(state.totalPnl) ? state.totalPnl : currentPnl;
                if (dailyLimit > 0 && openPositions.length > 0 && dailyPnl <= -dailyLimit) {
                    logToConsole(`🚨 Daily max loss hit: ₹${dailyPnl.toFixed(2)} <= -₹${dailyLimit}`, 'error');
                    showToast(`🚨 Daily max loss hit. Closing all positions...`, 'error');
                    closePnlPositionsAuto('Daily Max Loss');
                    return;
                }

                const perTradeLimit = tradingState.perTradeLossLimit || 0;
                if (perTradeLimit > 0 && openPositions.length > 0) {
                    openPositions.forEach(position => {
                        const symbol = position.symbol;
                        if (state.perTradeExitPending && state.perTradeExitPending.has(symbol)) return;

                        const qty = parseInt(position.quantity) || 0;
                        const avgPrice = parseFloat(position.average_price) || 0;
                        const currentPrice = getPositionPrice(symbol);
                        if (!currentPrice || !avgPrice) return;

                        const pnl = (currentPrice - avgPrice) * qty;
                        if (pnl <= -perTradeLimit) {
                            state.perTradeExitPending.add(symbol);
                            logToConsole(`🛑 Per-trade max loss hit for ${symbol}: ₹${pnl.toFixed(2)} <= -₹${perTradeLimit}`, 'error');
                            showToast(`🛑 Per-trade loss hit (${symbol}). Closing position...`, 'error');
                            exitPosition(symbol, String(position.quantity));
                        }
                    });
                }
            }
            
            // Check profit protection first (runs independently of P&L monitoring)
            if (state.profitProtectionEnabled) {
                checkProfitProtection(currentPnl);
            }
            
            // Standard P&L monitoring
            if (!state.pnlMonitoringActive) return;

            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const targetProfit = parseFloat(document.getElementById('targetProfit').value);

            // Check stop loss (user enters positive value like 1500 for max loss)
            const normalizedStop = Number.isFinite(stopLoss) ? Math.abs(stopLoss) : null;
            if (normalizedStop && normalizedStop > 0 && currentPnl <= -normalizedStop) {
                logToConsole(`🛑 Stop Loss Hit! P&L: ₹${currentPnl.toFixed(2)} <= -₹${normalizedStop}`, 'error');
                showToast(`🛑 Stop Loss Hit! Closing all positions...`, 'error');
                closePnlPositionsAuto('Stop Loss');
                return;
            }

            // Trailing logic
            if (state.trailingEnabled) {
                const trailPoints = parseFloat(document.getElementById('trailPoints').value) || 0;

                // Check if we've reached target profit to activate trailing
                if (targetProfit && currentPnl >= targetProfit) {
                    // Update highest P&L for trailing
                    if (currentPnl > state.highestPnl) {
                        state.highestPnl = currentPnl;
                        logToConsole(`📈 Trailing activated! Highest P&L: ₹${state.highestPnl.toFixed(2)}`, 'success');
                    }

                    // Check if we should trail
                    const trailingStop = state.highestPnl - trailPoints;

                    if (currentPnl <= trailingStop) {
                        logToConsole(`📉 Trailing Stop Hit! P&L: ₹${currentPnl.toFixed(2)} <= ₹${trailingStop.toFixed(2)} (High: ₹${state.highestPnl.toFixed(2)})`, 'error');
                        showToast(`📉 Trailing Stop Hit! Closing all positions...`, 'error');
                        closePnlPositionsAuto('Trailing Stop');
                        return;
                    }
                } else if (!targetProfit) {
                    // No target profit, trail from beginning
                    if (currentPnl > state.highestPnl) {
                        state.highestPnl = currentPnl;
                        logToConsole(`📈 New highest P&L: ₹${state.highestPnl.toFixed(2)}`, 'info');
                    }

                    const trailingStop = state.highestPnl - trailPoints;

                    if (currentPnl <= trailingStop) {
                        logToConsole(`📉 Trailing Stop Hit! P&L: ₹${currentPnl.toFixed(2)} <= ₹${trailingStop.toFixed(2)}`, 'error');
                        showToast(`📉 Trailing Stop Hit! Closing all positions...`, 'error');
                        closePnlPositionsAuto('Trailing Stop');
                        return;
                    }
                }
            } else {
                // Trailing NOT enabled - use fixed target profit
                if (targetProfit && currentPnl >= targetProfit) {
                    logToConsole(`🎯 Target Profit Hit! P&L: ₹${currentPnl.toFixed(2)} >= ₹${targetProfit}`, 'success');
                    showToast(`🎯 Target Hit! Closing all positions...`, 'success');
                    closePnlPositionsAuto('Target Profit');
                    return;
                }
            }
        }

        async function closePnlPositionsAuto(reason) {
            // Prevent multiple simultaneous triggers
            if (state.isClosingPositions) return;

            state.isClosingPositions = true;
            state.pnlMonitoringActive = false;
            updatePnlMonitorStatus();

            logToConsole(`🚨 Auto-closing all positions due to: ${reason}`, 'warn');

            // Close all positions
            const openPositions = state.positions.filter(p => parseInt(p.quantity) !== 0);
            for (const position of openPositions) {
                await exitPosition(position.symbol, position.quantity);
            }

            // Reset profit protection state
            resetProfitProtection();

            // Reset guard after delay
            setTimeout(() => {
                state.isClosingPositions = false;
                loadPositions();
            }, 2000);
        }

        function updatePnlMonitoring() {
            const stopLoss = document.getElementById('stopLoss').value;
            const targetProfit = document.getElementById('targetProfit').value;
            const trailingEnabled = state.trailingEnabled;
            const trailPoints = document.getElementById('trailPoints').value;
            const stopLossValue = parseFloat(stopLoss);
            const targetValue = parseFloat(targetProfit);
            const trailValue = parseFloat(trailPoints);

            const normalizedStopLoss = Number.isFinite(stopLossValue) ? Math.abs(stopLossValue) : null;
            const normalizedTarget = Number.isFinite(targetValue) ? Math.abs(targetValue) : null;
            const normalizedTrail = Number.isFinite(trailValue) ? Math.abs(trailValue) : 0;

            // Activate monitoring if any limit is set
            if (normalizedStopLoss || normalizedTarget || (trailingEnabled && normalizedTrail)) {
                state.pnlMonitoringActive = true;
                state.stopLoss = normalizedStopLoss;
                state.targetProfit = normalizedTarget;
                state.trailPoints = normalizedTrail;
            } else {
                state.pnlMonitoringActive = false;
            }

            updatePnlMonitorStatus();
        }

        function updatePnlMonitorStatus() {
            const statusElement = document.getElementById('pnlMonitorStatus');

            if (state.pnlMonitoringActive) {
                let status = '🟢 Monitoring: ';
                const parts = [];

                if (state.stopLoss) parts.push(`SL ₹${state.stopLoss}`);
                if (state.targetProfit) parts.push(`TP ₹${state.targetProfit}`);
                if (state.trailingEnabled && state.trailPoints) parts.push(`Trail ₹${state.trailPoints}`);

                status += parts.join(' | ');
                statusElement.textContent = status;
                statusElement.style.color = 'var(--success)';
            } else {
                statusElement.textContent = '⚪ Monitoring: OFF';
                statusElement.style.color = 'var(--text-secondary)';
            }
        }

        // ========== PROFIT PROTECTION SYSTEM ==========
        
        function toggleProfitProtection() {
            const checkbox = document.getElementById('enableProfitProtection');
            state.profitProtectionEnabled = checkbox.checked;
            
            // Enable/disable related inputs
            document.getElementById('breakevenThreshold').disabled = !checkbox.checked;
            
            // Show/hide UI elements
            const securedDisplay = document.getElementById('securedProfitDisplay');
            const levelIndicator = document.getElementById('protectionLevelIndicator');
            const breakevenStatus = document.getElementById('breakevenStatus');
            
            if (checkbox.checked) {
                securedDisplay.style.display = 'block';
                levelIndicator.style.display = 'block';
                breakevenStatus.style.display = 'block';
                
                // Read threshold from input
                state.breakevenThreshold = parseFloat(document.getElementById('breakevenThreshold').value) || 300;
                
                // Reset protection state
                state.currentProtectionLevel = -1;
                state.securedProfit = 0;
                state.breakevenActivated = false;
                
                updateProfitProtectionUI();
                logToConsole('🛡️ Profit Protection enabled', 'success');
            } else {
                securedDisplay.style.display = 'none';
                levelIndicator.style.display = 'none';
                breakevenStatus.style.display = 'none';
                logToConsole('🛡️ Profit Protection disabled', 'info');
            }
        }
        
        function updateProfitProtectionUI() {
            // Update secured profit display
            const securedValue = document.getElementById('securedProfitValue');
            securedValue.textContent = `₹${state.securedProfit.toFixed(0)}`;
            
            // Update protection level indicator
            const currentLevel = document.getElementById('currentProtectionLevel');
            const nextLevel = document.getElementById('nextProtectionLevel');
            
            if (state.currentProtectionLevel >= 0) {
                const level = state.profitProtectionLevels[state.currentProtectionLevel];
                currentLevel.textContent = `₹${level.trigger} → ${level.lockPercent}%`;
            } else {
                currentLevel.textContent = '-';
            }
            
            // Show next level
            const nextLevelIndex = state.currentProtectionLevel + 1;
            if (nextLevelIndex < state.profitProtectionLevels.length) {
                const next = state.profitProtectionLevels[nextLevelIndex];
                nextLevel.textContent = `₹${next.trigger} → ${next.lockPercent}%`;
            } else {
                nextLevel.textContent = 'Max reached';
            }
            
            // Update breakeven status
            const breakevenStatusText = document.getElementById('breakevenStatusText');
            const breakevenStatus = document.getElementById('breakevenStatus');
            
            if (state.breakevenActivated) {
                breakevenStatusText.textContent = '🟢 Breakeven: ACTIVE';
                breakevenStatus.style.background = 'rgba(0,255,136,0.15)';
                breakevenStatus.style.color = 'var(--success)';
            } else {
                breakevenStatusText.textContent = `⚪ Breakeven at ₹${state.breakevenThreshold}`;
                breakevenStatus.style.background = 'rgba(255,255,255,0.05)';
                breakevenStatus.style.color = 'var(--text-secondary)';
            }
        }
        
        function checkProfitProtection(currentPnl) {
            const pnl = Number.isFinite(currentPnl) ? currentPnl : (Number.isFinite(state.openPnl) ? state.openPnl : state.totalPnl);
            if (!state.profitProtectionEnabled || !Number.isFinite(pnl) || pnl <= 0) return;
            
            // Check breakeven activation
            if (!state.breakevenActivated && pnl >= state.breakevenThreshold) {
                state.breakevenActivated = true;
                state.securedProfit = 0; // Breakeven means we won't lose money
                logToConsole(`🟢 Breakeven activated at ₹${pnl.toFixed(2)}! Secured: ₹0 (no loss)`, 'success');
                showToast('🟢 Breakeven activated! Position protected from loss', 'success');
            }
            
            // Check profit protection levels
            for (let i = state.profitProtectionLevels.length - 1; i >= 0; i--) {
                const level = state.profitProtectionLevels[i];
                
                if (pnl >= level.trigger && i > state.currentProtectionLevel) {
                    state.currentProtectionLevel = i;
                    state.securedProfit = level.trigger * (level.lockPercent / 100);
                    
                    logToConsole(`🛡️ Protection Level ${i + 1} activated! Secured: ₹${state.securedProfit.toFixed(0)} (${level.lockPercent}% of ₹${level.trigger})`, 'success');
                    showToast(`🛡️ Secured ₹${state.securedProfit.toFixed(0)} profit!`, 'success');
                    break;
                }
            }
            
            // Check if we should close due to profit protection
            if (state.securedProfit > 0 && pnl <= state.securedProfit) {
                logToConsole(`🛡️ Profit Protection triggered! P&L ₹${pnl.toFixed(2)} <= Secured ₹${state.securedProfit.toFixed(0)}`, 'warn');
                showToast(`🛡️ Profit Protection! Closing to secure ₹${state.securedProfit.toFixed(0)}`, 'success');
                closePnlPositionsAuto('Profit Protection');
                return;
            }
            
            // Check breakeven stop (if activated and P&L goes negative)
            if (state.breakevenActivated && pnl <= 0) {
                logToConsole(`🛡️ Breakeven Stop triggered! P&L dropped to ₹${pnl.toFixed(2)}`, 'warn');
                showToast('🛡️ Breakeven Stop! Closing at breakeven', 'info');
                closePnlPositionsAuto('Breakeven Stop');
                return;
            }
            
            updateProfitProtectionUI();
        }
        
        // ========== AUTO TP/SL SYSTEM ==========
        
        function toggleAutoTPSL() {
            const checkbox = document.getElementById('enableAutoTPSL');
            state.autoTPEnabled = checkbox.checked;
            
            // Enable/disable related inputs
            document.getElementById('autoTPPoints').disabled = !checkbox.checked;
            document.getElementById('autoSLPoints').disabled = !checkbox.checked;
            
            if (checkbox.checked) {
                state.autoTPPoints = parseFloat(document.getElementById('autoTPPoints').value) || 5;
                state.autoSLPoints = parseFloat(document.getElementById('autoSLPoints').value) || 8;
                logToConsole(`🎯 Auto TP/SL enabled: TP +${state.autoTPPoints}pts, SL -${state.autoSLPoints}pts`, 'success');
            } else {
                logToConsole('🎯 Auto TP/SL disabled', 'info');
            }
        }
        
        // Round price to nearest tick size (0.05 for options)
        function roundToTick(price, tickSize = 0.05) {
            return Math.round(price / tickSize) * tickSize;
        }

        // Set virtual TP/SL levels when a position is detected (no real broker orders)
        function placeAutoTPSL(symbol, entryPrice, quantity, action) {
            if (!state.autoTPEnabled) return;

            const isLong = action === 'BUY';
            const tpPrice = roundToTick(isLong ? entryPrice + state.autoTPPoints : entryPrice - state.autoTPPoints);
            const slPrice = roundToTick(isLong ? entryPrice - state.autoSLPoints : entryPrice + state.autoSLPoints);

            // Store virtual TP/SL levels (monitored client-side, triggers MARKET order when hit)
            state.virtualTPSL.set(symbol, {
                tpPrice: tpPrice,
                slPrice: slPrice,
                entryPrice: entryPrice,
                action: action,
                quantity: quantity
            });

            logToConsole(`🎯 Virtual TP ₹${tpPrice.toFixed(2)} / SL ₹${slPrice.toFixed(2)} active (price monitoring)`, 'success');
            showToast(`TP ₹${tpPrice.toFixed(2)} / SL ₹${slPrice.toFixed(2)}`, 'success');
        }

        // Check if price crossed virtual TP/SL levels for a symbol
        function checkVirtualTPSLScalping(symbol, ltp) {
            const tpsl = state.virtualTPSL.get(symbol);
            if (!tpsl) return;

            const isLong = tpsl.action === 'BUY';

            // Check TP hit
            if (tpsl.tpPrice !== null) {
                if ((isLong && ltp >= tpsl.tpPrice) || (!isLong && ltp <= tpsl.tpPrice)) {
                    executeVirtualTPSLScalping('TP', symbol, tpsl);
                    return;
                }
            }

            // Check SL hit
            if (tpsl.slPrice !== null) {
                if ((isLong && ltp <= tpsl.slPrice) || (!isLong && ltp >= tpsl.slPrice)) {
                    executeVirtualTPSLScalping('SL', symbol, tpsl);
                    return;
                }
            }
        }

        // Execute virtual TP/SL — close position with MARKET order
        async function executeVirtualTPSLScalping(type, symbol, tpsl) {
            // Remove from tracking immediately to prevent re-triggers
            state.virtualTPSL.delete(symbol);

            const triggerPrice = type === 'TP' ? tpsl.tpPrice : tpsl.slPrice;
            logToConsole(`🎯 ${type} triggered for ${symbol} at ₹${triggerPrice.toFixed(2)} — auto-closing`, type === 'TP' ? 'success' : 'error');
            showToast(`${type} hit ₹${triggerPrice.toFixed(2)} — closing ${symbol}`, type === 'TP' ? 'success' : 'error');

            // Close position via existing exitPosition
            await exitPosition(symbol, String(tpsl.quantity));
        }
        
        // Reset profit protection state when positions are closed
        function resetProfitProtection() {
            state.currentProtectionLevel = -1;
            state.securedProfit = 0;
            state.breakevenActivated = false;
            state.highestPnl = 0;
            
            if (state.profitProtectionEnabled) {
                updateProfitProtectionUI();
            }
        }

        // ========== PHASE 2: QUICK ENTRY PRESETS ==========
        
        const ENTRY_PRESETS = {
            scalp: {
                name: 'Scalp',
                lots: 2,
                orderType: 'MARKET',
                autoTP: true,
                tpPoints: 5,
                autoSL: true,
                slPoints: 3
            },
            medium: {
                name: 'Medium',
                lots: 5,
                orderType: 'MARKET',
                autoTP: true,
                tpPoints: 10,
                autoSL: true,
                slPoints: 5
            },
            full: {
                name: 'Full',
                lots: 10,
                orderType: 'LIMIT',
                limitOffset: -2,  // 2 points below current price
                autoTP: true,
                tpPoints: 15,
                autoSL: true,
                slPoints: 8
            }
        };
        
        function applyPreset(presetName) {
            const preset = ENTRY_PRESETS[presetName];
            if (!preset) return;
            
            // Update quantity
            state.quantity = preset.lots;
            document.getElementById('qtyValue').textContent = preset.lots;
            
            // Update order type
            state.orderType = preset.orderType;
            const orderTypeToggle = document.getElementById('orderTypeToggle');
            orderTypeToggle.textContent = preset.orderType;
            orderTypeToggle.classList.toggle('active', preset.orderType === 'LIMIT');
            
            // Show/hide limit price input
            const limitContainer = document.getElementById('limitPriceContainer');
            if (preset.orderType === 'LIMIT') {
                limitContainer.style.display = 'block';
            } else {
                limitContainer.style.display = 'none';
            }
            
            // Update auto TP/SL settings
            if (preset.autoTP || preset.autoSL) {
                state.autoTPEnabled = true;
                document.getElementById('enableAutoTPSL').checked = true;
                document.getElementById('autoTPPoints').disabled = false;
                document.getElementById('autoSLPoints').disabled = false;
                
                if (preset.tpPoints) {
                    state.autoTPPoints = preset.tpPoints;
                    document.getElementById('autoTPPoints').value = preset.tpPoints;
                }
                if (preset.slPoints) {
                    state.autoSLPoints = preset.slPoints;
                    document.getElementById('autoSLPoints').value = preset.slPoints;
                }
            }
            
            // Highlight active preset
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            logToConsole(`⚡ Applied preset: ${preset.name} (${preset.lots}L, ${preset.orderType}, TP +${preset.tpPoints}pts)`, 'info');
            showToast(`⚡ ${preset.name} preset applied`, 'success');
        }
        
        // ========== PHASE 2: LADDER ORDER SYSTEM ==========
        
        let ladderPanelVisible = false;
        
        function toggleLadderPanel() {
            ladderPanelVisible = !ladderPanelVisible;
            const panel = document.getElementById('ladderPanel');
            panel.style.display = ladderPanelVisible ? 'block' : 'none';
            
            if (ladderPanelVisible) {
                updateLadderSummary();
            }
        }
        
        function getLadderLevels() {
            const levels = [];
            document.querySelectorAll('.ladder-level').forEach(levelEl => {
                const price = parseFloat(levelEl.querySelector('.ladder-price').value) || 0;
                const qty = parseInt(levelEl.querySelector('.ladder-qty').value) || 0;
                const autoTP = levelEl.querySelector('.ladder-auto-tp').checked;
                
                if (price > 0 && qty > 0) {
                    levels.push({ price, qty, autoTP });
                }
            });
            return levels;
        }
        
        function updateLadderSummary() {
            const levels = getLadderLevels();
            
            let totalLots = 0;
            let weightedSum = 0;
            
            levels.forEach(level => {
                totalLots += level.qty;
                weightedSum += level.price * level.qty;
            });
            
            const avgEntry = totalLots > 0 ? (weightedSum / totalLots) : 0;
            
            document.getElementById('ladderTotalLots').textContent = totalLots;
            document.getElementById('ladderAvgEntry').textContent = avgEntry > 0 ? `₹${avgEntry.toFixed(2)}` : '--';
        }
        
        // Auto-fill ladder prices based on selected strike's current price
        function autoFillLadder() {
            // Get selected row or ATM
            const rows = optionChainDomCache.rows.length
                ? optionChainDomCache.rows
                : Array.from(document.querySelectorAll('#optionChainBody tr'));
            let selectedRow = selectedRowEl;
            if (!selectedRow) {
                selectedRow = rows.find(row => row.classList.contains('atm')) || rows[0];
            }
            if (!selectedRow) return;
            
            if (!selectedRow) {
                showToast('Select a strike first', 'error');
                return;
            }
            
            // Get current LTP from the selected row (CE side)
            const cePrice = selectedRow.querySelector('td.price[data-type="ce"]');
            const currentPrice = cePrice ? parseFloat(cePrice.textContent) : 0;
            
            if (currentPrice <= 0) {
                showToast('No price available', 'error');
                return;
            }
            
            // Fill ladder levels with decreasing prices
            const priceInputs = document.querySelectorAll('.ladder-price');
            const offsets = [0, -5, -10]; // Price offsets for each level
            
            priceInputs.forEach((input, index) => {
                if (index < offsets.length) {
                    input.value = (currentPrice + offsets[index]).toFixed(2);
                }
            });
            
            updateLadderSummary();
            showToast('Ladder prices auto-filled', 'success');
        }
        
        async function placeLadderOrder(action) {
            const levels = getLadderLevels();
            
            if (levels.length === 0) {
                showToast('Add at least one ladder level', 'error');
                return;
            }
            
            // Get selected strike
            const rows = optionChainDomCache.rows.length
                ? optionChainDomCache.rows
                : Array.from(document.querySelectorAll('#optionChainBody tr'));
            let selectedRow = selectedRowEl;
            if (!selectedRow) {
                selectedRow = rows.find(row => row.classList.contains('atm')) || rows[0];
            }
            if (!selectedRow) return;
            
            if (!selectedRow) {
                showToast('Select a strike first', 'error');
                return;
            }
            
            const strike = parseFloat(selectedRow.dataset.strike);
            const chainItem = state.optionChainData.find(x => x.strike === strike);
            
            if (!chainItem) {
                showToast('Strike data not found', 'error');
                return;
            }
            
            // Determine which option type based on action (CE for BUY, PE for SELL typically)
            // But user might want to buy PE or sell CE, so we'll use CE by default
            const optionData = chainItem.ce;
            const symbol = optionData.symbol;
            const lotsize = optionData.lotsize || 15;
            const exchange = state.selectedIndex === 'SENSEX' ? 'BFO' : 'NFO';
            
            logToConsole(`📶 Placing ladder order: ${action} ${levels.length} levels for ${symbol}`, 'info');
            showToast(`Placing ${levels.length} ladder orders...`, 'info');
            
            let successCount = 0;
            let failCount = 0;
            
            for (const level of levels) {
                try {
                    const orderData = {
                        apikey: state.apiKey,
                        strategy: 'scalping_ladder',
                        exchange: exchange,
                        symbol: symbol,
                        action: action,
                        quantity: String(level.qty * lotsize),
                        pricetype: 'LIMIT',
                        product: 'MIS',
                        price: level.price.toFixed(2),
                        trigger_price: '0',
                        disclosed_quantity: '0'
                    };
                    
                    const response = await fetch('/api/v1/placeorder', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(orderData)
                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        successCount++;
                        logToConsole(`✅ Ladder L${levels.indexOf(level) + 1}: ${action} ${level.qty}L @ ₹${level.price.toFixed(2)}`, 'success');
                    } else {
                        failCount++;
                        logToConsole(`❌ Ladder L${levels.indexOf(level) + 1} failed: ${result.message}`, 'error');
                    }
                } catch (error) {
                    failCount++;
                    logToConsole(`❌ Ladder error: ${error.message}`, 'error');
                }
                
                // Small delay between orders
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            showToast(`Ladder: ${successCount} placed, ${failCount} failed`, successCount > 0 ? 'success' : 'error');
            
            // Refresh positions
            setTimeout(() => loadPositions(), 1500);
        }
        
        function saveLadderTemplate() {
            const levels = getLadderLevels();
            if (levels.length === 0) {
                showToast('No levels to save', 'error');
                return;
            }
            
            const template = {
                levels: levels,
                savedAt: new Date().toISOString()
            };
            
            localStorage.setItem('ladder_template', JSON.stringify(template));
            showToast('Ladder template saved', 'success');
        }
        
        function loadLadderTemplate() {
            const saved = localStorage.getItem('ladder_template');
            if (!saved) {
                showToast('No saved template', 'info');
                return;
            }
            
            try {
                const template = JSON.parse(saved);
                const levelEls = document.querySelectorAll('.ladder-level');
                
                template.levels.forEach((level, index) => {
                    if (index < levelEls.length) {
                        levelEls[index].querySelector('.ladder-price').value = level.price;
                        levelEls[index].querySelector('.ladder-qty').value = level.qty;
                        levelEls[index].querySelector('.ladder-auto-tp').checked = level.autoTP;
                    }
                });
                
                updateLadderSummary();
                showToast('Template loaded', 'success');
            } catch (error) {
                showToast('Failed to load template', 'error');
            }
        }
        
        // ========== PHASE 2: MARKET CONTEXT INDICATORS ==========
        
        function updateMarketContext() {
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const day = now.getDay();
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            
            // Time indicator
            const timeIndicator = document.getElementById('timeIndicator');
            timeIndicator.textContent = `⏰ ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            
            // Day indicator
            const dayIndicator = document.getElementById('dayIndicator');
            dayIndicator.textContent = `📅 ${dayNames[day]}`;
            
            // Session indicator
            const sessionIndicator = document.getElementById('sessionIndicator');
            
            if (hours < 9 || (hours === 9 && minutes < 15)) {
                sessionIndicator.textContent = '🔴 Pre-Market';
                sessionIndicator.className = 'context-badge danger';
            } else if (hours >= 15 && minutes >= 30) {
                sessionIndicator.textContent = '🔴 Market Closed';
                sessionIndicator.className = 'context-badge danger';
            } else if (hours >= 14) {
                sessionIndicator.textContent = '🟢 Prime Scalping';
                sessionIndicator.className = 'context-badge prime';
            } else if (hours >= 9 && hours < 10) {
                sessionIndicator.textContent = '🟡 Opening Hour';
                sessionIndicator.className = 'context-badge caution';
            } else {
                sessionIndicator.textContent = '🟢 Market Open';
                sessionIndicator.className = 'context-badge prime';
            }
            
            // Add expiry day warning
            if (day === 4) { // Thursday
                dayIndicator.className = 'context-badge caution';
                dayIndicator.textContent = '📅 Thu (Expiry)';
            } else if (day === 3) { // Wednesday
                dayIndicator.className = 'context-badge caution';
                dayIndicator.textContent = '📅 Wed (Pre-Exp)';
            }
        }
        
        // Update market context every minute
        setInterval(updateMarketContext, 60000);
        
        // Add event listeners for ladder inputs
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.ladder-price, .ladder-qty').forEach(input => {
                input.addEventListener('input', updateLadderSummary);
            });
            
            // Initial market context update
            updateMarketContext();
        });

        // UI Update Functions
        function updateIndexInfo(data) {
            elements.indexName.textContent = data.underlying;
            elements.indexLTP.textContent = data.underlying_ltp.toFixed(2);
            elements.atmStrike.textContent = data.atm_strike;

            const change = data.underlying_ltp - data.underlying_prev_close;
            const changePct = ((change / data.underlying_prev_close) * 100).toFixed(2);
            elements.indexChange.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${change >= 0 ? '+' : ''}${changePct}%)`;
            elements.indexChange.className = `index-change ${change >= 0 ? 'positive' : 'negative'}`;
        }

        function renderOptionChain(chain) {
            if (!chain || chain.length === 0) {
                elements.optionChainBody.innerHTML = '<tr><td colspan="5" style="padding: 40px;">No data available</td></tr>';
                rebuildOptionChainCache([]);
                return;
            }

            elements.optionChainBody.innerHTML = chain.map(item => {
                const ce = item.ce || {};
                const pe = item.pe || {};
                const isATM = ce.label === 'ATM';
                const rowClass = isATM ? 'atm' : (ce.label?.includes('ITM') ? 'itm' : 'otm');

                return `
                    <tr class="${rowClass}" data-strike="${item.strike}">
                        <td class="price" data-symbol="${ce.symbol}" data-type="ce">${ce.ltp || '-'}</td>
                        <td>
                            <button class="action-btn buy" onclick="handleOrderClick('${ce.symbol}', 'BUY', 'CE', ${item.strike}, '${ce.label}')" title="Buy Call">BUY</button>
                            <button class="action-btn sell" onclick="handleOrderClick('${ce.symbol}', 'SELL', 'CE', ${item.strike}, '${ce.label}')" title="Sell Call">SELL</button>
                        </td>
                        <td class="strike-price" style="font-weight: 800; color: ${isATM ? '#00ff88' : 'inherit'};">
                            <div class="strike-main">
                                <span>${item.strike}</span>
                                <button class="action-btn chart chart-launch" onclick="openChartSplit('${ce.symbol}', '${pe.symbol}', ${item.strike})" title="Open Split Chart">📊</button>
                                <button class="action-btn chart chart-launch auto-launch" onclick="openAutoTradeSplit('${ce.symbol}', '${pe.symbol}', ${item.strike})" title="Open Auto Trade">AUTO</button>
                            </div>
                            ${isATM ? '<span class="atm-label">ATM</span>' : ''}
                        </td>
                        <td>
                            <button class="action-btn buy" onclick="handleOrderClick('${pe.symbol}', 'BUY', 'PE', ${item.strike}, '${pe.label}')" title="Buy Put">BUY</button>
                            <button class="action-btn sell" onclick="handleOrderClick('${pe.symbol}', 'SELL', 'PE', ${item.strike}, '${pe.label}')" title="Sell Put">SELL</button>
                        </td>
                        <td class="price" data-symbol="${pe.symbol}" data-type="pe">${pe.ltp || '-'}</td>
                    </tr>
                `;
            }).join('');
            rebuildOptionChainCache(chain);
            bindOptionChainSelection();
            syncDepthTarget();
        }

        // Strike navigation with W/S keys
        function moveStrikeSelection(direction) {
            const rows = optionChainDomCache.rows.length
                ? optionChainDomCache.rows
                : Array.from(document.querySelectorAll('#optionChainBody tr'));
            let selectedRow = selectedRowEl;
            if (rows.length === 0) return;

            if (!selectedRow) {
                // No selection, select ATM
                selectedRow = rows.find(row => row.classList.contains('atm')) || rows[0];
                if (selectedRow) {
                    selectedRow.classList.add('selected');
                    state.selectedStrike = parseFloat(selectedRow.dataset.strike);
                    selectedRowEl = selectedRow;
                    syncDepthTarget();
                }
                return;
            }

            const currentIndex = rows.indexOf(selectedRow);
            const newIndex = currentIndex + direction;

            if (newIndex >= 0 && newIndex < rows.length) {
                selectedRow.classList.remove('selected');
                rows[newIndex].classList.add('selected');
                state.selectedStrike = parseFloat(rows[newIndex].dataset.strike);
                selectedRowEl = rows[newIndex];

                // Scroll into view if needed
                rows[newIndex].scrollIntoView({ behavior: 'auto', block: 'nearest' });

                syncDepthTarget();
                logToConsole(`Moved to strike: ${state.selectedStrike}`, 'info');
            }
        }

        function switchPositionTab(tab) {
            state.activePositionTab = tab;

            // Update tab styles
            document.getElementById('openTab').classList.toggle('active', tab === 'open');
            document.getElementById('closedTab').classList.toggle('active', tab === 'closed');

            // Re-render positions
            renderPositions();
            logToConsole(`Switched to ${tab} positions tab`, 'info');
        }

        // Get best available price for a position symbol
        function getPositionPrice(symbol) {
            // Priority 1: WebSocket real-time price
            const wsPrice = state.prices.get(symbol);
            if (wsPrice && wsPrice > 0) return wsPrice;

            // Priority 2: Option chain data (snapshot, updated by WebSocket)
            const cachedPrice = optionChainPriceMap.get(symbol);
            if (cachedPrice && cachedPrice > 0) return cachedPrice;

            for (const strike of state.optionChainData) {
                if (strike.ce?.symbol === symbol) {
                    const p = parseFloat(strike.ce.ltp) || 0;
                    if (p > 0) return p;
                }
                if (strike.pe?.symbol === symbol) {
                    const p = parseFloat(strike.pe.ltp) || 0;
                    if (p > 0) return p;
                }
            }

            return null;  // No price available
        }

        // Fetch LTPs via quotes API for positions missing WebSocket prices
        async function fetchPositionPrices() {
            const openPositions = state.positions.filter(p => parseInt(p.quantity) !== 0);
            if (openPositions.length === 0) return;

            // Find symbols without a price in state.prices
            const missing = openPositions.filter(p => {
                const price = state.prices.get(p.symbol);
                return !price || price <= 0;
            });

            if (missing.length === 0) return;

            // Build symbols list for multiquotes API
            const symbols = missing.map(p => ({ symbol: p.symbol, exchange: p.exchange }));

            try {
                const result = await apiCall('/api/v1/multiquotes', { symbols: symbols });
                if (result.status === 'success' && result.results) {
                    let updated = 0;
                    for (const item of result.results) {
                        if (item.data && item.symbol) {
                            const ltp = parseFloat(item.data.ltp) || parseFloat(item.data.last_price) || 0;
                            if (ltp > 0) {
                                state.prices.set(item.symbol, ltp);
                                updated++;
                            }
                        }
                    }
                    if (updated > 0) {
                        renderPositions();  // Re-render with fresh prices
                    }
                }
            } catch (e) {
                console.error('Error fetching position prices:', e);
            }
        }

        let lastOpenPositionCount = 0;

        function renderPositions() {
            if (!state.positions || state.positions.length === 0) {
                elements.positionsContainer.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No positions</div>';
                state.totalPnl = 0;
                state.openPnl = 0;
                elements.totalPnL.textContent = '₹0';
                if (lastOpenPositionCount !== 0) {
                    resetProfitProtection();
                    lastOpenPositionCount = 0;
                }
                return;
            }

            // Filter positions based on active tab
            const filteredPositions = state.positions.filter(position => {
                const qty = parseInt(position.quantity) || 0;
                if (state.activePositionTab === 'open') {
                    return qty !== 0;  // Open positions
                } else {
                    return qty === 0;  // Closed positions (today's realized P&L)
                }
            });

            if (filteredPositions.length === 0) {
                const message = state.activePositionTab === 'open' ? 'No open positions' : 'No closed positions today';
                elements.positionsContainer.innerHTML = `<div style="color: var(--text-secondary); text-align: center; padding: 20px;">${message}</div>`;
                if (state.activePositionTab === 'open') {
                    state.totalPnl = 0;
                    elements.totalPnL.textContent = '₹0';
                }
                return;
            }

            // Calculate TOTAL P&L from ALL positions (open + closed) and OPEN P&L
            let totalPnl = 0;
            let openPnl = 0;
            let openCount = 0;
            const openSymbols = new Set();

            // Include ALL positions for total calculation
            state.positions.forEach(position => {
                const qty = parseInt(position.quantity) || 0;

                if (qty === 0) {
                    // Closed position - use broker-reported realized PnL (primary)
                    const apiPnl = parseFloat(position.pnl) || 0;
                    totalPnl += apiPnl;
                } else {
                    // Open position - calculate unrealized P&L using best available price
                    const avgPrice = parseFloat(position.average_price) || 0;
                    const currentPrice = getPositionPrice(position.symbol) || avgPrice;
                    const pnl = (currentPrice - avgPrice) * qty;
                    totalPnl += pnl;
                    openPnl += pnl;
                    openCount++;
                    if (position.symbol) openSymbols.add(position.symbol);
                }
            });

            state.totalPnl = totalPnl;
            state.openPnl = openPnl;

            if (openCount === 0 && lastOpenPositionCount !== 0) {
                resetProfitProtection();
            } else if (openCount > 0 && lastOpenPositionCount === 0) {
                resetProfitProtection();
                state.highestPnl = openPnl || 0;
            }
            lastOpenPositionCount = openCount;

            if (state.perTradeExitPending && state.perTradeExitPending.size > 0) {
                for (const symbol of state.perTradeExitPending) {
                    if (!openSymbols.has(symbol)) {
                        state.perTradeExitPending.delete(symbol);
                    }
                }
            }

            updateLivePnlDisplay();
            checkPnlLimits();

            // Render positions
            elements.positionsContainer.innerHTML = filteredPositions.map(position => {
                const qty = parseInt(position.quantity) || 0;
                const avgPrice = parseFloat(position.average_price) || 0;
                const currentPrice = getPositionPrice(position.symbol) || avgPrice;

                // For closed positions, use broker-reported realized PnL
                let pnl;
                if (qty === 0) {
                    pnl = parseFloat(position.pnl) || 0;
                } else {
                    pnl = (currentPrice - avgPrice) * qty;
                }

                const pnlClass = pnl >= 0 ? 'positive' : 'negative';

                // Only show EXIT button for open positions
                const exitButton = qty !== 0
                    ? `<button class="exit-btn" onclick="exitPosition('${position.symbol}', '${position.quantity}')">EXIT</button>`
                    : '';

                // Show virtual TP/SL targets if active
                const tpsl = state.virtualTPSL.get(position.symbol);
                const tpslRow = (tpsl && qty !== 0) ? `<div style="font-size:10px; padding:2px 8px; color:var(--text-secondary);">TP <span style="color:#22c55e">₹${tpsl.tpPrice.toFixed(2)}</span> | SL <span style="color:#ef4444">₹${tpsl.slPrice.toFixed(2)}</span></div>` : '';

                return `
                    <div class="position-item">
                        <div class="position-info">
                            <div class="position-symbol">${position.symbol}</div>
                            <div class="position-qty">${qty === 0 ? 'CLOSED' : (qty > 0 ? 'LONG' : 'SHORT')} ${Math.abs(qty)}</div>
                            <div class="position-pnl ${pnlClass}">₹${pnl.toFixed(2)}</div>
                        </div>
                        ${tpslRow}
                        ${exitButton}
                    </div>
                `;
            }).join('');

            const pnlClass = totalPnl >= 0 ? 'positive' : 'negative';
            elements.totalPnL.className = pnlClass;
            elements.totalPnL.textContent = `₹${totalPnl.toFixed(2)}`;
        }

        // Throttle position re-renders (only update every 500ms max)
        let lastPositionUpdate = 0;
        let positionUpdateTimer = null;

        function updatePrice(data) {
            // Handle both formats: direct {symbol, ltp} and nested {symbol, data: {ltp}}
            const rawLtp = data.ltp ?? data.data?.ltp;
            const symbol = data.symbol;

            const ltp = parseFloat(rawLtp);
            if (!Number.isFinite(ltp) || ltp <= 0 || !symbol) return; // Skip if no valid price data

            const prev = state.prices.get(symbol);
            state.prices.set(symbol, ltp);
            optionChainPriceMap.set(symbol, ltp);
            updatePriceTimestamp(symbol);

            if (prev === ltp) {
                return;
            }

            // Check virtual TP/SL levels on every tick
            checkVirtualTPSLScalping(symbol, ltp);

            // Update option chain prices
            const formatted = ltp.toFixed(2);
            const priceElements = optionChainDomCache.priceCellMap.get(symbol) || [];
            if (priceElements.length > 0) {
                for (const el of priceElements) {
                    if (el.textContent === formatted) continue;
                    if (!CONFIG.performanceMode.disablePriceAnimations) {
                        const oldPrice = parseFloat(el.textContent) || 0;
                        if (ltp > oldPrice) {
                            el.classList.add('price-up');
                            setTimeout(() => el.classList.remove('price-up'), 500);
                        } else if (ltp < oldPrice) {
                            el.classList.add('price-down');
                            setTimeout(() => el.classList.remove('price-down'), 500);
                        }
                    }
                    el.textContent = formatted;
                }
            } else {
                const fallbackElements = document.querySelectorAll(`[data-symbol="${symbol}"]`);
                fallbackElements.forEach(el => {
                    if (el.textContent === formatted) return;
                    if (!CONFIG.performanceMode.disablePriceAnimations) {
                        const oldPrice = parseFloat(el.textContent) || 0;
                        if (ltp > oldPrice) {
                            el.classList.add('price-up');
                            setTimeout(() => el.classList.remove('price-up'), 500);
                        } else if (ltp < oldPrice) {
                            el.classList.add('price-down');
                            setTimeout(() => el.classList.remove('price-down'), 500);
                        }
                    }
                    el.textContent = formatted;
                });
            }

            // Update index if it's the index symbol
            if (symbol === state.selectedIndex) {
                elements.indexLTP.textContent = formatted;
                const ts = data.data?.timestamp || data.timestamp || Date.now();
                updateUnderlyingMetrics(ltp, ts);
            }

            if (symbol === state.depthSymbol) {
                const ts = data.data?.timestamp || data.timestamp || Date.now();
                updateGreeksProxy(ltp, ts);
            }

            // Throttle position P&L updates (max once per 500ms)
            const now = Date.now();
            if (now - lastPositionUpdate < 500) {
                // Schedule update for later if not already scheduled
                if (!positionUpdateTimer) {
                    positionUpdateTimer = setTimeout(() => {
                        renderPositions();
                        lastPositionUpdate = Date.now();
                        positionUpdateTimer = null;
                    }, 500);
                }
            } else {
                renderPositions();
                lastPositionUpdate = now;
            }
        }

        // Event Handlers
        async function handleConnect() {
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) {
                showToast('Please enter your API key', 'error');
                return;
            }

            state.apiKey = apiKey;
            localStorage.setItem('openalgo_api_key', apiKey);

            // Ensure WebSocket URL is fetched from server before connecting
            try {
                const configResp = await fetch('/scalping/config');
                const configData = await configResp.json();
                if (configData.wsUrl) {
                    CONFIG.wsUrl = configData.wsUrl;
                }
                console.log('WebSocket URL:', CONFIG.wsUrl);
            } catch (e) {
                console.warn('Config fetch failed, using default:', CONFIG.wsUrl);
            }

            connectWebSocket();
        }

        function handleIndexChange() {
            state.selectedIndex = elements.indexSelect.value;
            elements.indexName.textContent = state.selectedIndex;
            if (state.connected) {
                loadExpiries();
            }
        }

        function handleExpiryChange() {
            state.selectedExpiry = elements.expirySelect.value;
            if (state.connected) {
                loadOptionChain();
            }
        }

        function adjustQuantity(delta) {
            state.quantity = Math.max(1, state.quantity + delta);
            elements.qtyValue.textContent = state.quantity;
        }

        function toggleOrderType() {
            state.orderType = state.orderType === 'MARKET' ? 'LIMIT' : 'MARKET';
            elements.orderTypeToggle.textContent = state.orderType;
            elements.orderTypeToggle.classList.toggle('active');

            // Show/hide limit price input
            const limitContainer = document.getElementById('limitPriceContainer');
            if (state.orderType === 'LIMIT') {
                limitContainer.style.display = 'block';
                document.getElementById('limitPrice').focus();
            } else {
                limitContainer.style.display = 'none';
            }
        }

        function toggleHotkeys() {
            state.hotkeysEnabled = !state.hotkeysEnabled;
            elements.hotkeyToggle.textContent = `Hotkeys: ${state.hotkeysEnabled ? 'ON' : 'OFF'}`;
            elements.hotkeyToggle.classList.toggle('active');
            elements.hotkeyIndicator.classList.toggle('hidden', !state.hotkeysEnabled);
        }

        function handleHotkey(e) {
            // Console toggle with Ctrl + ` (backtick)
            if (e.ctrlKey && e.key === '`') {
                e.preventDefault();
                toggleConsole();
                return;
            }

            if (!state.hotkeysEnabled || !state.connected) return;

            // Find selected row (or fall back to ATM)
            const rows = optionChainDomCache.rows.length
                ? optionChainDomCache.rows
                : Array.from(document.querySelectorAll('#optionChainBody tr'));
            let selectedRow = selectedRowEl;
            if (!selectedRow) {
                selectedRow = rows.find(row => row.classList.contains('atm')) || rows[0];
            }
            if (!selectedRow) return;

            if (!selectedRow && !['F6', 'F7', 'w', 'W', 's', 'S'].includes(e.key)) return;

            const strike = selectedRow ? parseFloat(selectedRow.dataset.strike) : null;
            const chainItem = state.optionChainData.find(x => x.strike === strike);

            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (chainItem && chainItem.ce) {
                        handleOrderClick(chainItem.ce.symbol, 'BUY', 'CE', strike, chainItem.ce.label);
                    }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (chainItem && chainItem.pe) {
                        handleOrderClick(chainItem.pe.symbol, 'BUY', 'PE', strike, chainItem.pe.label);
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (chainItem && chainItem.ce) {
                        handleOrderClick(chainItem.ce.symbol, 'SELL', 'CE', strike, chainItem.ce.label);
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (chainItem && chainItem.pe) {
                        handleOrderClick(chainItem.pe.symbol, 'SELL', 'PE', strike, chainItem.pe.label);
                    }
                    break;
                case 'F6':
                    e.preventDefault();
                    closeAllPositions();
                    break;
                case 'w':
                case 'W':
                    e.preventDefault();
                    moveStrikeSelection(-1);  // Move up
                    break;
                case 's':
                case 'S':
                    e.preventDefault();
                    moveStrikeSelection(1);   // Move down
                    break;
                case 'F7':
                    e.preventDefault();
                    showToast('Close all orders feature coming soon', 'info');
                    break;
            }
        }

        function handleOrderClick(symbol, action, optionType, strike, offset) {
            if (optionType) {
                state.chartSidePreference = optionType.toUpperCase();
            }
            placeOrder(symbol, action, optionType, strike, offset);
        }

        // Cancel all open orders for a specific symbol (TP/SL cleanup before closing)
        async function cancelOpenOrdersForSymbol(symbol) {
            try {
                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });
                const result = await response.json();
                if (result.status !== 'success' || !result.data || !result.data.orders) {
                    console.warn('Could not fetch orderbook for cancel:', result);
                    return;
                }

                const openOrders = result.data.orders.filter(o =>
                    o.symbol === symbol &&
                    (o.order_status || '').toLowerCase() === 'open'
                );

                if (openOrders.length === 0) return;

                logToConsole(`Cancelling ${openOrders.length} open order(s) for ${symbol}`, 'warn');

                const cancelPromises = openOrders.map(order =>
                    fetch('/api/v1/cancelorder', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            apikey: state.apiKey,
                            strategy: 'scalping',
                            orderid: String(order.orderid)
                        })
                    }).then(r => r.json()).then(res => {
                        if (res.status === 'success') {
                            logToConsole(`Cancelled order ${order.orderid} (${order.pricetype} @ ${order.price})`, 'info');
                        } else {
                            console.warn(`Failed to cancel order ${order.orderid}:`, res.message);
                        }
                    }).catch(e => console.error(`Error cancelling order ${order.orderid}:`, e))
                );

                await Promise.all(cancelPromises);

                // Clear virtual TP/SL tracking for this symbol
                state.virtualTPSL.delete(symbol);
            } catch (error) {
                console.error('Error cancelling open orders for symbol:', error);
            }
        }

        async function exitPosition(symbol, quantity) {
            // Parse and validate quantity
            const rawQty = parseInt(quantity);
            if (isNaN(rawQty) || rawQty === 0) {
                logToConsole(`❌ Invalid quantity for ${symbol}`, 'error');
                showToast('Invalid position quantity', 'error');
                return;
            }

            // Clear virtual TP/SL tracking for this symbol
            state.virtualTPSL.delete(symbol);

            // Cancel any remaining open orders for this symbol BEFORE closing
            await cancelOpenOrdersForSymbol(symbol);

            // Find position to calculate P&L before exiting
            const position = state.positions.find(p => p.symbol === symbol);
            if (position) {
                const avgPrice = parseFloat(position.average_price) || 0;
                let currentPrice = null;
                let priceSource = 'unknown';

                // SCALPING PRIORITY: Get the LIVE price at moment of exit

                // Priority 1: WebSocket state (most recent tick)
                const wsPrice = state.prices.get(symbol);
                if (wsPrice) {
                    currentPrice = parseFloat(wsPrice);
                    priceSource = 'WebSocket';
                }

                // Priority 2: DOM element (displayed price, updated by WebSocket)
                if (!currentPrice) {
                    const cachedCells = optionChainDomCache.priceCellMap.get(symbol);
                    const priceElement = cachedCells && cachedCells.length ? cachedCells[0] : null;
                    if (priceElement && priceElement.textContent) {
                        const domPrice = parseFloat(priceElement.textContent);
                        if (domPrice > 0) {
                            currentPrice = domPrice;
                            priceSource = 'DOM/Display';
                        }
                    }
                }

                // Priority 3: Option chain data
                if (!currentPrice) {
                    const cachedPrice = optionChainPriceMap.get(symbol);
                    if (cachedPrice && cachedPrice > 0) {
                        currentPrice = cachedPrice;
                        priceSource = 'OptionChain';
                    } else {
                        for (const strike of state.optionChainData) {
                            if (strike.ce?.symbol === symbol && strike.ce?.ltp) {
                                currentPrice = parseFloat(strike.ce.ltp);
                                priceSource = 'OptionChain';
                                break;
                            }
                            if (strike.pe?.symbol === symbol && strike.pe?.ltp) {
                                currentPrice = parseFloat(strike.pe.ltp);
                                priceSource = 'OptionChain';
                                break;
                            }
                        }
                    }
                }

                // Priority 4: Position API data
                if (!currentPrice) {
                    const apiLtp = parseFloat(position.ltp) || 0;
                    if (apiLtp > 0) {
                        currentPrice = apiLtp;
                        priceSource = 'API';
                    }
                }

                // Last resort: avgPrice (will show 0 P&L)
                if (!currentPrice || currentPrice === 0) {
                    currentPrice = avgPrice;
                    priceSource = 'AvgPrice(0 P&L)';
                    console.warn(`⚠️ No live price for ${symbol} - P&L will be 0`);
                }

                const pnl = (currentPrice - avgPrice) * rawQty;

                // Store P&L as a trade entry
                if (!Array.isArray(state.sessionClosedPnL)) {
                    state.sessionClosedPnL = [];
                }
                state.sessionClosedPnL.push({
                    symbol,
                    pnl,
                    timestamp: new Date().toISOString(),
                    qty: rawQty,
                    entryPrice: avgPrice,
                    exitPrice: currentPrice,
                    source: priceSource
                });
                saveSessionPnL();

                logManualTrade({
                    type: 'EXIT',
                    tradeId: `scalp_${Date.now()}_${symbol}`,
                    symbol,
                    side: symbol.includes('PE') ? 'PE' : (symbol.includes('CE') ? 'CE' : undefined),
                    action,
                    qty: Math.abs(rawQty),
                    price: currentPrice,
                    pnl,
                    reason: 'Manual Exit',
                    entryPrice: avgPrice,
                    exitPrice: currentPrice,
                    priceSource
                });

                console.log(`💰 SCALP P&L:`, {
                    symbol,
                    entry: avgPrice.toFixed(2),
                    exit: currentPrice.toFixed(2),
                    qty: rawQty,
                    pnl: pnl.toFixed(2),
                    source: priceSource
                });
                logToConsole(`💰 ${symbol}: ₹${pnl.toFixed(2)} (${avgPrice.toFixed(2)}→${currentPrice.toFixed(2)} via ${priceSource})`, 'info');
            }

            const action = rawQty > 0 ? 'SELL' : 'BUY';
            const qty = Math.abs(rawQty);

            logToConsole(`Exiting ${action} ${qty} of ${symbol}`, 'info');
            showToast(`Exiting ${symbol}...`, 'info');

            // Determine exchange based on index (fallback to NFO)
            let exchange = 'NFO';
            if (state.selectedIndex === 'SENSEX' || symbol.startsWith('SENSEX') || symbol.startsWith('BANKEX')) {
                exchange = 'BFO';
            }

            const orderData = {
                apikey: state.apiKey,
                strategy: 'scalping',
                exchange: exchange,
                symbol: symbol,
                action: action,
                quantity: String(qty),
                pricetype: 'MARKET',
                product: 'MIS',
                price: '0',
                trigger_price: '0',
                disclosed_quantity: '0'
            };

            try {
                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();
                if (result.status === 'success') {
                    logToConsole(`✅ EXIT ${action} ${qty} of ${symbol}`, 'success');
                    showToast(`✅ Exit order placed for ${symbol}`, 'success');
                    // Refresh positions after short delay
                    setTimeout(loadPositions, 1000);
                } else {
                    logToConsole(`❌ EXIT FAILED: ${result.message}`, 'error');
                    showToast(`❌ Exit failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Exit order error:', error);
                showToast('Exit order failed', 'error');
            }
        }

        // Close all positions
        async function closeAllPositions() {
            console.log('📊 Close All Positions clicked');
            console.log('📊 Total positions in state:', state.positions.length);
            console.log('📊 Positions:', state.positions);

            // Filter only open positions (quantity != 0)
            const openPositions = state.positions.filter(p => parseInt(p.quantity) !== 0);

            console.log('📊 Open positions (qty != 0):', openPositions.length);

            if (!openPositions || openPositions.length === 0) {
                showToast('No open positions to close', 'info');
                console.log('⚠️ No open positions found - refreshing...');
                // Try refreshing positions first
                await loadPositions();
                return;
            }

            showToast(`Closing ${openPositions.length} positions...`, 'info');
            logToConsole(`Closing all ${openPositions.length} positions`, 'warn');

            for (const position of openPositions) {
                await exitPosition(position.symbol, position.quantity);
            }

            // Refresh positions after closing
            setTimeout(() => loadPositions(), 1000);
        }

        // Console Logging
        function logToConsole(message, type = 'info') {
            // Skip logging if performance mode is enabled
            if (CONFIG.performanceMode.disableConsoleLog && type !== 'error') {
                return;
            }

            // Filter: Only show trading-related logs, not WebSocket noise
            const hidePatterns = [
                'WebSocket connected',
                'WebSocket disconnected',
                'Connecting to WebSocket',
                'Cannot subscribe',
                'Authenticated as',
                'Connected successfully',
                'Loading expiries',
                'Loaded.*expiries',
                'Loading option chain',
                'Switched to.*tab',
                'Moved to strike',
                'Total P&L:',
                'Exit called:'
            ];

            // Check if message should be hidden
            const shouldHide = hidePatterns.some(pattern =>
                new RegExp(pattern, 'i').test(message)
            );

            if (shouldHide && type !== 'error') {
                // Still log to browser console for debugging
                console.log(`[${type}] ${message}`);
                return;
            }

            const consoleLog = document.getElementById('consoleLog');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span>${message}`;
            consoleLog.appendChild(entry);
            consoleLog.scrollTop = consoleLog.scrollHeight;

            // Also log to browser console
            console.log(`[${type}] ${message}`);
        }

        // Console functions
        function clearConsole() {
            document.getElementById('consoleLog').innerHTML = '';
            logToConsole('Console cleared', 'info');
        }

        function toggleConsole() {
            const consoleLog = document.getElementById('consoleLog');
            const btn = document.getElementById('consoleToggleBtn');

            if (consoleLog.style.display === 'none') {
                // Show console content
                consoleLog.style.display = 'block';
                btn.textContent = 'Hide';
            } else {
                // Hide console content only (header stays visible)
                consoleLog.style.display = 'none';
                btn.textContent = 'Show';
            }
        }

        // Utility Functions
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Fast mode for scalping
            const duration = CONFIG.performanceMode.fastToasts ? 1000 : 3000;

            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 200);
            }, duration);
        }

        // Start periodic position refresh
        setInterval(() => {
            if (state.connected) {
                loadPositions();
            }
        }, CONFIG.positionUpdateInterval);

        // Initialize on load
        init();
    </script>
</body>

</html>
