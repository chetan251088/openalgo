<!DOCTYPE html>
<!--
╔══════════════════════════════════════════════════════════════════════╗
║                    CHART WINDOW ARCHITECTURE MAP                     ║
║                                                                      ║
║  Self-contained chart trading page (~4100 lines).                    ║
║  Opened as popup from scalping interface. Receives symbol,           ║
║  exchange, API key, lot size via URL params.                         ║
╚══════════════════════════════════════════════════════════════════════╝

STATE OBJECT (const state = {...})
  Core:     symbol, exchange, underlying, optionType, strike, expiry
  Config:   apiKey, quantity, lotSize, orderType ('MARKET'|'LIMIT'|'FAKELIMIT')
  Chart:    chart, candlestickSeries, currentPrice, candles[], pendingCandle
  Orders:   orders Map (orderId → {orderId, action, price, status, priceLine, overlay})
  Triggers: fakeLimitOrders Map (id → {action, triggerPrice, direction, priceLine, overlay, tpPoints, slPoints})
  Position: position, entryPrice, isClosingPosition
  Follow:   followingMode, followingType
  TP/SL:    tpPoints (default 8), slPoints (default 5)
  Profit:   profitProtectionEnabled, securedProfit, highestPnl, totalPnl

KEY GLOBALS (outside state)
  positionTPSL    = {tpPrice, slPrice, tpLine, slLine, tpOverlay, slOverlay}
  positionOverlay = HTML div for the position line
  followPriceLine = chart price line that follows cursor in LIMIT/TRIGGER mode
  openOrdersData  = array from /api/v1/openorders (for orders panel)

SECTIONS & KEY FUNCTIONS (search by name with Grep)
─────────────────────────────────────────────────────
CSS STYLES ............................................. lines 8-970
  .order-line-overlay, .order-close-btn, .trigger-buy/.trigger-sell
  .order-type-btn.active / .active-trigger

HTML LAYOUT ............................................ lines 870-970
  Row 1: Symbol + Price | Row 2: Market context badges
  Row 4: BUY | SELL | MARKET | LIMIT | TRIGGER | Qty ±  | TP [] SL []
  Row 5: Position info + Close button + Profit Protection

INIT & CONFIG .......................................... ~995-1100
  roundToTick(price)       — snap to 0.05 tick
  parseUrlParams()         — reads symbol/exchange/apikey/lotsize from URL
  initChart()              — creates Lightweight Charts instance + indicators

UI SETUP ............................................... ~1195-1340
  updatePnL(), showToast()
  setupEventListeners()    — button handlers, qty ±, TP/SL inputs
  setOrderType(type)       — three-way toggle: MARKET/LIMIT/FAKELIMIT

INTERACTIVE ORDER PLACEMENT ............................ ~1338-1420
  enableFollowMode(action) — creates dashed follow line (green/red/orange)
  disableFollowMode()
  setupChartInteraction()  — subscribeCrosshairMove + subscribeClick
  placeMarketOrder(action) — immediate MARKET at current price
  placeOrderAtPrice(price, action) — POST /api/v1/placeorder, draws order line

FAKE LIMIT (TRIGGER ORDERS) ............................ ~1504-1738
  placeFakeLimitOrder(triggerPrice, action) — stores virtual trigger in Map
  drawFakeLimitLine(price, action, id)     — orange dashed line + overlay
  setupFakeLimitDraggable(overlay, id)     — drag = local only, no API
  cancelFakeLimitOrder(id)                 — remove line + overlay + Map entry
  checkFakeLimitTriggers()                 — called every tick; BUY fires at ltp>=trigger, SELL at ltp<=trigger
  executeFakeLimitOrder(id, order)         — fires MARKET order, draws order line

ORDER LINE MANAGEMENT .................................. ~1740-1930
  drawOrderLine(price, action, orderId) — chart priceLine + HTML overlay + state.orders
  updateOverlayPosition(overlay, price) — keeps overlay at correct Y
  updateAllOverlays()      — repositions all overlays on scroll/resize
  setupDraggable(overlay, orderData) — drag-to-modify with API call
  modifyOrder(orderId, newPrice)     — POST /api/v1/modifyorder

POSITION MANAGEMENT .................................... ~2082-2120
  closeOrder(orderId)      — cancel via /api/v1/cancelorder
  closeAllPositions()      — cancels all orders + fake limits
  updateLivePNL()          — recalculates P&L labels per tick

WEBSOCKET .............................................. ~2144-2210
  connectWebSocket()       — auth → subscribe → handle messages
  handleMarketData(data)   — updates currentPrice, builds candles, calls:
    → updateIndicators(), updateLivePNL(), checkVirtualTPSL(), checkFakeLimitTriggers()

TECHNICAL INDICATORS ................................... ~2209-2356
  calculateEMA(candles, period)
  calculateSupertrend(candles, atrPeriod, mult)
  calculateVWAP(candles)
  updateIndicators()       — redraws EMA9/21, Supertrend, VWAP on chart

VIRTUAL TP/SL (POSITION MONITORING) .................... ~2424-2510
  checkVirtualTPSL()       — checks if price crossed TP/SL levels
  executeVirtualTPSL(type, triggerPrice) — MARKET close + cleanup

OPEN ORDERS PANEL ...................................... ~2512-2700
  toggleOrdersPanel(), fetchOpenOrders(), renderOpenOrders()
  cancelSingleOrder(orderId, symbol)
  removeOrderLineFromChart(orderId)
  closeAllOpenOrders()

ORDER FILL DETECTION ................................... ~2773-2880
  checkOrderFills()        — polls /api/v1/orderbook every 5s
    → detects fills → calculates auto TP/SL → calls fetchAndDisplayPosition()

POSITION DISPLAY + TP/SL LINES ......................... ~2881-3300
  fetchAndDisplayPosition(tpslData) — gets position from /api/v1/positionbook
  updatePositionDisplay(position, tpslData)
  drawPositionLine(entryPrice, action, tpslData) — position line + TP/SL lines
  createTPSLOverlay(price, type, parentAction)   — draggable TP/SL line overlay
  setupTPSLDraggable(overlay, type, parentAction)
  removePositionTPSL(type)
  closePosition()          — POST MARKET close + cancel TP/SL + clear visuals
  cancelTPSLOrders()       — clears TP/SL visual elements
  clearPositionVisuals()   — removes all position-related overlays

PROFIT PROTECTION ...................................... ~3368-3520
  toggleProfitProtection(), checkProfitProtection()
  closePositionAuto(reason), resetProfitProtection()

QUICK ENTRY PRESETS .................................... ~3519-3570

MARKET CONTEXT ......................................... ~3570-3630

CONNECTION HEALTH ...................................... ~3631-3700
  updateConnectionHealth(type, latency)
  fetchWithRetry(url, options, maxRetries)
  Price staleness: updatePriceTimestamp(), getPriceStaleness(), isPriceStale()

ORDER VALIDATION ....................................... ~3738-3800
  validateOrder(orderData, currentPrice)

AUDIT TRAIL ............................................ ~3795-3880
  logAuditEntry(), logOrderPlaced(), logPositionClosed()
  exportAuditTrail(), loadAuditTrail()

PSYCHOLOGY SUPPORT ..................................... ~3880-4090
  analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition)
  checkLossAversion(currentPnl), showLossWarning(), hideLossWarning()

INITIALIZATION ......................................... ~4094
  init()                   — parseUrlParams → initChart → connectWebSocket → start intervals

DATA FLOWS
──────────
  Order Placement:  B/S key → enableFollowMode → click → placeOrderAtPrice → drawOrderLine
  Trigger Order:    B/S key → enableFollowMode → click → placeFakeLimitOrder → drawFakeLimitLine
  Trigger Fire:     tick → checkFakeLimitTriggers → executeFakeLimitOrder → MARKET order → drawOrderLine
  Fill Detection:   5s poll → checkOrderFills → detect fill → auto TP/SL calc → fetchAndDisplayPosition
  TP/SL Trigger:    tick → checkVirtualTPSL → executeVirtualTPSL → MARKET close → clearPositionVisuals
  Price Updates:    WS tick → handleMarketData → build candle → updateIndicators → updateLivePNL
  Profit Protect:   tick → checkProfitProtection → closePositionAuto if profit drops below secured level
-->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Trading Window - OpenAlgo</title>
    <!-- External fonts removed to avoid CSP violations -->
    <style>
        :root {
            --bg-primary: #0b0f14;
            --bg-secondary: #121821;
            --bg-card: rgba(18, 24, 33, 0.92);
            --panel-bg: rgba(14, 19, 26, 0.94);
            --text-primary: #f5f7fb;
            --text-secondary: #9aa8b6;
            --border-color: rgba(143, 162, 182, 0.2);
            --success: #57f59a;
            --danger: #ff6b6b;
            --warning: #ffb020;
            --accent-cyan: #53f2d6;
            --accent-lime: #c7f55d;
            --accent-blue: #5ab0ff;
            --dock-width: 300px;
            --shadow-tight: 0 10px 24px rgba(6, 9, 14, 0.35);
            --border: var(--border-color);
            /* Optimized: Reusable alpha values */
            --alpha-04: rgba(255, 255, 255, 0.04);
            --alpha-05: rgba(255, 255, 255, 0.05);
            --alpha-08: rgba(255, 255, 255, 0.08);
            --alpha-12: rgba(255, 255, 255, 0.12);
            --success-alpha: rgba(0, 255, 136, 0.12);
            --danger-alpha: rgba(255, 107, 107, 0.12);
            --transition-fast: 0.12s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Bahnschrift', 'Segoe UI', sans-serif;
            background:
                radial-gradient(900px 600px at 5% -10%, rgba(83, 242, 214, 0.14), transparent 45%),
                radial-gradient(900px 600px at 95% 0%, rgba(255, 180, 67, 0.16), transparent 45%),
                linear-gradient(160deg, var(--bg-primary) 0%, #0f1723 100%);
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
            overflow: hidden;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--dock-width);
            height: 100vh;
            background: #0e131a;
            border-right: 1px solid var(--border-color);
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            overflow-y: auto;
            contain: layout paint;
            scrollbar-gutter: stable;
            transform: translateZ(0);
        }

        .control-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(83, 242, 214, 0.25);
            border-radius: 999px;
        }

        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .scalp-radar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .scalp-radar-title {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scalp-radar-meter {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .radar-toggle-btn {
            padding: 3px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 9px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .radar-toggle-btn.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.45);
            background: rgba(0, 255, 136, 0.12);
        }

        .scalp-radar.off .scalp-radar-fill {
            width: 0% !important;
        }

        .scalp-radar.off .scalp-radar-label {
            color: var(--text-secondary);
        }

        .scalp-radar-bar {
            width: 110px;
            height: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .scalp-radar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(0, 255, 136, 0.4) 0%, rgba(255, 210, 63, 0.6) 60%, rgba(255, 107, 107, 0.6) 100%);
            transition: width 0.12s ease;
        }

        .scalp-radar-label {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }

        .scalp-radar-label.hot {
            color: var(--success);
        }

        .scalp-radar-label.warm {
            color: var(--warning);
        }

        .scalp-radar-label.cool {
            color: var(--text-secondary);
        }

        .scalp-radar-value {
            font-size: 9px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .symbol-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .current-price {
            font-size: 20px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .current-price .price-value {
            display: inline-block;
            min-width: 70px;
        }

        .side-badge {
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.4px;
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-secondary);
        }

        .side-badge.ce {
            border-color: rgba(83, 242, 214, 0.6);
            color: var(--accent-cyan);
        }

        .side-badge.pe {
            border-color: rgba(255, 176, 32, 0.6);
            color: var(--warning);
        }

        .price-positive {
            color: var(--success);
        }

        .price-negative {
            color: var(--danger);
        }

        .controls-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .dock-section {
            background: #121821;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 8px 10px;
            box-shadow: var(--shadow-tight);
        }

        .depth-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .auto-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .auto-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .auto-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--accent-lime);
            letter-spacing: 0.4px;
        }

        .auto-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .auto-pill {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-size: 9px;
        }

        .auto-pill.off {
            color: var(--text-secondary);
        }

        .auto-pill.on {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .auto-pill.paper {
            color: var(--accent-blue);
            border-color: rgba(90, 176, 255, 0.45);
        }

        .auto-pill.live {
            color: var(--warning);
            border-color: rgba(255, 176, 32, 0.45);
        }

        .auto-pill.server {
            color: var(--accent-cyan);
            border-color: rgba(66, 226, 255, 0.45);
        }

        .auto-backend-pill {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            font-size: 9px;
            letter-spacing: 0.6px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .auto-backend-pill.active {
            color: var(--accent-cyan);
            border-color: rgba(66, 226, 255, 0.45);
        }

        .auto-toggle-btn {
            width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: linear-gradient(120deg, rgba(90, 176, 255, 0.12), rgba(199, 245, 93, 0.12));
            color: var(--text-primary);
            font-weight: 700;
            font-size: 11px;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.2s ease;
        }

        .auto-toggle-btn.active {
            border-color: rgba(0, 255, 136, 0.4);
            background: linear-gradient(120deg, rgba(0, 255, 136, 0.16), rgba(83, 242, 214, 0.16));
        }

        .auto-mode-row {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .auto-mode-group {
            display: flex;
            gap: 6px;
        }

        .auto-mode-btn {
            padding: 5px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
            font-size: 9px;
            text-transform: uppercase;
            cursor: pointer;
            letter-spacing: 0.5px;
        }

        .auto-mode-btn.active {
            color: var(--text-primary);
            border-color: rgba(83, 242, 214, 0.45);
            background: rgba(83, 242, 214, 0.12);
        }

        .auto-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px 8px;
        }

        .auto-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-field input,
        .auto-field select {
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 10px;
        }

        .auto-toggle-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-toggle-row input[type="number"] {
            width: 70px;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 10px;
        }

        .auto-toggle-row input[type="text"],
        .auto-toggle-row select {
            width: 180px;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 10px;
        }

        .auto-mini-btn {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
            font-size: 9px;
            cursor: pointer;
        }

        .auto-reset-btn {
            padding: 2px 6px;
            font-size: 8px;
            margin-left: 6px;
        }

        .auto-mini-btn.primary {
            color: var(--text-primary);
            border-color: rgba(66, 226, 255, 0.45);
            background: rgba(66, 226, 255, 0.12);
        }

        .auto-key-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-key-pill {
            padding: 2px 6px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-key-pill.ok {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .auto-key-pill.miss {
            color: var(--danger);
            border-color: rgba(255, 72, 87, 0.4);
        }

        .auto-toggle-row label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .auto-status-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-status-grid span {
            color: var(--text-primary);
            font-weight: 700;
        }

        .auto-backend-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-backend-grid span {
            color: var(--text-primary);
            font-weight: 700;
        }

        .auto-log {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.03);
        }

        .auto-log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-log-list {
            max-height: 120px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 9px;
        }

        .auto-log-item {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 4px 6px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
        }

        .auto-log-item .tag {
            color: var(--text-primary);
            font-weight: 700;
        }

        .auto-learning {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.03);
        }

        .auto-learning-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-learning-grid span {
            color: var(--text-primary);
            font-weight: 600;
            margin-left: 6px;
        }

        .auto-learning-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .auto-learning-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .auto-learning-actions input[type="number"] {
            width: 70px;
            padding: 4px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 10px;
        }

        .auto-checklist {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.03);
        }

        .auto-hint {
            font-size: 9px;
            color: var(--text-secondary);
        }

        /* Phase 5: New UI Components */
        .auto-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 3px;
            font-size: 9px;
        }

        .auto-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2px 0;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 8px;
        }

        .stat-value {
            font-weight: 700;
            font-size: 10px;
            color: var(--text-primary);
        }

        .stat-green {
            color: #22c55e !important;
        }

        .stat-red {
            color: #ef4444 !important;
        }

        .blink {
            animation: blink-anim 0.5s infinite;
        }

        @keyframes blink-anim {
            50% {
                opacity: 0.3;
            }
        }

        .auto-summary-panel {
            padding: 6px 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.03);
        }

        .auto-summary-panel .auto-log-header {
            margin-bottom: 4px;
        }

        .equity-curve-wrap {
            padding: 4px 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
        }

        .equity-curve-wrap canvas {
            width: 100%;
            display: block;
        }

        .auto-indicators-row {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 4px 8px;
            font-size: 9px;
        }

        .indicator-chip {
            display: flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--border-color);
        }

        .indicator-chip .chip-label {
            color: var(--text-secondary);
            font-size: 8px;
        }

        .indicator-chip .chip-value {
            font-weight: 700;
            font-size: 10px;
        }

        .trail-stage {
            font-weight: 700;
        }

        .trail-stage-0 {
            color: var(--text-secondary);
        }

        .trail-stage-1 {
            color: #f59e0b;
        }

        .trail-stage-2 {
            color: #22c55e;
        }

        .trail-stage-3 {
            color: #3b82f6;
        }

        .trail-stage-4 {
            color: #8b5cf6;
        }

        .trail-stage-5 {
            color: #ef4444;
        }

        .regime-badge {
            font-weight: 700;
            padding: 1px 4px;
            border-radius: 4px;
        }

        .regime-trending {
            color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
        }

        .regime-ranging {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
        }

        .regime-volatile {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
        }

        .regime-unknown {
            color: var(--text-secondary);
        }

        .momentum-gauge {
            width: 60px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .momentum-gauge-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.15s ease;
        }

        .gauge-building {
            background: #f59e0b;
        }

        .gauge-ready {
            background: #22c55e;
        }

        .trade-popup {
            position: absolute;
            top: 60px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 10px;
            font-weight: 700;
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s, transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .trade-popup-fade {
            opacity: 1;
            transform: translateY(0);
        }

        .trade-popup-profit {
            background: rgba(34, 197, 94, 0.9);
            color: #fff;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .trade-popup-loss {
            background: rgba(239, 68, 68, 0.9);
            color: #fff;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .trade-popup-pnl {
            font-size: 18px;
        }

        .trade-popup-detail {
            font-size: 10px;
            font-weight: 400;
            opacity: 0.8;
        }

        .depth-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .depth-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .depth-meta {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-status {
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.04);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .depth-status.live {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .depth-symbol {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .depth-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .depth-level-select,
        .depth-toggle {
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 9px;
            cursor: pointer;
        }

        .depth-toggle.active {
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.4);
        }

        .depth-summary {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-summary span {
            display: block;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-table {
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.2);
        }

        .depth-header-row,
        .depth-row {
            display: grid;
            grid-template-columns: 1.1fr 1fr 1fr 1.1fr;
            gap: 6px;
            padding: 5px 8px;
            font-size: 9px;
            font-variant-numeric: tabular-nums;
        }

        .depth-header-row {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-row {
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .depth-row.selected {
            background: rgba(0, 212, 255, 0.08);
        }

        .depth-bid {
            color: var(--success);
        }

        .depth-ask {
            color: var(--danger);
            text-align: right;
        }

        .depth-price-cell {
            cursor: pointer;
        }

        .depth-rows {
            max-height: 200px;
            overflow: auto;
        }

        .depth-quick {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-selected {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-selected span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .depth-quick-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .depth-modes {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-mode-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-mode-btn {
            padding: 3px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 9px;
            cursor: pointer;
        }

        .depth-mode-btn.active {
            background: rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-color: var(--accent-cyan);
        }

        .tooltip-target {
            position: relative;
        }

        .tooltip-target[data-tooltip]:hover::after,
        .tooltip-target.tooltip-show[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 50%;
            bottom: calc(100% + 6px);
            transform: translateX(-50%);
            background: rgba(15, 20, 27, 0.95);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 9px;
            padding: 5px 7px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 100;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        }

        .depth-reprice {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .depth-reprice-input {
            width: 60px;
            padding: 3px 5px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 9px;
        }

        .depth-signals {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .signal-badge {
            padding: 3px 7px;
            border-radius: 999px;
            font-size: 9px;
            font-weight: 600;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .signal-badge.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .signal-badge.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-score {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .depth-score-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .depth-score-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .depth-score-pill {
            padding: 3px 7px;
            border-radius: 999px;
            font-size: 9px;
            font-weight: 700;
            border: 1px solid transparent;
        }

        .depth-score-pill.hot {
            background: rgba(0, 255, 136, 0.15);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-score-pill.warm {
            background: rgba(255, 210, 63, 0.12);
            color: var(--warning);
            border-color: rgba(255, 210, 63, 0.35);
        }

        .depth-score-pill.cool {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .greeks-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 9px;
            color: var(--text-secondary);
        }

        .greeks-panel span {
            font-weight: 700;
            color: var(--text-primary);
            margin-left: 4px;
        }

        .greeks-panel .hot {
            color: var(--success);
        }

        .greeks-panel .warm {
            color: var(--warning);
        }

        .depth-alert {
            padding: 5px 8px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 600;
            border: 1px solid transparent;
        }

        .depth-alert.neutral {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .depth-alert.buy {
            background: rgba(0, 255, 136, 0.12);
            color: var(--success);
            border-color: rgba(0, 255, 136, 0.35);
        }

        .depth-alert.sell {
            background: rgba(255, 107, 107, 0.12);
            color: var(--danger);
            border-color: rgba(255, 107, 107, 0.35);
        }

        .depth-hint {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .controls-row--actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .controls-row--settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
        }

        .order-type-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .controls-row--settings .divider {
            display: none;
        }

        .controls-row--settings .qty-control,
        .controls-row--settings .tpsl-control {
            justify-content: space-between;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            text-transform: uppercase;
        }

        .order-type-btn {
            padding: 6px 6px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .action-btn {
            padding: 10px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 700;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
        }

        .action-btn.buy {
            background: rgba(87, 245, 154, 0.18);
            border-color: rgba(87, 245, 154, 0.45);
            color: var(--success);
        }

        .action-btn.sell {
            background: rgba(255, 107, 107, 0.18);
            border-color: rgba(255, 107, 107, 0.45);
            color: var(--danger);
        }

        .order-type-btn.active {
            background: var(--accent-lime);
            color: var(--bg-primary);
            font-weight: 600;
        }

        .order-type-btn:hover {
            border-color: var(--accent-cyan);
        }

        /* Order Line Overlays */
        .order-line-overlay {
            position: absolute;
            left: 0;
            right: 0;
            height: 20px;
            /* Larger hit area for dragging */
            margin-top: -10px;
            /* Center on price */
            cursor: ns-resize;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }

        .tpsl-line-overlay {
            position: absolute;
            left: 0;
            right: 0;
            height: 16px;
            margin-top: -8px;
            cursor: ns-resize;
            z-index: 9;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 6px;
            padding: 0 10px;
            pointer-events: auto;
        }

        .tpsl-line-overlay:hover {
            background: rgba(255, 255, 255, 0.04);
        }

        .tpsl-line-overlay.dragging {
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.25);
        }

        .tpsl-close {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-secondary);
            font-size: 10px;
            line-height: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
        }

        .tpsl-close:hover {
            color: var(--text-primary);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .order-line-overlay:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .order-line-overlay.dragging {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .order-line-label {
            font-size: 11px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 3px;
            font-weight: 600;
            pointer-events: none;
        }

        .order-line-label.buy {
            color: var(--success);
        }

        .order-line-label.sell {
            color: var(--danger);
        }

        .order-line-label.trigger-buy,
        .order-line-label.trigger-sell {
            color: var(--warning);
        }

        .order-line-overlay.fake-limit:hover {
            background: rgba(255, 165, 0, 0.08);
        }

        .order-line-overlay.fake-limit.dragging {
            background: rgba(255, 165, 0, 0.15);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.4);
        }

        .order-type-btn.active-trigger {
            background: var(--warning);
            color: var(--bg-primary);
            font-weight: 600;
        }

        .pnl-label {
            font-size: 11px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 3px;
            font-weight: 600;
            pointer-events: none;
        }

        .pnl-label.profit {
            color: #00ff88;
        }

        .pnl-label.loss {
            color: #ff4560;
        }

        .order-close-btn {
            background: rgba(255, 69, 96, 0.2);
            border: 1px solid #ff4560;
            color: #ff4560;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .order-close-btn:hover {
            background: #ff4560;
            color: white;
        }

        /* Order Controls Popup */
        .order-controls-popup {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .order-controls-popup button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .set-tp-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #000;
        }

        .set-sl-btn {
            background: linear-gradient(135deg, #ff4560 0%, #cc3748 100%);
            color: white;
        }

        .close-order-btn {
            background: var(--danger);
            color: white;
        }

        .btn-buy {
            background: rgba(87, 245, 154, 0.2);
            color: var(--bg-primary);
            border: 1px solid rgba(87, 245, 154, 0.45);
        }

        .btn-buy:hover {
            border-color: rgba(87, 245, 154, 0.7);
        }

        .btn-sell {
            background: rgba(255, 107, 107, 0.2);
            color: var(--text-primary);
            border: 1px solid rgba(255, 107, 107, 0.45);
        }

        .btn-sell:hover {
            border-color: rgba(255, 107, 107, 0.7);
        }

        .btn-toggle {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-toggle.active {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            border-color: var(--accent-cyan);
        }

        .divider {
            width: 1px;
            height: 30px;
            background: var(--border-color);
        }

        .qty-control {
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .qty-btn {
            width: 26px;
            height: 26px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qty-value {
            min-width: 50px;
            text-align: center;
            font-weight: 600;
        }

        .tpsl-control {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-secondary);
            padding: 4px 6px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .tpsl-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tpsl-btn {
            width: 22px;
            height: 22px;
            font-size: 14px;
        }

        .tpsl-unit {
            font-size: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .tpsl-control label {
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .tpsl-input {
            width: 36px;
            padding: 3px 2px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            font-weight: 600;
            text-align: center;
        }

        .tpsl-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .price-input {
            width: 120px;
            padding: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .price-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .position-info {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 13px;
        }

        .position-label {
            color: var(--text-secondary);
        }

        .position-value {
            font-weight: 600;
        }

        .pnl-display {
            font-weight: 700;
            font-size: 16px;
        }

        .btn-close-position {
            background: var(--danger);
            color: white;
            padding: 8px 16px;
            font-size: 12px;
        }

        /* Indicator Legend */
        .indicator-legend {
            position: absolute;
            top: 8px;
            left: 10px;
            z-index: 10;
            display: flex;
            gap: 12px;
            font-size: 11px;
            font-weight: 600;
            background: rgba(14, 19, 26, 0.8);
            border: 1px solid var(--border-color);
            padding: 4px 10px;
            border-radius: 4px;
            pointer-events: none;
        }

        .ind-item {
            opacity: 0.85;
        }

        .side-toggle {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .side-btn {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
        }

        .side-btn.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        /* Chart Container */
        #chart-container {
            position: absolute;
            top: 0;
            left: var(--dock-width);
            right: 0;
            bottom: 0;
        }

        .chart-split {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        .chart-pane {
            position: relative;
            background: #0a0e27;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
        }

        .chart-pane.active {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 1px rgba(83, 242, 214, 0.35);
        }

        .chart-pane-label {
            position: absolute;
            top: 6px;
            right: 10px;
            z-index: 12;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 700;
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-secondary);
            letter-spacing: 0.4px;
        }

        .chart-inner {
            position: absolute;
            inset: 0;
        }

        /* Loading Spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--bg-secondary);
            border-radius: 10px;
            border-left: 4px solid var(--accent-cyan);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            border-left-color: var(--success);
        }

        .toast.error {
            border-left-color: var(--danger);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        /* Open Orders Panel */
        .orders-panel {
            position: fixed;
            top: 12px;
            right: 12px;
            width: 320px;
            max-height: 70vh;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 200;
            overflow: hidden;
        }

        .orders-panel.collapsed {
            width: 140px;
            max-height: 45px;
        }

        .orders-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(83, 242, 214, 0.18) 0%, rgba(255, 180, 67, 0.16) 100%);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            user-select: none;
        }

        .orders-title {
            font-weight: 700;
            font-size: 13px;
            color: var(--accent-cyan);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .orders-count {
            background: var(--accent-lime);
            color: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .orders-actions {
            display: flex;
            gap: 8px;
        }

        .orders-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }

        .orders-refresh-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .orders-refresh-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .orders-close-all-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .orders-close-all-btn:hover {
            background: #ff5c6e;
        }

        .orders-list {
            max-height: 450px;
            overflow-y: auto;
            padding: 10px;
        }

        .order-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .order-item:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent-cyan);
        }

        .order-info {
            flex: 1;
        }

        .order-symbol {
            font-weight: 700;
            font-size: 12px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .order-details {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            gap: 10px;
        }

        .order-action-buy {
            color: var(--success);
            font-weight: 600;
        }

        .order-action-sell {
            color: var(--danger);
            font-weight: 600;
        }

        .order-close-icon {
            background: rgba(255, 69, 96, 0.2);
            border: 1px solid var(--danger);
            color: var(--danger);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .order-close-icon:hover {
            background: var(--danger);
            color: white;
        }

        .orders-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .orders-loading {
            text-align: center;
            padding: 15px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Phase 2: Quick Entry Presets */
        .presets-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            padding: 0;
            border-bottom: none;
        }

        .preset-btn {
            flex: 1;
            padding: 8px 4px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.12s ease, border-color 0.12s ease, color 0.12s ease;
            text-align: center;
        }

        .preset-btn:hover {
            background: rgba(83, 242, 214, 0.12);
            border-color: var(--accent-cyan);
        }

        .preset-btn.active {
            background: rgba(83, 242, 214, 0.2);
            border-color: var(--accent-cyan);
            color: var(--text-primary);
        }

        .preset-btn.scalp {
            border-color: rgba(87, 245, 154, 0.6);
        }

        .preset-btn.scalp:hover,
        .preset-btn.scalp.active {
            background: rgba(87, 245, 154, 0.18);
            color: var(--text-primary);
        }

        .preset-btn.medium {
            border-color: rgba(90, 176, 255, 0.6);
        }

        .preset-btn.medium:hover,
        .preset-btn.medium.active {
            background: rgba(90, 176, 255, 0.18);
            color: var(--text-primary);
        }

        .preset-btn.full {
            border-color: rgba(255, 180, 67, 0.6);
        }

        .preset-btn.full:hover,
        .preset-btn.full.active {
            background: rgba(255, 180, 67, 0.2);
            color: var(--text-primary);
        }

        /* Phase 3: Price Staleness Indicators */
        .price-live {
            color: var(--success);
        }

        .price-delayed {
            color: var(--warning);
            opacity: 0.9;
        }

        .price-stale {
            color: var(--danger);
            opacity: 0.7;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0.5;
            }
        }

        /* Phase 3: Connection Health */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
            color: var(--text-secondary);
        }

        .connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
        }

        .connection-dot.warning {
            background: var(--warning);
        }

        .connection-dot.error {
            background: var(--danger);
        }

        /* Phase 5: Loss Warning Banner */
        .loss-warning-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 9999;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
            }

            to {
                transform: translateY(0);
            }
        }

        .loss-warning-banner.warning {
            background: linear-gradient(90deg, rgba(255, 165, 0, 0.95), rgba(255, 140, 0, 0.95));
            color: white;
        }

        .loss-warning-banner.critical {
            background: linear-gradient(90deg, rgba(255, 69, 96, 0.95), rgba(220, 20, 60, 0.95));
            color: white;
            animation: slideDown 0.3s ease, pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }

        .loss-message {
            font-weight: 700;
            font-size: 13px;
        }

        .loss-actions {
            display: flex;
            gap: 8px;
        }

        .loss-exit-btn {
            padding: 6px 14px;
            background: white;
            color: var(--danger);
            border: none;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 12px;
        }

        .loss-dismiss-btn {
            padding: 6px 10px;
            background: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            :root {
                --dock-width: 280px;
            }
        }

        @media (max-width: 960px) {
            :root {
                --dock-width: 0px;
            }

            body {
                overflow: auto;
            }

            .control-panel {
                position: relative;
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            #chart-container {
                position: relative;
                left: 0;
                top: 0;
                height: 70vh;
            }

            .orders-panel {
                top: auto;
                bottom: 12px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
    </style>
</head>

<body>
    <!-- Control Panel -->
    <div class="control-panel">
        <!-- Header Row -->
        <div class="symbol-header dock-section">
            <div class="symbol-title" id="symbolTitle">Loading...</div>
            <div class="current-price" id="currentPrice">
                <span class="price-value">--</span>
                <span class="side-badge ce" id="activeSideBadge">CE Active</span>
            </div>
        </div>
        <div class="side-toggle dock-section" id="sideToggle">
            <button class="side-btn active" id="sideCeBtn" data-side="CE">CE</button>
            <button class="side-btn" id="sidePeBtn" data-side="PE">PE</button>
        </div>
        <div class="scalp-radar dock-section" id="scalpRadar">
            <div class="scalp-radar-title">Scalp Radar</div>
            <div class="scalp-radar-meter">
                <div class="scalp-radar-bar">
                    <div id="scalpRadarFill" class="scalp-radar-fill"></div>
                </div>
                <span id="scalpRadarLabel" class="scalp-radar-label cool">COOL</span>
                <span id="scalpRadarValue" class="scalp-radar-value">--</span>
                <button id="scalpRadarToggle" class="radar-toggle-btn">Radar Off</button>
            </div>
        </div>

        <!-- Controls Row 1: Order Buttons -->
        <div class="controls-row controls-row--actions dock-section">
            <button id="buyBtn" class="action-btn buy" title="Hotkey: B">📈 BUY <span
                    style="opacity:0.5;font-size:10px">(B)</span></button>
            <button id="sellBtn" class="action-btn sell" title="Hotkey: S">📉 SELL <span
                    style="opacity:0.5;font-size:10px">(S)</span></button>
        </div>
        <div class="controls-row controls-row--settings dock-section">
            <div class="order-type-group">
                <button id="marketBtn" class="order-type-btn active">MARKET</button>
                <button id="limitBtn" class="order-type-btn">LIMIT</button>
                <button id="fakeLimitBtn" class="order-type-btn"
                    title="Virtual trigger: MARKET order fires when LTP crosses price">TRIGGER</button>
            </div>

            <div class="qty-control">
                <button class="qty-btn" id="qtyMinus">−</button>
                <div class="qty-value"><span id="qtyValue">2</span> Lots</div>
                <button class="qty-btn" id="qtyPlus">+</button>
            </div>

            <div class="tpsl-control">
                <div class="tpsl-group">
                    <label style="color: var(--success);">TP</label>
                    <button class="qty-btn tpsl-btn" id="tpMinus">&minus;</button>
                    <input type="number" id="tpPointsInput" class="tpsl-input" value="8" min="1" step="1"
                        title="Take Profit points from fill price">
                    <button class="qty-btn tpsl-btn" id="tpPlus">+</button>
                </div>
                <div class="tpsl-group">
                    <label style="color: var(--danger);">SL</label>
                    <button class="qty-btn tpsl-btn" id="slMinus">&minus;</button>
                    <input type="number" id="slPointsInput" class="tpsl-input" value="5" min="1" step="1"
                        title="Stop Loss points from fill price">
                    <button class="qty-btn tpsl-btn" id="slPlus">+</button>
                </div>
                <span class="tpsl-unit">pts</span>
            </div>
        </div>

        <!-- Controls Row 2: Position Info -->
        <div class="position-info dock-section" id="positionInfo">
            <span class="position-label">Position:</span>
            <span class="position-value" id="positionQty">--</span>
            <span class="position-label">Entry:</span>
            <span class="position-value" id="entryPrice">--</span>
            <span class="position-label">P&L:</span>
            <span class="pnl-display" id="pnlValue">₹0.00</span>

            <!-- Secured Profit Display (inline) -->
            <span id="securedProfitDisplay" style="display: none; margin-left: 10px;">
                <span style="font-size: 10px; color: var(--success);">🔒</span>
                <span id="securedProfitValue" style="font-weight: 700; color: var(--success);">₹0</span>
            </span>

            <button class="btn btn-close-position hidden" id="btnClosePosition">Close Position</button>

            <!-- Profit Protection Toggle -->
            <label
                style="display: flex; align-items: center; gap: 5px; margin-left: 15px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="enableProfitProtection" style="width: 14px; height: 14px;"
                    onchange="toggleProfitProtection()">
                <span style="color: var(--text-secondary);">🛡️ Protect</span>
            </label>
        </div>

        <div class="depth-panel dock-section" id="depthPanel">
            <div class="depth-header">
                <div class="depth-title">Depth Scout</div>
                <div class="depth-meta">
                    <span id="depthBroker">Broker: --</span>
                    <span id="depthStatus" class="depth-status">Off</span>
                </div>
            </div>
            <div class="depth-controls">
                <div class="depth-symbol" id="depthSymbol">--</div>
                <div class="depth-actions">
                    <select id="depthLevelSelect" class="depth-level-select">
                        <option value="5">5L</option>
                        <option value="20">20L</option>
                    </select>
                    <button id="depthToggleBtn" class="depth-toggle active">Depth On</button>
                </div>
            </div>
            <div class="depth-modes">
                <span class="depth-mode-label">Mode</span>
                <button class="depth-mode-btn tooltip-target active" data-mode="JOIN"
                    data-tooltip="Join best bid/ask to queue without crossing">Join</button>
                <button class="depth-mode-btn tooltip-target" data-mode="STEP"
                    data-tooltip="Step 1 tick inside spread for faster priority">Step-In</button>
                <button class="depth-mode-btn tooltip-target" data-mode="TAKE"
                    data-tooltip="Cross spread for fastest fill (uses market if allowed)">Take</button>
                <label class="depth-reprice tooltip-target" data-tooltip="Auto-cancel/replace to stay near top of book">
                    <input type="checkbox" id="depthRepriceToggle" checked style="width: 12px; height: 12px;">
                    <span>Reprice</span>
                </label>
                <input type="number" id="depthRepriceMs" class="depth-reprice-input" min="100" step="50" value="400"
                    title="Reprice after ms">
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAlertToggle" checked style="width: 12px; height: 12px;">
                    <span>Alerts</span>
                </label>
                <label class="depth-reprice">
                    <input type="checkbox" id="depthAudioToggle" style="width: 12px; height: 12px;">
                    <span>Audio</span>
                </label>
                <label class="depth-reprice tooltip-target"
                    data-tooltip="Block MARKET orders; force LIMIT for depth actions">
                    <input type="checkbox" id="depthLimitOnly" style="width: 12px; height: 12px;">
                    <span>No MKT</span>
                </label>
            </div>
            <div class="depth-signals">
                <span id="signalMomentum" class="signal-badge">Momentum --</span>
                <span id="signalSpread" class="signal-badge">Spread --</span>
                <span id="signalLiquidity" class="signal-badge">Liquidity --</span>
                <span id="signalGamma" class="signal-badge">Gamma Squeeze --</span>
            </div>
            <div class="depth-score">
                <span class="depth-score-label">Scalp Score</span>
                <span id="scalpScore" class="depth-score-value">--</span>
                <span id="scalpScoreLabel" class="depth-score-pill cool">COOL</span>
            </div>
            <div class="greeks-panel">
                <div>Gamma Proxy<span id="gammaProxy">--</span></div>
                <div>Vol Spike<span id="volProxy">--</span></div>
            </div>
            <div class="depth-summary">
                <div>Bid <span id="depthTopBid">--</span></div>
                <div>Ask <span id="depthTopAsk">--</span></div>
                <div>Spread <span id="depthSpread">--</span></div>
                <div>Imb <span id="depthImbalance">--</span></div>
            </div>
            <div class="depth-table">
                <div class="depth-header-row">
                    <div>Bid Qty</div>
                    <div>Bid</div>
                    <div style="text-align:right;">Ask</div>
                    <div style="text-align:right;">Ask Qty</div>
                </div>
                <div class="depth-rows" id="depthRows"></div>
            </div>
            <div class="depth-quick">
                <div class="depth-selected">Selected <span id="depthSelectedPrice">--</span></div>
                <div class="depth-quick-actions">
                    <button id="depthBuyBtn" class="action-btn buy">BUY @ --</button>
                    <button id="depthSellBtn" class="action-btn sell">SELL @ --</button>
                </div>
            </div>
            <div class="depth-alert neutral" id="depthAlert">Imbalance neutral</div>
            <div class="depth-hint" id="depthHint">Read-only. Uses live depth feed when available.</div>
        </div>

        <div class="auto-panel dock-section" id="autoPanel">
            <div class="auto-header">
                <div class="auto-title">AutoTrade Engine</div>
                <div class="auto-status">
                    <span id="autoStatusPill" class="auto-pill off" title="Auto engine state">OFF</span>
                    <span id="autoModePill" class="auto-pill paper" title="Execution mode">PAPER</span>
                </div>
            </div>
            <button id="autoToggleBtn" class="auto-toggle-btn" title="Start or stop auto trading">AutoTrade Off</button>
            <div class="auto-toggle-row">
                <label title="Run server agent (local auto pauses)">
                    <input type="checkbox" id="autoServerToggle" style="width: 12px; height: 12px;"
                        title="Run server agent (local auto pauses)">
                    <span>Server Agent</span>
                </label>
                <span id="autoBackendPill" class="auto-backend-pill" title="Auto execution backend">LOCAL</span>
            </div>
            <div class="auto-mode-row">
                <div class="auto-mode-group" id="autoModeGroup">
                    <button class="auto-mode-btn active" data-mode="AUTO" title="Trade both CE and PE">Auto</button>
                    <button class="auto-mode-btn" data-mode="CE" title="Only take CE entries">Fire CE</button>
                    <button class="auto-mode-btn" data-mode="PE" title="Only take PE entries">Fire PE</button>
                </div>
                <label class="auto-toggle-row" title="Use paper mode (no live orders)">
                    <input type="checkbox" id="autoPaperToggle" checked style="width: 12px; height: 12px;"
                        title="Use paper mode (no live orders)">
                    <span>Paper Mode</span>
                </label>
                <label class="auto-toggle-row" title="Use broker MTM for Auto P&L in live mode">
                    <input type="checkbox" id="autoBrokerPnlToggle" style="width: 12px; height: 12px;"
                        title="Use broker MTM for Auto P&L in live mode">
                    <span>Broker P&L</span>
                </label>
            </div>
            <div class="auto-toggle-row">
                <label title="Preset settings for common scenarios">
                    <span>Preset</span>
                </label>
                <select id="autoPresetSelect" title="Apply preset settings by underlying">
                    <option value="">Custom (no change)</option>
                    <option value="sensex_expiry">Sensex Expiry (fast)</option>
                    <option value="sensex_normal">Sensex Normal</option>
                    <option value="nifty_expiry">Nifty Expiry (fast)</option>
                    <option value="nifty_normal">Nifty Normal</option>
                    <option value="sniper_quality">🎯 Sniper (Quality)</option>
                    <option value="balanced_trader">⚖️ Balanced Trader</option>
                    <option value="momentum_scalper">⚡ Momentum Scalper</option>
                    <option value="auto_adaptive">🤖 Auto (Adaptive)</option>
                </select>
                <button id="autoPresetApply" class="auto-mini-btn" title="Apply preset settings">Apply</button>
            </div>
            <div class="auto-toggle-row">
                <label title="Show signals only; do not place orders">
                    <input type="checkbox" id="autoAssistToggle" style="width: 12px; height: 12px;"
                        title="Show signals only; do not place orders">
                    <span>Suggest Only</span>
                </label>
                <label title="Enable LLM advisor suggestions">
                    <input type="checkbox" id="autoAdvisorToggle" checked style="width: 12px; height: 12px;"
                        title="Enable LLM advisor suggestions">
                    <span>LLM Advisor</span>
                </label>
                <label title="Auto-apply advisor updates">
                    <input type="checkbox" id="autoAdvisorAutoApply" checked style="width: 12px; height: 12px;"
                        title="Auto-apply advisor updates">
                    <span>Auto-Apply</span>
                </label>
            </div>
            <div class="auto-toggle-row">
                <label title="LLM provider selection">
                    <span>LLM Provider</span>
                </label>
                <select id="autoAdvisorProvider" title="Select advisor provider">
                    <option value="stub">Stub (Local)</option>
                    <option value="openai">OpenAI</option>
                    <option value="anthropic">Anthropic</option>
                    <option value="ollama">Ollama</option>
                    <option value="custom">Custom URL</option>
                </select>
                <button id="autoAdvisorStubBtn" class="auto-mini-btn" title="Switch advisor to local stub">Use
                    Stub</button>
                <span class="auto-key-status">
                    Keys:
                    <span id="autoKeyOpenAI" class="auto-key-pill">OpenAI</span>
                    <span id="autoKeyAnthropic" class="auto-key-pill">Anthropic</span>
                    <span id="autoKeyOllama" class="auto-key-pill">Ollama</span>
                </span>
            </div>
            <div class="auto-toggle-row">
                <label title="LLM model selection">
                    <span>LLM Model</span>
                </label>
                <select id="autoAdvisorModelPreset" title="Select a preset model">
                    <option value="">Select model</option>
                </select>
                <input type="text" id="autoAdvisorModel" placeholder="Custom model name" title="Custom model name">
            </div>
            <div class="auto-toggle-row">
                <label title="LLM base URL and endpoint">
                    <span>LLM Base URL</span>
                </label>
                <input type="text" id="autoAdvisorBaseUrl" placeholder="http://127.0.0.1:11434"
                    title="Base URL for LLM provider">
                <input type="text" id="autoAdvisorUrl" placeholder="/ai_scalper/advisor_stub"
                    title="Custom advisor endpoint">
                <button id="autoAdvisorTestBtn" class="auto-mini-btn primary" title="Test advisor connectivity">Test
                    Advisor</button>
            </div>
            <div class="auto-toggle-row">
                <label title="Enable learning tuner">
                    <input type="checkbox" id="autoLearningToggle" checked style="width: 12px; height: 12px;"
                        title="Enable learning tuner">
                    <span>Learning</span>
                </label>
                <label title="Auto-apply learning updates">
                    <input type="checkbox" id="autoLearningAutoApply" checked style="width: 12px; height: 12px;"
                        title="Auto-apply learning updates">
                    <span>Auto-Apply</span>
                </label>
                <label title="Exploration rate (epsilon)">
                    <span>Explore</span>
                </label>
                <input type="number" id="autoLearningExplore" min="0" max="0.5" step="0.05" value="0.15"
                    title="Exploration rate (epsilon)">
                <label title="Tune interval in seconds">
                    <span>Tune (s)</span>
                </label>
                <input type="number" id="autoLearningInterval" min="15" max="300" step="5" value="60"
                    title="Tune interval in seconds">
                <label title="Min trades before tuning">
                    <span>Min Trades</span>
                </label>
                <input type="number" id="autoLearningMinTrades" min="3" max="50" step="1" value="10"
                    title="Min trades before tuning">
            </div>
            <div class="auto-toggle-row">
                <label title="Enable Telegram alerts">
                    <input type="checkbox" id="autoTelegramToggle" style="width: 12px; height: 12px;"
                        title="Enable Telegram alerts">
                    <span>Telegram Alerts</span>
                </label>
                <label title="Alert on entry">
                    <input type="checkbox" id="autoTelegramEntry" checked style="width: 12px; height: 12px;"
                        title="Alert on entry">
                    <span>Entry</span>
                </label>
                <label title="Alert on exit">
                    <input type="checkbox" id="autoTelegramExit" checked style="width: 12px; height: 12px;"
                        title="Alert on exit">
                    <span>Exit</span>
                </label>
                <label title="Alert on tuning">
                    <input type="checkbox" id="autoTelegramTune" checked style="width: 12px; height: 12px;"
                        title="Alert on tuning">
                    <span>Tune</span>
                </label>
            </div>
            <div class="auto-grid">
                <div class="auto-field">
                    <label title="Lots per entry">Entry Lots</label>
                    <input type="number" id="autoEntryLots" min="1" max="5" step="1" value="2" title="Lots per entry">
                </div>
                <div class="auto-field">
                    <label title="Max lots per strike">Max Lots/Strike</label>
                    <input type="number" id="autoMaxLots" min="1" max="10" step="1" value="3"
                        title="Max lots per strike">
                </div>
                <div class="auto-field">
                    <label title="Minimum time between entries">Min Gap (ms)</label>
                    <input type="number" id="autoMinGap" min="500" max="5000" step="100" value="3000"
                        title="Minimum time between entries">
                </div>
                <div class="auto-field">
                    <label title="Throttle entries per minute">Max Trades/min</label>
                    <input type="number" id="autoMaxTrades" min="1" max="60" step="1" value="10"
                        title="Throttle entries per minute">
                </div>
                <div class="auto-field">
                    <label title="Hard cap on total quantity per side (0=lots cap)">Max Qty (0=auto)</label>
                    <input type="number" id="autoMaxQty" min="0" step="1" value="0"
                        title="Hard cap on total quantity per side (0=lots cap)">
                </div>
                <div class="auto-field">
                    <label title="Min price move since last exit before re-entry">Min Move (pts)</label>
                    <input type="number" id="autoMinMove" min="0" step="0.5" value="1"
                        title="Min price move since last exit before re-entry">
                </div>
                <div class="auto-field">
                    <label title="Cooldown after loss">Cooldown (s)</label>
                    <input type="number" id="autoCooldown" min="5" max="120" step="1" value="25"
                        title="Cooldown after loss">
                </div>
                <div class="auto-field">
                    <label title="Auto-exit when single trade loss exceeds this">Per-trade Max Loss</label>
                    <input type="number" id="autoPerTradeLoss" min="100" step="100" value="2000"
                        title="Auto-exit when single trade loss exceeds this">
                </div>
                <div class="auto-field">
                    <label title="Stop auto after daily loss limit">Daily Max Loss</label>
                    <input type="number" id="autoDailyLoss" min="500" step="500" value="10000"
                        title="Stop auto after daily loss limit">
                </div>
                <div class="auto-field">
                    <label title="Auto take profit points">Auto TP (pts)</label>
                    <input type="number" id="autoTpPoints" min="1" step="1" value="8" title="Auto take profit points">
                </div>
                <div class="auto-field">
                    <label title="Auto stop loss points">Auto SL (pts)</label>
                    <input type="number" id="autoSlPoints" min="1" step="1" value="5" title="Auto stop loss points">
                </div>
                <div class="auto-field">
                    <label title="Consecutive ticks needed to enter">Momentum Ticks</label>
                    <input type="number" id="autoMomentumTicks" min="2" max="8" step="1" value="4"
                        title="Consecutive ticks needed to enter">
                </div>
                <div class="auto-field">
                    <label title="Candle confirmation ticks">Candle Ticks</label>
                    <input type="number" id="autoCandleTicks" min="3" max="12" step="1" value="4"
                        title="Candle confirmation ticks">
                </div>
                <div class="auto-field">
                    <label title="Underlying direction ticks required">Underlying Ticks</label>
                    <input type="number" id="autoUnderlyingTicks" min="1" max="6" step="1" value="2"
                        title="Underlying direction ticks required">
                </div>
                <div class="auto-field">
                    <label title="Candle confirmation mode">Candle Mode</label>
                    <select id="autoCandleMode" title="Candle confirmation mode">
                        <option value="EMA9">EMA9</option>
                        <option value="PREV">Prev Close</option>
                    </select>
                </div>
                <div class="auto-field">
                    <label title="Minimum hold before flip exit">Min Flip Hold (s)</label>
                    <input type="number" id="autoMinFlipHold" min="1" max="10" step="1" value="3"
                        title="Minimum hold before flip exit">
                </div>
                <div class="auto-field">
                    <label title="Averaging window length">Avg Window (s)</label>
                    <input type="number" id="autoAvgWindow" min="5" max="20" step="1" value="12"
                        title="Averaging window length">
                </div>
                <div class="auto-field">
                    <label title="Time between average adds">Avg Interval (ms)</label>
                    <input type="number" id="autoAvgInterval" min="1000" max="5000" step="100" value="3500"
                        title="Time between average adds">
                </div>
                <div class="auto-field">
                    <label title="Trailing SL distance">Trail Distance</label>
                    <input type="number" id="autoTrailDistance" min="0.5" step="0.5" value="2"
                        title="Trailing SL distance">
                </div>
                <div class="auto-field">
                    <label title="Minimum trailing move to update SL">Trail Step</label>
                    <input type="number" id="autoTrailStep" min="0.05" step="0.05" value="0.05"
                        title="Minimum trailing move to update SL">
                </div>
                <div class="auto-field">
                    <label title="Delay before BE SL activates">BE Delay (ms)</label>
                    <input type="number" id="autoBeDelay" min="0" step="100" value="1000"
                        title="Delay before BE SL activates">
                </div>
                <div class="auto-field">
                    <label title="SL offset below entry when BE triggers">BE Buffer (pts)</label>
                    <input type="number" id="autoBeBuffer" min="0" step="0.5" value="1"
                        title="SL offset below entry when BE triggers">
                </div>
                <div class="auto-field">
                    <label title="Lock minimum profit once price moves this far">Profit Lock (pts)</label>
                    <input type="number" id="autoProfitLock" min="0" step="0.5" value="0"
                        title="Lock minimum profit once price moves this far">
                </div>
                <div class="auto-field">
                    <label title="Lock minimum profit in rupees (auto-converts to points)">Profit Lock (Rs)</label>
                    <input type="number" id="autoProfitLockRs" min="0" step="10" value="0"
                        title="Lock minimum profit in rupees (auto-converts to points)">
                </div>
                <div class="auto-field">
                    <label title="Strike offset for auto-roll">Strike Offset</label>
                    <select id="autoStrikeOffset" title="Strike offset for auto-roll">
                        <option value="ATM">ATM</option>
                        <option value="OTM1">OTM +1</option>
                        <option value="OTM3">OTM +3</option>
                    </select>
                </div>
            </div>
            <div class="auto-grid">
                <div class="auto-field">
                    <label title="Index bias mode">Index Bias</label>
                    <select id="autoIndexBiasMode" title="How index trend filters entries">
                        <option value="OFF">OFF</option>
                        <option value="FILTER">Filter</option>
                        <option value="STRONG">Strong Filter</option>
                    </select>
                </div>
                <div class="auto-field">
                    <label title="Minimum score to define bull/bear bias">Bias Score Min</label>
                    <input type="number" id="autoIndexBiasMin" min="1" max="5" step="1" value="2"
                        title="Min score to declare bias direction">
                </div>
                <div class="auto-field">
                    <label title="RSI bull threshold">RSI Bull</label>
                    <input type="number" id="autoIndexRsiBull" min="50" max="80" step="1" value="55"
                        title="RSI >= this is bullish">
                </div>
                <div class="auto-field">
                    <label title="RSI bear threshold">RSI Bear</label>
                    <input type="number" id="autoIndexRsiBear" min="20" max="50" step="1" value="45"
                        title="RSI <= this is bearish">
                </div>
                <div class="auto-field">
                    <label title="ADX strength threshold">ADX Min</label>
                    <input type="number" id="autoIndexAdxMin" min="10" max="50" step="1" value="18"
                        title="ADX must be >= this to count">
                </div>
                <div class="auto-field">
                    <label title="VWAP buffer in index points">VWAP Buffer</label>
                    <input type="number" id="autoIndexVwapBuffer" min="0" step="0.5" value="0"
                        title="Price must be above/below VWAP by this many points">
                </div>
            </div>
            <div class="auto-toggle-row">
                <label title="Use EMA 9/21 cross for bias">
                    <input type="checkbox" id="autoIndexEma" checked style="width: 12px; height: 12px;"
                        title="Use EMA 9/21 cross for bias">
                    <span>Index EMA 9/21</span>
                </label>
                <label title="Use VWAP for bias">
                    <input type="checkbox" id="autoIndexVwap" checked style="width: 12px; height: 12px;"
                        title="Use VWAP for bias">
                    <span>Index VWAP</span>
                </label>
                <label title="Use RSI for bias">
                    <input type="checkbox" id="autoIndexRsi" checked style="width: 12px; height: 12px;"
                        title="Use RSI for bias">
                    <span>Index RSI</span>
                </label>
                <label title="Use ADX/DI for bias">
                    <input type="checkbox" id="autoIndexAdx" checked style="width: 12px; height: 12px;"
                        title="Use ADX/DI for bias">
                    <span>Index ADX</span>
                </label>
                <label title="Use Supertrend for bias">
                    <input type="checkbox" id="autoIndexSupertrend" checked style="width: 12px; height: 12px;"
                        title="Use Supertrend for bias">
                    <span>Index Supertrend</span>
                </label>
            </div>
            <div class="auto-toggle-row">
                <label title="Require underlying direction alignment">
                    <input type="checkbox" id="autoUnderlyingFilter" checked style="width: 12px; height: 12px;"
                        title="Require underlying direction alignment">
                    <span>Underlying Dir</span>
                </label>
                <label title="Require candle confirmation">
                    <input type="checkbox" id="autoCandleConfirm" checked style="width: 12px; height: 12px;"
                        title="Require candle confirmation">
                    <span>Candle Confirm</span>
                </label>
                <label title="Require relative strength between CE/PE">
                    <input type="checkbox" id="autoRelativeStrength" checked style="width: 12px; height: 12px;"
                        title="Require relative strength between CE/PE">
                    <span>Rel Strength</span>
                </label>
                <label title="Show entry checklist details">
                    <input type="checkbox" id="autoChecklistToggle" style="width: 12px; height: 12px;"
                        title="Show entry checklist details">
                    <span>Checklist</span>
                </label>
                <label title="Reverse entries (CE signal -> PE trade)">
                    <input type="checkbox" id="autoReverseTrades" style="width: 12px; height: 12px;"
                        title="Reverse entries (CE signal -> PE trade)">
                    <span>Reverse</span>
                </label>
            </div>
            <div class="auto-toggle-row">
                <label title="Allow averaging into position">
                    <input type="checkbox" id="autoAvgEnabled" checked style="width: 12px; height: 12px;"
                        title="Allow averaging into position">
                    <span>Averaging</span>
                </label>
                <label title="Only average when position PnL is positive">
                    <input type="checkbox" id="autoAvgOnlyProfit" checked style="width: 12px; height: 12px;"
                        title="Only average when position PnL is positive">
                    <span>Avg +PnL</span>
                </label>
                <label title="Ensure TP points are >= SL points">
                    <input type="checkbox" id="autoRrGuard" checked style="width: 12px; height: 12px;"
                        title="Ensure TP points are >= SL points">
                    <span>TP ≥ SL Guard</span>
                </label>
            </div>
            <div class="auto-toggle-row">
                <label title="Require bid/ask imbalance">
                    <input type="checkbox" id="autoImbalanceToggle" style="width: 12px; height: 12px;"
                        title="Require bid/ask imbalance">
                    <span>Imbalance Filter</span>
                </label>
                <input type="number" id="autoImbalanceRatio" min="1" step="0.1" value="1.8"
                    title="Bid/Ask ratio threshold">
                <label title="Enable trailing stop loss">
                    <input type="checkbox" id="autoTrailingToggle" checked style="width: 12px; height: 12px;"
                        title="Enable trailing stop loss">
                    <span>Trailing</span>
                </label>
                <label title="Move SL to entry once in profit">
                    <input type="checkbox" id="autoBreakeven" checked style="width: 12px; height: 12px;"
                        title="Move SL to entry once in profit">
                    <span>BE SL</span>
                </label>
                <label title="Ignore fixed TP and let trailing SL manage exit">
                    <input type="checkbox" id="autoOverrideTp" checked style="width: 12px; height: 12px;"
                        title="Ignore fixed TP and let trailing SL manage exit">
                    <span>Override TP</span>
                </label>
                <label title="After 14:00 on expiry, move to OTM +3">
                    <input type="checkbox" id="autoExpiryOtm" checked style="width: 12px; height: 12px;"
                        title="After 14:00 on expiry, move to OTM +3">
                    <span>Expiry 14:00 → OTM3</span>
                </label>
            </div>
            <div class="auto-status-grid">
                <div title="Total auto P&L for current session">
                    Auto P&L <span id="autoDailyPnl">?0</span>
                    <button id="autoPnlResetBtn" class="auto-mini-btn auto-reset-btn"
                        title="Reset auto PnL stats">Reset</button>
                </div>
                <div title="Open P&L from current positions">Open <span id="autoOpenPnl">?0</span></div>
                <div title="Realized P&L from closed trades">Realized <span id="autoRealizedPnl">?0</span></div>
                <div title="Estimated net P&L after brokerage, STT, exchange charges, GST">Net(est) <span
                        id="autoNetPnl">₹0</span></div>
                <div title="P&L time anchor (local or broker)">Since <span id="autoPnlSince">--</span></div>
                <div title="Remaining cooldown after loss">Cooldown <span id="autoCooldownStatus">--</span></div>
                <div title="Trades executed per minute">Trades/min <span id="autoTradesPerMin">0</span></div>
                <div title="Latest signal detected by engine">Last Signal <span id="autoLastSignal">--</span></div>
                <div title="Last entry gate decision summary">Entry Gate <span id="autoEntryGate">--</span></div>
            </div>
            <!-- Phase 5: Indicators Row -->
            <div class="auto-indicators-row">
                <div class="indicator-chip" title="Trailing SL stage">
                    <span class="chip-label">Trail</span>
                    <span id="trail-stage-indicator" class="chip-value trail-stage trail-stage-0">—</span>
                </div>
                <div class="indicator-chip" title="Market regime">
                    <span class="chip-label">Regime</span>
                    <span id="regime-indicator" class="chip-value regime-badge regime-unknown">—</span>
                </div>
                <div class="indicator-chip" title="Momentum gauge">
                    <span class="chip-label">Mom</span>
                    <div class="momentum-gauge">
                        <div id="momentum-gauge-fill" class="momentum-gauge-fill gauge-building" style="width:0%"></div>
                    </div>
                </div>
                <div class="indicator-chip" title="Momentum velocity">
                    <span class="chip-label">Vel</span>
                    <span id="momentum-velocity" class="chip-value">0/1.5</span>
                </div>
                <div class="indicator-chip" title="Consecutive losses">
                    <span class="chip-label">Losses</span>
                    <span id="consec-loss-indicator" class="chip-value">—</span>
                </div>
            </div>
            <!-- Phase 5: Equity Curve -->
            <div class="equity-curve-wrap">
                <div class="auto-log-header"><span>Equity Curve</span></div>
                <canvas id="equity-curve-canvas" height="60"></canvas>
            </div>
            <!-- Phase 5: Summary Stats -->
            <div class="auto-summary-panel" id="auto-summary-stats">
                <div class="auto-log-header"><span>Session Stats</span></div>
                <div class="auto-stats-grid">
                    <div class="auto-stat"><span class="stat-label">Trades</span><span class="stat-value">0</span></div>
                    <div class="auto-stat"><span class="stat-label">Win%</span><span class="stat-value">—</span></div>
                    <div class="auto-stat"><span class="stat-label">PF</span><span class="stat-value">—</span></div>
                    <div class="auto-stat"><span class="stat-label">P&L</span><span class="stat-value">₹0</span></div>
                </div>
            </div>
            <div class="auto-checklist" id="autoChecklistPanel" style="display:none;">
                <div class="auto-log-header">
                    <span>Entry Checklist</span>
                    <span id="autoChecklistSide">CE</span>
                </div>
                <div id="autoChecklistList" class="auto-log-list"></div>
            </div>
            <div class="auto-backend-grid">
                <div title="Server agent state">Backend <span id="autoBackendState">--</span></div>
                <div title="Active playbook name">Playbook <span id="autoBackendPlaybook">--</span></div>
                <div title="Server agent signal snapshot">Signal <span id="autoBackendSignal">--</span></div>
                <div title="Server agent P&L">P&L <span id="autoBackendPnl">--</span></div>
            </div>
            <div class="auto-log">
                <div class="auto-log-header">
                    <span>Auto Trade Log</span>
                    <select id="autoLogModeFilter" title="Filter DB logs by mode">
                        <option value="">All</option>
                        <option value="PAPER">Paper</option>
                        <option value="LIVE">Live</option>
                    </select>
                    <button id="autoLogExportBtn" class="auto-mini-btn" title="Export auto trade log">Export</button>
                    <button id="autoLogExportDbBtn" class="auto-mini-btn" title="Export stored logs from server">Export
                        DB</button>
                </div>
                <div id="autoLogList" class="auto-log-list"></div>
            </div>
            <div class="auto-learning">
                <div class="auto-log-header">
                    <span>Learning Dashboard</span>
                    <button id="autoLearningRefreshBtn" class="auto-mini-btn"
                        title="Refresh learning stats">Refresh</button>
                </div>
                <div class="auto-learning-grid">
                    <div title="Total trades used for learning">Total <span id="learningTotal">--</span></div>
                    <div title="Win rate (%)">Win% <span id="learningWinRate">--</span></div>
                    <div title="Average P&L per trade">Avg P&L <span id="learningAvgPnl">--</span></div>
                    <div title="Profit factor (gross win / gross loss)">PF <span id="learningProfitFactor">--</span>
                    </div>
                    <div title="Max drawdown">DD <span id="learningMaxDd">--</span></div>
                    <div title="Total P&L of learning sample">Sum <span id="learningSumPnl">--</span></div>
                </div>
                <div class="auto-learning-section" title="Current bandit arm selection">
                    <span>Bandit Arms</span>
                    <span id="learningCurrentArm">Arm --</span>
                </div>
                <div id="learningArms" class="auto-log-list"></div>
                <div class="auto-learning-section">
                    <span>Recent Trades</span>
                    <button id="learningTradesRefreshBtn" class="auto-mini-btn"
                        title="Refresh recent trades">Refresh</button>
                </div>
                <div id="learningTradesList" class="auto-log-list"></div>
                <span>Replay Analyzer</span>
                <div class="auto-learning-actions">
                    <input type="number" id="learningReplayLimit" min="50" max="1000" step="50" value="300"
                        title="Replay trades">
                    <button id="learningReplayBtn" class="auto-mini-btn" title="Run replay analyzer">Replay</button>
                    <button id="learningReplayExport" class="auto-mini-btn" title="Export replay output">Export</button>
                </div>
            </div>
            <div id="learningReplayOutput" class="auto-log-list"></div>
        </div>
        <div class="auto-hint">Auto uses MARKET entries with virtual TP/SL and stops when data stalls. Server Agent
            disables local auto while running.</div>
    </div>
    </div>

    <!-- Open Orders Panel -->
    <div class="orders-panel" id="ordersPanel">
        <div class="orders-header" onclick="toggleOrdersPanel()">
            <div class="orders-title">
                📋 Open Orders
                <span class="orders-count" id="ordersCount">0</span>
            </div>
            <div class="orders-actions">
                <button class="orders-refresh-btn" onclick="event.stopPropagation(); fetchOpenOrders()"
                    title="Refresh orders">🔄</button>
                <button class="orders-close-all-btn" id="closeAllOrdersBtn"
                    onclick="event.stopPropagation(); closeAllOpenOrders()">Close All</button>
                <button class="orders-toggle" id="ordersToggle">▼</button>
            </div>
        </div>
        <div class="orders-list" id="ordersList">
            <div class="orders-loading">Loading orders...</div>
        </div>
    </div>

    <!-- Chart Container -->
    <div id="chart-container">
        <div class="chart-split" id="chartSplit">
            <div class="chart-pane active" id="chartPaneCE">
                <div class="chart-pane-label">CE</div>
                <div class="chart-inner" id="chartCE"></div>
            </div>
            <div class="chart-pane" id="chartPanePE">
                <div class="chart-pane-label">PE</div>
                <div class="chart-inner" id="chartPE"></div>
            </div>
        </div>
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px;">Loading chart...</p>
        </div>
        <!-- Indicator Legend -->
        <div id="indicatorLegend" class="indicator-legend">
            <span class="ind-item" style="color:#f7c325;">EMA 9</span>
            <span class="ind-item" style="color:#7b61ff;">EMA 21</span>
            <span class="ind-item"><span style="color:#00ff88;">S</span><span style="color:#ff4560;">T</span>
                10,3</span>
            <span class="ind-item" style="color:#00bcd4;">VWAP</span>
        </div>
    </div>

    <!-- Lightweight Charts Library -->
    <script src="/static/js/lightweight-charts.standalone.production.js"></script>

    <script>
        // Configuration - wsUrl derived from page port, overridden from server config
        const CONFIG = {
            wsUrl: `ws://${window.location.hostname}:${parseInt(window.location.port || '5000') + 3765}`,
            wsReconnectInterval: 5000,
            candleInterval: 60, // 1-minute candles
            tickSize: 0.05 // Options tick size
        };

        const PERF = {
            disableConsoleLog: true,
            indicatorThrottleMs: 250,
            depthThrottleMs: 80,
            resizeDebounceMs: 150 // Debounce window resize events
        };

        // Utility: Debounce function for performance-critical events
        function debounce(fn, delay) {
            let timeoutId;
            return function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // Utility: Throttle function for continuous events
        function throttle(fn, limit) {
            let inThrottle;
            return function (...args) {
                if (!inThrottle) {
                    fn.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        const ui = {
            currentPrice: document.getElementById('currentPrice'),
            currentPriceValue: null,
            sideToggle: document.getElementById('sideToggle'),
            sideCeBtn: document.getElementById('sideCeBtn'),
            sidePeBtn: document.getElementById('sidePeBtn'),
            chartSplit: document.getElementById('chartSplit'),
            chartPaneCE: document.getElementById('chartPaneCE'),
            chartPanePE: document.getElementById('chartPanePE'),
            // Optimized: Cached elements for frequent updates
            pnlValue: document.getElementById('pnlValue'),
            positionQty: document.getElementById('positionQty'),
            entryPrice: document.getElementById('entryPrice'),
            loading: document.getElementById('loading')
        };

        const depthUi = {
            panel: document.getElementById('depthPanel'),
            scalpRadar: document.getElementById('scalpRadar'),
            scalpRadarFill: document.getElementById('scalpRadarFill'),
            scalpRadarLabel: document.getElementById('scalpRadarLabel'),
            scalpRadarValue: document.getElementById('scalpRadarValue'),
            scalpRadarToggle: document.getElementById('scalpRadarToggle'),
            status: document.getElementById('depthStatus'),
            broker: document.getElementById('depthBroker'),
            symbol: document.getElementById('depthSymbol'),
            levelSelect: document.getElementById('depthLevelSelect'),
            toggleBtn: document.getElementById('depthToggleBtn'),
            rows: document.getElementById('depthRows'),
            topBid: document.getElementById('depthTopBid'),
            topAsk: document.getElementById('depthTopAsk'),
            spread: document.getElementById('depthSpread'),
            imbalance: document.getElementById('depthImbalance'),
            selectedPrice: document.getElementById('depthSelectedPrice'),
            buyBtn: document.getElementById('depthBuyBtn'),
            sellBtn: document.getElementById('depthSellBtn'),
            alert: document.getElementById('depthAlert'),
            hint: document.getElementById('depthHint'),
            repriceToggle: document.getElementById('depthRepriceToggle'),
            repriceMs: document.getElementById('depthRepriceMs'),
            alertToggle: document.getElementById('depthAlertToggle'),
            audioToggle: document.getElementById('depthAudioToggle'),
            limitOnly: document.getElementById('depthLimitOnly'),
            scalpScore: document.getElementById('scalpScore'),
            scalpScoreLabel: document.getElementById('scalpScoreLabel'),
            gammaProxy: document.getElementById('gammaProxy'),
            volProxy: document.getElementById('volProxy'),
            signalMomentum: document.getElementById('signalMomentum'),
            signalSpread: document.getElementById('signalSpread'),
            signalLiquidity: document.getElementById('signalLiquidity'),
            signalGamma: document.getElementById('signalGamma')
        };

        const autoUi = {
            panel: document.getElementById('autoPanel'),
            toggleBtn: document.getElementById('autoToggleBtn'),
            statusPill: document.getElementById('autoStatusPill'),
            modePill: document.getElementById('autoModePill'),
            serverToggle: document.getElementById('autoServerToggle'),
            backendPill: document.getElementById('autoBackendPill'),
            modeGroup: document.getElementById('autoModeGroup'),
            paperToggle: document.getElementById('autoPaperToggle'),
            brokerPnlToggle: document.getElementById('autoBrokerPnlToggle'),
            presetSelect: document.getElementById('autoPresetSelect'),
            presetApply: document.getElementById('autoPresetApply'),
            assistToggle: document.getElementById('autoAssistToggle'),
            advisorToggle: document.getElementById('autoAdvisorToggle'),
            advisorAutoApply: document.getElementById('autoAdvisorAutoApply'),
            advisorUrl: document.getElementById('autoAdvisorUrl'),
            advisorStubBtn: document.getElementById('autoAdvisorStubBtn'),
            advisorProvider: document.getElementById('autoAdvisorProvider'),
            advisorModelPreset: document.getElementById('autoAdvisorModelPreset'),
            advisorModel: document.getElementById('autoAdvisorModel'),
            advisorBaseUrl: document.getElementById('autoAdvisorBaseUrl'),
            advisorTestBtn: document.getElementById('autoAdvisorTestBtn'),
            keyOpenAI: document.getElementById('autoKeyOpenAI'),
            keyAnthropic: document.getElementById('autoKeyAnthropic'),
            keyOllama: document.getElementById('autoKeyOllama'),
            learningToggle: document.getElementById('autoLearningToggle'),
            learningAutoApply: document.getElementById('autoLearningAutoApply'),
            learningExplore: document.getElementById('autoLearningExplore'),
            learningInterval: document.getElementById('autoLearningInterval'),
            learningMinTrades: document.getElementById('autoLearningMinTrades'),
            telegramToggle: document.getElementById('autoTelegramToggle'),
            telegramEntry: document.getElementById('autoTelegramEntry'),
            telegramExit: document.getElementById('autoTelegramExit'),
            telegramTune: document.getElementById('autoTelegramTune'),
            learningRefreshBtn: document.getElementById('autoLearningRefreshBtn'),
            learningTotal: document.getElementById('learningTotal'),
            learningWinRate: document.getElementById('learningWinRate'),
            learningAvgPnl: document.getElementById('learningAvgPnl'),
            learningProfitFactor: document.getElementById('learningProfitFactor'),
            learningMaxDd: document.getElementById('learningMaxDd'),
            learningSumPnl: document.getElementById('learningSumPnl'),
            learningCurrentArm: document.getElementById('learningCurrentArm'),
            learningArms: document.getElementById('learningArms'),
            learningTradesList: document.getElementById('learningTradesList'),
            learningTradesRefreshBtn: document.getElementById('learningTradesRefreshBtn'),
            learningReplayLimit: document.getElementById('learningReplayLimit'),
            learningReplayBtn: document.getElementById('learningReplayBtn'),
            learningReplayExport: document.getElementById('learningReplayExport'),
            learningReplayOutput: document.getElementById('learningReplayOutput'),
            logList: document.getElementById('autoLogList'),
            logModeFilter: document.getElementById('autoLogModeFilter'),
            logExportBtn: document.getElementById('autoLogExportBtn'),
            logExportDbBtn: document.getElementById('autoLogExportDbBtn'),
            entryLots: document.getElementById('autoEntryLots'),
            maxLots: document.getElementById('autoMaxLots'),
            minGap: document.getElementById('autoMinGap'),
            maxTrades: document.getElementById('autoMaxTrades'),
            maxQty: document.getElementById('autoMaxQty'),
            minMove: document.getElementById('autoMinMove'),
            cooldown: document.getElementById('autoCooldown'),
            perTradeLoss: document.getElementById('autoPerTradeLoss'),
            dailyLoss: document.getElementById('autoDailyLoss'),
            autoTpPoints: document.getElementById('autoTpPoints'),
            autoSlPoints: document.getElementById('autoSlPoints'),
            momentumTicks: document.getElementById('autoMomentumTicks'),
            candleTicks: document.getElementById('autoCandleTicks'),
            candleMode: document.getElementById('autoCandleMode'),
            underlyingTicks: document.getElementById('autoUnderlyingTicks'),
            minFlipHold: document.getElementById('autoMinFlipHold'),
            avgWindow: document.getElementById('autoAvgWindow'),
            avgInterval: document.getElementById('autoAvgInterval'),
            trailDistance: document.getElementById('autoTrailDistance'),
            trailStep: document.getElementById('autoTrailStep'),
            beDelay: document.getElementById('autoBeDelay'),
            beBuffer: document.getElementById('autoBeBuffer'),
            profitLock: document.getElementById('autoProfitLock'),
            profitLockRs: document.getElementById('autoProfitLockRs'),
            strikeOffset: document.getElementById('autoStrikeOffset'),
            indexBiasMode: document.getElementById('autoIndexBiasMode'),
            indexBiasMin: document.getElementById('autoIndexBiasMin'),
            indexRsiBull: document.getElementById('autoIndexRsiBull'),
            indexRsiBear: document.getElementById('autoIndexRsiBear'),
            indexAdxMin: document.getElementById('autoIndexAdxMin'),
            indexVwapBuffer: document.getElementById('autoIndexVwapBuffer'),
            indexEmaToggle: document.getElementById('autoIndexEma'),
            indexVwapToggle: document.getElementById('autoIndexVwap'),
            indexRsiToggle: document.getElementById('autoIndexRsi'),
            indexAdxToggle: document.getElementById('autoIndexAdx'),
            indexSupertrendToggle: document.getElementById('autoIndexSupertrend'),
            underlyingFilter: document.getElementById('autoUnderlyingFilter'),
            candleConfirm: document.getElementById('autoCandleConfirm'),
            relativeStrength: document.getElementById('autoRelativeStrength'),
            checklistToggle: document.getElementById('autoChecklistToggle'),
            reverseToggle: document.getElementById('autoReverseTrades'),
            avgEnabledToggle: document.getElementById('autoAvgEnabled'),
            avgOnlyProfitToggle: document.getElementById('autoAvgOnlyProfit'),
            rrGuardToggle: document.getElementById('autoRrGuard'),
            imbalanceToggle: document.getElementById('autoImbalanceToggle'),
            imbalanceRatio: document.getElementById('autoImbalanceRatio'),
            trailingToggle: document.getElementById('autoTrailingToggle'),
            breakevenToggle: document.getElementById('autoBreakeven'),
            overrideTp: document.getElementById('autoOverrideTp'),
            expiryOtm: document.getElementById('autoExpiryOtm'),
            dailyPnl: document.getElementById('autoDailyPnl'),
            openPnl: document.getElementById('autoOpenPnl'),
            realizedPnl: document.getElementById('autoRealizedPnl'),
            netPnl: document.getElementById('autoNetPnl'),
            pnlSince: document.getElementById('autoPnlSince'),
            pnlResetBtn: document.getElementById('autoPnlResetBtn'),
            cooldownStatus: document.getElementById('autoCooldownStatus'),
            tradesPerMin: document.getElementById('autoTradesPerMin'),
            lastSignal: document.getElementById('autoLastSignal'),
            entryGate: document.getElementById('autoEntryGate'),
            checklistPanel: document.getElementById('autoChecklistPanel'),
            checklistList: document.getElementById('autoChecklistList'),
            checklistSide: document.getElementById('autoChecklistSide'),
            backendState: document.getElementById('autoBackendState'),
            backendPlaybook: document.getElementById('autoBackendPlaybook'),
            backendSignal: document.getElementById('autoBackendSignal'),
            backendPnl: document.getElementById('autoBackendPnl')
        };

        const depthDomCache = {
            rows: [],
            bidQty: [],
            bidPrice: [],
            askPrice: [],
            askQty: [],
            maxRows: 20
        };

        const depthAnalytics = {
            imbalanceHistory: [],
            spreadHistory: [],
            bidQtyHistory: [],
            askQtyHistory: [],
            priceHistory: [],
            underlyingHistory: []
        };

        const depthState = {
            enabled: true,
            level: 5,
            requestedLevel: 5,
            lastUpdate: 0,
            pending: null,
            scheduled: false,
            lastRender: 0,
            broker: null,
            selectedPrice: null,
            selectedSide: null,
            topBidValue: null,
            topAskValue: null,
            orderMode: 'JOIN',
            repriceEnabled: true,
            repriceMs: 400,
            repriceMaxRetries: 2,
            alertEnabled: true,
            audioEnabled: true,
            limitOnly: false,
            radarEnabled: false,
            lastScore: 0,
            lastAlertTs: 0,
            lastAudioTs: 0,
            stepInTicks: 1,
            takeMaxSpread: 0.1,
            momentumWindow: 8,
            momentumThreshold: 6,
            spreadWide: 0.2,
            spreadTight: 0.05,
            liquidityDropPct: 40,
            imbalanceMomentum: 0,
            gammaAccelHigh: 12,
            gammaAccelMed: 6,
            volHigh: 6,
            volMed: 3,
            priceHistorySize: 12,
            lastSpeed: 0,
            gammaLevel: 'LOW',
            volLevel: 'LOW',
            underlyingHistorySize: 8,
            underlyingSpeedHigh: 60,
            underlyingAccelHigh: 25,
            underlyingMovePts: 5,
            underlyingSpeed: 0,
            underlyingAccel: 0,
            underlyingMove: 0,
            gammaSqueezeActive: false,
            lastBidAskRatio: null,
            lastImbalancePct: null
        };

        const autoState = {
            enabled: false,
            mode: 'AUTO',
            paperMode: true,
            useBrokerPnl: false,
            presetKey: '',
            presetApplied: false,
            assistOnly: false,
            advisorEnabled: true,
            advisorAutoApply: true,
            advisorProvider: 'stub',
            advisorUrl: '/ai_scalper/advisor_stub',
            advisorModel: '',
            advisorBaseUrl: 'http://127.0.0.1:11434',
            learningEnabled: true,
            learningAutoApply: true,
            learningExploration: 0.15,
            learningIntervalMs: 60000,
            learningMinTrades: 10,
            telegramAlertsEnabled: false,
            telegramAlertEntry: true,
            telegramAlertExit: true,
            telegramAlertTune: true,
            serverMode: false,
            backendPollTimer: null,
            backendStatus: {
                running: false,
                enabled: false,
                playbook: '--',
                lastSignal: '--',
                pnl: { daily: 0, open: 0, realized: 0 }
            },
            brokerPnl: { total: 0, open: 0, realized: 0, source: 'BROKER' },
            brokerPnlUpdatedTs: 0,
            brokerPnlTimer: null,
            brokerTradebookCache: [],
            brokerTradebookTs: 0,
            brokerPnlFetching: false,
            brokerPnlError: null,
            lastExitLog: { key: null, ts: 0 },
            liveEntry: {
                CE: { qty: 0, avg: 0 },
                PE: { qty: 0, avg: 0 }
            },
            serverRestartNoticeTs: 0,
            entryLots: 2,
            scaleLots: 1,
            maxLotsPerStrike: 3,
            minEntryGapMs: 3000,
            maxTradesPerMin: 10,
            maxQty: 0,
            minMovePts: 1,
            cooldownMs: 45000,
            flipCooldownMs: 15000,
            flipCooldownUntil: 0,
            perTradeMaxLoss: 2000,
            dailyMaxLoss: 10000,
            momentumTicks: 6,
            momentumMinMovePts: 1.5,
            candleConfirmEnabled: true,
            candleConfirmMode: 'EMA9',
            candleMomentumTicks: 5,
            minFlipHoldMs: 5000,
            avgWindowMs: 15000,
            avgIntervalMs: 5000,
            avgIntervalMinMs: 4500,
            avgIntervalMaxMs: 5500,
            trailDistance: 2,
            trailStep: CONFIG.tickSize,
            trailingEnabled: true,
            trailStaged: true,
            trailStage1Trigger: 2,
            trailStage1SL: 0,
            trailStage2Trigger: 4,
            trailStage2SL: 0.5,
            trailStage3Trigger: 6,
            trailStage3Distance: 2.5,
            trailStage4Distance: 1.5,
            trailAccelEnabled: true,
            trailAccelMovePts: 3,
            trailAccelTimeMs: 8000,
            trailAccelDistance: 1,
            breakevenEnabled: true,
            breakevenDelayMs: 3000,
            breakevenBufferPts: 0.5,
            profitLockPts: 0,
            profitLockRs: 0,
            trailingOverrideTP: true,
            imbalanceEnabled: false,
            imbalanceRatio: 1.8,
            strikeOffset: 'ATM',
            expiryOtm: true,
            autoRoll: true,
            autoRollNifty: 50,
            autoRollSensex: 100,
            tradeMaxDurationMs: 180000,
            timeExitTightenPts: 1,
            spreadMaxNifty: 0.25,
            spreadMaxSensex: 0.4,
            underlyingFilterEnabled: true,
            underlyingMomentumTicks: 2,
            underlyingMomentumDir: null,
            underlyingMomentumCount: 0,
            underlyingLastTick: null,
            relativeStrengthEnabled: true,
            relativeStrengthDiff: 1,
            indexBiasMode: 'FILTER',
            indexBiasMinScore: 2,
            indexEmaEnabled: true,
            indexVwapEnabled: true,
            indexRsiEnabled: true,
            indexAdxEnabled: true,
            indexSupertrendEnabled: true,
            indexRsiBull: 55,
            indexRsiBear: 45,
            indexAdxMin: 18,
            indexVwapBuffer: 0,
            lastUnderlying: null,
            lastRollUnderlying: null,
            lastEntryTs: 0,
            cooldownUntil: 0,
            tradeTimestamps: [],
            realizedPnl: 0,
            pnlResetTs: Date.now(),
            pnlDate: new Date().toISOString().split('T')[0],
            dailyLossHit: false,
            lastSignal: { CE: null, PE: null },
            lastBlockReason: { CE: null, PE: null },
            checklistEnabled: false,
            reverseTrades: false,
            avgEnabled: true,
            avgOnlyProfit: true,
            rrGuardEnabled: true,
            lastExitPrice: { CE: null, PE: null },
            momentumDir: { CE: null, PE: null },
            momentumCount: { CE: 0, PE: 0 },
            lastTick: { CE: null, PE: null },
            avgSession: { CE: null, PE: null },
            activeTradeId: { CE: null, PE: null },
            pendingExitMeta: { CE: null, PE: null },
            pendingOrders: new Map(),
            pendingPositionTag: { CE: null, PE: null },
            paperPositions: { CE: null, PE: null },
            trailingAnchor: { CE: null, PE: null },
            trailCurrentStage: { CE: 0, PE: 0 },
            positionEntryTs: { CE: null, PE: null },
            positionHighPrice: { CE: 0, PE: 0 },
            lastAnyTickTs: 0,
            stopOnStale: true,
            staleTimeoutMs: 5000,
            consecutiveLosses: 0,
            consecutiveLossBreaker: 3,
            consecutiveLossCooldownMs: 180000,
            consecutiveLossMomentumBoost: 2,
            regimeTradingMode: 'all', // 'all', 'trending_only', 'trending_volatile'
            currentAdaptivePreset: null, // Tracks which sub-preset is active when auto_adaptive is selected
            adaptiveLastUpdate: 0,
            maxConsecLosses: 0,
            winStreak: 0,
            winStreakWideTrail: 3,
            winStreakTrailDistance: 3.5,
            noTradeZoneEnabled: true,
            noTradeZoneRangePts: 2,
            noTradeZoneWindowMs: 30000,
            recentPrices: { CE: [], PE: [] },
            partialExitEnabled: true,
            partialExitPts: 5,
            partialExitPct: 50,
            partialExitDone: { CE: false, PE: false },
            reEntryEnabled: true,
            reEntryWindowMs: 15000,
            reEntryCooldownMs: 5000,
            lastProfitableExitTs: { CE: 0, PE: 0 },
            lastProfitableExitSide: { CE: null, PE: null },
            regimeDetectionEnabled: true,
            currentRegime: 'UNKNOWN',
            regimeWindowMs: 60000,
            regimeTrendAtrThreshold: 1.5,
            regimeVolatileThreshold: 5,
            regimeRangingThreshold: 3,
            todProfileEnabled: true,
            todCurrentProfile: null,
            equityCurve: [],
            tradeHistory: [],
            maxEquityCurvePoints: 200,
            summaryStats: null,
            perTradeMaxLoss: 500
        };

        const indexState = {
            candles: [],
            pendingCandle: null,
            lastPrice: null,
            ema9Last: null,
            ema21Last: null,
            vwapLast: null,
            supertrendLast: null,
            rsiLast: null,
            adxLast: null,
            diPlusLast: null,
            diMinusLast: null,
            lastIndicatorUpdate: 0,
            indicatorUpdateScheduled: false
        };

        function ensureCurrentPriceValue() {
            if (!ui.currentPrice) return null;
            if (ui.currentPriceValue && ui.currentPriceValue.isConnected) {
                return ui.currentPriceValue;
            }
            let valueEl = ui.currentPrice.querySelector('.price-value');
            if (!valueEl) {
                valueEl = document.createElement('span');
                valueEl.className = 'price-value';
                ui.currentPrice.insertBefore(valueEl, ui.currentPrice.firstChild);
            }
            ui.currentPriceValue = valueEl;
            return valueEl;
        }

        function debugLog(...args) {
            if (!PERF.disableConsoleLog) console.log(...args);
        }

        function debugWarn(...args) {
            if (!PERF.disableConsoleLog) console.warn(...args);
        }

        // Helper function to round price to tick size
        function roundToTick(price) {
            return Math.round(price / CONFIG.tickSize) * CONFIG.tickSize;
        }

        // State
        const state = {
            symbol: null,
            underlying: null,
            exchange: null,
            underlyingExchange: null,
            ceSymbol: null,
            peSymbol: null,
            splitMode: false,
            activeSide: 'CE',
            optionType: null,
            strike: null,
            expiry: null,
            apiKey: null,
            ws: null,
            chart: null,
            candlestickSeries: null,
            currentPrice: 0,
            quantity: 2,
            orderType: 'MARKET',
            position: null,
            entryPrice: 0,
            orderLines: new Map(),
            followingMode: false,
            followingType: null,
            currentFollowLine: null,
            lastCandleTime: 0,
            pendingCandle: null,
            lotSize: 65, // Will be updated from URL params
            isMockMode: false, // Set during init based on wsUrl
            // Order and position tracking
            orders: new Map(), // orderId -> order data
            // Fake limit (virtual trigger) orders
            fakeLimitOrders: new Map(), // id -> {id, action, triggerPrice, direction, quantity, priceLine, overlay, tpPoints, slPoints}
            fakeLimitIdCounter: 0,
            positions: new Map(), // orderId -> position data
            dragState: {
                isDragging: false,
                orderId: null,
                startY: 0,
                startPrice: 0
            },
            // Phase 1: Profit Protection System
            profitProtectionEnabled: false,
            profitProtectionLevels: [
                { trigger: 500, lockPercent: 50 },
                { trigger: 1000, lockPercent: 60 },
                { trigger: 2000, lockPercent: 70 },
                { trigger: 3000, lockPercent: 80 }
            ],
            currentProtectionLevel: -1,
            securedProfit: 0,
            breakevenActivated: false,
            breakevenThreshold: 300,
            highestPnl: 0,
            totalPnl: 0,
            isClosingPosition: false,
            // Auto TP/SL point offsets (configurable via UI inputs)
            tpPoints: 8,
            slPoints: 5,
            // Indicator state
            candles: [],           // Completed candle history for indicator calculations
            ema9Series: null,
            ema21Series: null,
            supertrendSeries: null,
            vwapSeries: null
        };

        const chartContexts = {};
        const positionStates = {
            CE: {
                position: null,
                entryPrice: 0,
                positionLine: null,
                positionOverlay: null,
                positionTPSL: {
                    tpLine: null,
                    slLine: null,
                    tpOverlay: null,
                    slOverlay: null,
                    tpPrice: null,
                    slPrice: null,
                    slTrail: false
                }
            },
            PE: {
                position: null,
                entryPrice: 0,
                positionLine: null,
                positionOverlay: null,
                positionTPSL: {
                    tpLine: null,
                    slLine: null,
                    tpOverlay: null,
                    slOverlay: null,
                    tpPrice: null,
                    slPrice: null,
                    slTrail: false
                }
            }
        };

        // Parse URL parameters
        function parseUrlParams() {
            const params = new URLSearchParams(window.location.search);
            state.symbol = params.get('symbol');
            state.underlying = params.get('underlying');
            state.ceSymbol = params.get('ceSymbol');
            state.peSymbol = params.get('peSymbol');
            const initialSide = (params.get('initialSide') || params.get('optionType') || 'CE').toUpperCase();

            // Map INDEX exchanges to options exchanges
            const rawExchange = params.get('exchange');
            state.underlyingExchange = rawExchange;
            if (rawExchange === 'NSE_INDEX') {
                state.exchange = 'NFO'; // NIFTY options
            } else if (rawExchange === 'BSE_INDEX') {
                state.exchange = 'BFO'; // SENSEX options
            } else {
                state.exchange = rawExchange;
            }

            state.optionType = params.get('optionType');
            state.strike = params.get('strike');
            state.expiry = params.get('expiry');
            state.lotSize = parseInt(params.get('lotSize')) || 65; // Default to 65 if not provided

            if (state.ceSymbol || state.peSymbol) {
                state.splitMode = true;
            }
            if (!state.ceSymbol && state.optionType === 'CE') state.ceSymbol = state.symbol;
            if (!state.peSymbol && state.optionType === 'PE') state.peSymbol = state.symbol;
            if (!state.ceSymbol && state.peSymbol && state.symbol === state.peSymbol) {
                state.ceSymbol = '';
            }
            if (!state.peSymbol && state.ceSymbol && state.symbol === state.ceSymbol) {
                state.peSymbol = '';
            }

            state.activeSide = initialSide === 'PE' ? 'PE' : 'CE';
            const activeSymbol = state.activeSide === 'PE' ? state.peSymbol : state.ceSymbol;
            if (activeSymbol) {
                state.symbol = activeSymbol;
            }

            // Get API key from parent window or localStorage
            if (window.opener && window.opener.state && window.opener.state.apiKey) {
                state.apiKey = window.opener.state.apiKey;
            } else {
                state.apiKey = localStorage.getItem('openalgo_api_key') || localStorage.getItem('apiKey');
            }

            // Update title
            const titleEl = document.getElementById('symbolTitle');
            if (state.underlying && state.strike && state.expiry) {
                titleEl.textContent = `${state.underlying} ${state.strike} CE/PE - ${state.expiry}`;
            } else if (state.underlying && state.strike) {
                titleEl.textContent = `${state.underlying} ${state.strike} CE/PE`;
            } else if (state.symbol) {
                titleEl.textContent = state.symbol;
            } else {
                titleEl.textContent = 'Auto Trading Window - Waiting for symbol';
            }
        }

        function getSideForSymbol(symbol) {
            if (symbol && state.ceSymbol && symbol === state.ceSymbol) return 'CE';
            if (symbol && state.peSymbol && symbol === state.peSymbol) return 'PE';
            return null;
        }

        function getActiveSymbol() {
            return state.activeSide === 'PE' ? state.peSymbol : state.ceSymbol;
        }

        function getContext(side) {
            return chartContexts[side];
        }

        function getContextForSide(side) {
            if (side && chartContexts[side]) return chartContexts[side];
            return chartContexts.CE || chartContexts.PE || null;
        }

        function getContextForSymbol(symbol) {
            const side = getSideForSymbol(symbol) || state.activeSide;
            return getContextForSide(side);
        }

        function getPositionState(side = state.activeSide) {
            return positionStates[side] || positionStates.CE;
        }

        function updateActivePriceUI() {
            if (!ui.currentPrice) return;
            const ctx = getContextForSide(state.activeSide);
            if (!ctx) return;
            const valueEl = ensureCurrentPriceValue();
            if (valueEl) {
                valueEl.textContent = ctx.currentPrice ? `₹${ctx.currentPrice.toFixed(2)}` : '--';
            }
            ui.currentPrice.className = 'current-price price-positive';
        }

        function updateSideUI() {
            if (ui.sideCeBtn) ui.sideCeBtn.classList.toggle('active', state.activeSide === 'CE');
            if (ui.sidePeBtn) ui.sidePeBtn.classList.toggle('active', state.activeSide === 'PE');
            if (ui.chartPaneCE) ui.chartPaneCE.classList.toggle('active', state.activeSide === 'CE');
            if (ui.chartPanePE) ui.chartPanePE.classList.toggle('active', state.activeSide === 'PE');
            if (!state.splitMode && ui.chartPaneCE) {
                const label = ui.chartPaneCE.querySelector('.chart-pane-label');
                if (label) label.textContent = state.activeSide;
            }
            const badge = document.getElementById('activeSideBadge');
            if (badge) {
                badge.textContent = `${state.activeSide} Active`;
                badge.classList.toggle('ce', state.activeSide === 'CE');
                badge.classList.toggle('pe', state.activeSide === 'PE');
            }
            updateActivePriceUI();
            updateDepthSymbolUI();
        }

        function updatePositionPanelFromState(side) {
            const posState = getPositionState(side);
            const qty = parseInt(posState?.position?.quantity) || 0;

            if (!posState?.position || qty === 0) {
                document.getElementById('positionQty').textContent = '--';
                document.getElementById('entryPrice').textContent = '--';
                document.getElementById('pnlValue').textContent = '₹0.00';
                document.getElementById('btnClosePosition').classList.add('hidden');
                return;
            }

            const entry = Number.isFinite(posState.entryPrice) && posState.entryPrice > 0
                ? posState.entryPrice
                : (parseFloat(posState.position.average_price) || 0);
            posState.entryPrice = entry;

            document.getElementById('positionQty').textContent = `${qty > 0 ? '+' : ''}${qty}`;
            document.getElementById('entryPrice').textContent = `₹${entry.toFixed(2)}`;
            document.getElementById('btnClosePosition').classList.remove('hidden');

            const ctx = getContextForSide(side);
            const ltp = ctx?.currentPrice || 0;
            if (ltp > 0) {
                const pnl = (ltp - entry) * qty;
                const pnlEl = document.getElementById('pnlValue');
                pnlEl.textContent = `₹${pnl.toFixed(2)}`;
                pnlEl.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;
            }
        }

        function setActiveSide(side, options = {}) {
            const normalized = side === 'PE' ? 'PE' : 'CE';
            if (state.activeSide === normalized) return;
            const prevSymbol = state.symbol;
            state.activeSide = normalized;
            state.symbol = getActiveSymbol() || state.symbol;
            state.optionType = normalized;

            const ctx = getContextForSide(normalized);
            if (ctx) {
                state.chart = ctx.chart;
                state.candlestickSeries = ctx.series;
                state.ema9Series = ctx.ema9Series;
                state.ema21Series = ctx.ema21Series;
                state.supertrendSeries = ctx.supertrendSeries;
                state.vwapSeries = ctx.vwapSeries;
                state.currentPrice = ctx.currentPrice || 0;
            }

            if (depthState.enabled && prevSymbol && prevSymbol !== state.symbol) {
                unsubscribeDepth(prevSymbol);
                subscribeDepth();
            } else {
                updateDepthSymbolUI();
            }

            if (!options.preserveFollow) {
                disableFollowMode();
            } else {
                resetFollowLineForSide(normalized);
            }
            const posState = getPositionState(normalized);
            state.position = posState.position;
            state.entryPrice = posState.entryPrice || 0;
            updateSideUI();
            updatePositionPanelFromState(normalized);
            updateAutoStatsUI();
            fetchAndDisplayPosition(null, state.symbol, normalized);
        }

        // Depth Scout UI
        function isDhanBroker() {
            const broker = depthState.broker ? depthState.broker.toLowerCase() : '';
            if (broker.includes('dhan')) return true;
            return window.location.port === '5001';
        }

        function initDepthPanel() {
            if (!depthUi.panel) return;
            buildDepthRows();
            if (depthUi.rows) {
                depthUi.rows.addEventListener('click', handleDepthRowClick);
            }

            const modeButtons = Array.from(depthUi.panel.querySelectorAll('.depth-mode-btn'));
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    setDepthOrderMode(mode);
                });
            });

            if (depthUi.levelSelect) {
                depthUi.levelSelect.value = String(depthState.level);
                depthUi.levelSelect.addEventListener('change', (e) => {
                    const level = parseInt(e.target.value, 10);
                    setDepthLevel(level);
                });
            }

            if (depthUi.toggleBtn) {
                depthUi.toggleBtn.addEventListener('click', () => {
                    setDepthEnabled(!depthState.enabled);
                });
            }
            if (depthUi.buyBtn) {
                depthUi.buyBtn.addEventListener('click', () => placeDepthOrder('BUY'));
            }
            if (depthUi.sellBtn) {
                depthUi.sellBtn.addEventListener('click', () => placeDepthOrder('SELL'));
            }
            if (depthUi.repriceToggle) {
                depthUi.repriceToggle.checked = depthState.repriceEnabled;
                depthUi.repriceToggle.addEventListener('change', (e) => {
                    depthState.repriceEnabled = e.target.checked;
                });
            }
            if (depthUi.repriceMs) {
                depthUi.repriceMs.value = String(depthState.repriceMs);
                depthUi.repriceMs.addEventListener('change', (e) => {
                    const val = parseInt(e.target.value, 10);
                    if (Number.isFinite(val) && val >= 100) {
                        depthState.repriceMs = val;
                    }
                    depthUi.repriceMs.value = String(depthState.repriceMs);
                });
            }
            if (depthUi.alertToggle) {
                depthUi.alertToggle.checked = depthState.alertEnabled;
                depthUi.alertToggle.addEventListener('change', (e) => {
                    depthState.alertEnabled = e.target.checked;
                });
            }
            if (depthUi.scalpRadarToggle) {
                depthUi.scalpRadarToggle.addEventListener('click', () => {
                    setScalpRadarEnabled(!depthState.radarEnabled);
                });
            }
            if (depthUi.audioToggle) {
                depthUi.audioToggle.checked = depthState.audioEnabled;
                depthUi.audioToggle.addEventListener('change', (e) => {
                    depthState.audioEnabled = e.target.checked;
                    if (depthState.audioEnabled) {
                        initDepthAudio();
                    }
                });
            }
            if (depthUi.limitOnly) {
                depthUi.limitOnly.checked = depthState.limitOnly;
                depthUi.limitOnly.addEventListener('change', (e) => {
                    depthState.limitOnly = e.target.checked;
                    updateDepthQuickUI();
                });
            }

            updateDepthSymbolUI();
            updateDepthBrokerUI();
            updateDepthStatusUI();
            updateDepthModeUI();
            updateDepthQuickUI();
            updateDepthHint();
            resetDepthAnalytics();
            if (depthState.audioEnabled) {
                initDepthAudio();
            }
            setScalpRadarEnabled(false);
        }

        let tooltipHintsBound = false;

        function initTooltipHints() {
            if (tooltipHintsBound) return;
            tooltipHintsBound = true;
            const targets = Array.from(document.querySelectorAll('.tooltip-target[data-tooltip]'));
            targets.forEach(el => {
                let timer;
                el.addEventListener('touchstart', () => {
                    el.classList.add('tooltip-show');
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1600);
                }, { passive: true });
                el.addEventListener('touchend', () => {
                    clearTimeout(timer);
                    timer = setTimeout(() => el.classList.remove('tooltip-show'), 1200);
                }, { passive: true });
            });
        }

        function resetDepthAnalytics() {
            depthAnalytics.imbalanceHistory = [];
            depthAnalytics.spreadHistory = [];
            depthAnalytics.bidQtyHistory = [];
            depthAnalytics.askQtyHistory = [];
            depthAnalytics.priceHistory = [];
            depthAnalytics.underlyingHistory = [];
            depthState.lastSpeed = 0;
            depthState.gammaLevel = 'LOW';
            depthState.volLevel = 'LOW';
            depthState.underlyingSpeed = 0;
            depthState.underlyingAccel = 0;
            depthState.underlyingMove = 0;
            depthState.gammaSqueezeActive = false;
            updateGreeksProxyUI(depthUi.gammaProxy, '--');
            updateGreeksProxyUI(depthUi.volProxy, '--');
            updateSignalBadge(depthUi.signalMomentum, 'Momentum --', 'neutral');
            updateSignalBadge(depthUi.signalSpread, 'Spread --', 'neutral');
            updateSignalBadge(depthUi.signalLiquidity, 'Liquidity --', 'neutral');
            updateSignalBadge(depthUi.signalGamma, 'Gamma Squeeze --', 'neutral');
            updateScalpScore(0);
        }

        function buildDepthRows() {
            if (!depthUi.rows) return;
            depthUi.rows.innerHTML = '';
            depthDomCache.rows = [];
            depthDomCache.bidQty = [];
            depthDomCache.bidPrice = [];
            depthDomCache.askPrice = [];
            depthDomCache.askQty = [];

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = document.createElement('div');
                row.className = 'depth-row';
                row.dataset.index = String(i);

                const bidQty = document.createElement('div');
                const bidPrice = document.createElement('div');
                const askPrice = document.createElement('div');
                const askQty = document.createElement('div');

                bidPrice.classList.add('depth-bid', 'depth-price-cell');
                askPrice.classList.add('depth-ask', 'depth-price-cell');
                askQty.classList.add('depth-ask');
                bidPrice.dataset.side = 'bid';
                askPrice.dataset.side = 'ask';
                bidPrice.dataset.index = String(i);
                askPrice.dataset.index = String(i);

                row.appendChild(bidQty);
                row.appendChild(bidPrice);
                row.appendChild(askPrice);
                row.appendChild(askQty);

                depthUi.rows.appendChild(row);
                depthDomCache.rows.push(row);
                depthDomCache.bidQty.push(bidQty);
                depthDomCache.bidPrice.push(bidPrice);
                depthDomCache.askPrice.push(askPrice);
                depthDomCache.askQty.push(askQty);
            }
        }

        function updateDepthSymbolUI() {
            if (!depthUi.symbol) return;
            depthUi.symbol.textContent = state.symbol || '--';
        }

        function setDepthOrderMode(mode) {
            if (!mode) return;
            const normalized = mode.toUpperCase();
            if (!['JOIN', 'STEP', 'TAKE'].includes(normalized)) return;
            if (depthState.orderMode === normalized) return;
            depthState.orderMode = normalized;
            updateDepthModeUI();
            updateDepthQuickUI();
        }

        function updateDepthModeUI() {
            if (!depthUi.panel) return;
            depthUi.panel.querySelectorAll('.depth-mode-btn').forEach(btn => {
                const active = btn.dataset.mode === depthState.orderMode;
                btn.classList.toggle('active', active);
            });
        }

        function setDepthEnabled(enabled) {
            depthState.enabled = !!enabled;
            updateDepthStatusUI();
            if (depthState.enabled) {
                subscribeDepth();
            } else {
                unsubscribeDepth();
            }
            clearDepthUI();
            updateDepthHint();
        }

        function setDepthLevel(level) {
            if (!Number.isFinite(level)) return;
            const requested = Math.max(1, Math.min(20, level));
            let normalized = requested;
            const allow20 = isDhanBroker() && state.exchange !== 'BFO';
            if (!allow20 && normalized > 5) {
                normalized = 5;
            }
            depthState.requestedLevel = requested;
            if (depthState.level === normalized) return;
            depthState.level = normalized;
            if (depthUi.levelSelect) {
                depthUi.levelSelect.value = String(normalized);
            }
            if (depthState.enabled) {
                unsubscribeDepth();
                subscribeDepth();
            }
            updateDepthHint();
        }

        function updateDepthBrokerUI() {
            if (!depthUi.broker) return;
            const broker = depthState.broker ? depthState.broker.toUpperCase() : '--';
            depthUi.broker.textContent = `Broker: ${broker}`;

            if (depthUi.levelSelect) {
                const allow20 = isDhanBroker() && state.exchange !== 'BFO';
                const opt20 = depthUi.levelSelect.querySelector('option[value=\"20\"]');
                if (opt20) {
                    opt20.disabled = !allow20;
                }
                if (!allow20 && depthState.level > 5) {
                    depthState.level = 5;
                    depthUi.levelSelect.value = '5';
                }
            }
            updateDepthHint();
        }

        function updateDepthStatusUI() {
            if (!depthUi.status) return;
            if (!depthState.enabled) {
                depthUi.status.textContent = 'Off';
                depthUi.status.classList.remove('live');
            } else if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
                depthUi.status.textContent = 'On';
                depthUi.status.classList.remove('live');
            } else {
                const age = Date.now() - (depthState.lastUpdate || 0);
                if (depthState.lastUpdate && age < 5000) {
                    depthUi.status.textContent = 'Live';
                    depthUi.status.classList.add('live');
                } else {
                    depthUi.status.textContent = 'On';
                    depthUi.status.classList.remove('live');
                }
            }

            if (depthUi.toggleBtn) {
                depthUi.toggleBtn.textContent = depthState.enabled ? 'Depth On' : 'Depth Off';
                depthUi.toggleBtn.classList.toggle('active', depthState.enabled);
            }

            const disableOrders = !depthState.enabled;
            if (depthUi.buyBtn) depthUi.buyBtn.disabled = disableOrders;
            if (depthUi.sellBtn) depthUi.sellBtn.disabled = disableOrders;
        }

        function updateDepthQuickUI() {
            const selectedPrice = depthState.selectedPrice;
            if (depthUi.selectedPrice) {
                depthUi.selectedPrice.textContent = selectedPrice ? formatDepthPrice(selectedPrice) : '--';
            }
            const buySpec = getDepthOrderSpec('BUY');
            const sellSpec = getDepthOrderSpec('SELL');
            if (depthUi.buyBtn) {
                depthUi.buyBtn.textContent = buySpec.pricetype === 'MARKET'
                    ? 'BUY @ MKT'
                    : `BUY @ ${buySpec.price ? formatDepthPrice(buySpec.price) : '--'}`;
            }
            if (depthUi.sellBtn) {
                depthUi.sellBtn.textContent = sellSpec.pricetype === 'MARKET'
                    ? 'SELL @ MKT'
                    : `SELL @ ${sellSpec.price ? formatDepthPrice(sellSpec.price) : '--'}`;
            }
        }

        function updateDepthAlert(imbalance) {
            if (!depthUi.alert) return;
            if (!Number.isFinite(imbalance)) {
                depthUi.alert.className = 'depth-alert neutral';
                depthUi.alert.textContent = 'Imbalance neutral';
                return;
            }
            if (imbalance >= 25) {
                depthUi.alert.className = 'depth-alert buy';
                depthUi.alert.textContent = `Buy pressure +${imbalance.toFixed(0)}%`;
            } else if (imbalance <= -25) {
                depthUi.alert.className = 'depth-alert sell';
                depthUi.alert.textContent = `Sell pressure ${imbalance.toFixed(0)}%`;
            } else {
                depthUi.alert.className = 'depth-alert neutral';
                depthUi.alert.textContent = `Imbalance ${imbalance >= 0 ? '+' : ''}${imbalance.toFixed(0)}%`;
            }
        }

        function updateSignalBadge(el, text, type) {
            if (!el) return;
            el.textContent = text;
            el.classList.remove('buy', 'sell');
            if (type === 'buy') el.classList.add('buy');
            if (type === 'sell') el.classList.add('sell');
        }

        let depthAudioContext = null;

        function initDepthAudio() {
            if (depthAudioContext) return;
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return;
            try {
                depthAudioContext = new AudioCtx();
            } catch (err) {
                depthAudioContext = null;
            }
        }

        function playDepthAlertTone() {
            if (!depthState.audioEnabled) return;
            if (!depthAudioContext) {
                initDepthAudio();
            }
            if (!depthAudioContext) return;
            if (depthAudioContext.state === 'suspended') {
                depthAudioContext.resume().catch(() => { });
            }
            const now = depthAudioContext.currentTime;
            const osc = depthAudioContext.createOscillator();
            const gain = depthAudioContext.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.setValueAtTime(0.001, now);
            gain.gain.exponentialRampToValueAtTime(0.08, now + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
            osc.connect(gain);
            gain.connect(depthAudioContext.destination);
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function setScalpRadarEnabled(enabled) {
            depthState.radarEnabled = !!enabled;
            if (depthUi.scalpRadarToggle) {
                depthUi.scalpRadarToggle.textContent = depthState.radarEnabled ? 'Radar On' : 'Radar Off';
                depthUi.scalpRadarToggle.classList.toggle('active', depthState.radarEnabled);
            }
            if (depthUi.scalpRadar) {
                depthUi.scalpRadar.classList.toggle('off', !depthState.radarEnabled);
            }
            if (!depthState.radarEnabled) {
                if (depthUi.scalpRadarFill) depthUi.scalpRadarFill.style.width = '0%';
                if (depthUi.scalpRadarLabel) {
                    depthUi.scalpRadarLabel.textContent = 'OFF';
                    depthUi.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    depthUi.scalpRadarLabel.classList.add('cool');
                }
                if (depthUi.scalpRadarValue) depthUi.scalpRadarValue.textContent = '--';
            } else {
                updateScalpScore(depthState.lastScore || 0);
            }
        }

        function updateScalpScore(score) {
            if (!depthUi.scalpScore || !depthUi.scalpScoreLabel) return;
            const clipped = Math.max(0, Math.min(100, Math.round(score)));
            depthUi.scalpScore.textContent = clipped.toString();
            depthUi.scalpScoreLabel.classList.remove('hot', 'warm', 'cool');
            let label = 'COOL';
            let cls = 'cool';
            if (clipped >= 75) {
                label = 'HOT';
                cls = 'hot';
            } else if (clipped >= 50) {
                label = 'WARM';
                cls = 'warm';
            }
            depthUi.scalpScoreLabel.textContent = label;
            depthUi.scalpScoreLabel.classList.add(cls);

            if (depthState.radarEnabled) {
                if (depthUi.scalpRadarFill) {
                    depthUi.scalpRadarFill.style.width = `${clipped}%`;
                }
                if (depthUi.scalpRadarLabel) {
                    depthUi.scalpRadarLabel.textContent = label;
                    depthUi.scalpRadarLabel.classList.remove('hot', 'warm', 'cool');
                    depthUi.scalpRadarLabel.classList.add(cls);
                }
                if (depthUi.scalpRadarValue) {
                    depthUi.scalpRadarValue.textContent = clipped.toString();
                }
            }

            if (depthState.radarEnabled && clipped >= 75 && depthState.lastScore < 75) {
                const now = Date.now();
                if (depthState.alertEnabled && now - depthState.lastAlertTs > 5000) {
                    depthState.lastAlertTs = now;
                    showToast(`Scalp Radar HOT (${clipped})`, 'success');
                }
                if (depthState.audioEnabled && now - depthState.lastAudioTs > 5000) {
                    depthState.lastAudioTs = now;
                    playDepthAlertTone();
                }
            }
            depthState.lastScore = clipped;
        }

        function updateGreeksProxyUI(el, level) {
            if (!el) return;
            el.textContent = level;
            el.classList.remove('hot', 'warm');
            if (level === 'HIGH') el.classList.add('hot');
            if (level === 'MED') el.classList.add('warm');
        }

        function updateGreeksProxy(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.priceHistory || [];
            history.push({ price, ts });
            const maxSize = depthState.priceHistorySize || 12;
            if (history.length > maxSize) history.shift();
            depthAnalytics.priceHistory = history;
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (depthState.lastSpeed || 0);
            depthState.lastSpeed = speed;

            const diffs = [];
            for (let i = 1; i < history.length; i++) {
                diffs.push(history[i].price - history[i - 1].price);
            }
            const mean = diffs.reduce((a, b) => a + b, 0) / diffs.length;
            const variance = diffs.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / diffs.length;
            const std = Math.sqrt(variance);

            const tick = CONFIG.tickSize || 0.05;
            const accelTicks = Math.abs(accel) / tick;
            const volTicks = std / tick;

            let gammaLevel = 'LOW';
            if (accelTicks >= depthState.gammaAccelHigh) gammaLevel = 'HIGH';
            else if (accelTicks >= depthState.gammaAccelMed) gammaLevel = 'MED';

            let volLevel = 'LOW';
            if (volTicks >= depthState.volHigh) volLevel = 'HIGH';
            else if (volTicks >= depthState.volMed) volLevel = 'MED';

            depthState.gammaLevel = gammaLevel;
            depthState.volLevel = volLevel;

            updateGreeksProxyUI(depthUi.gammaProxy, gammaLevel);
            updateGreeksProxyUI(depthUi.volProxy, volLevel);
        }

        function updateUnderlyingMetrics(price, timestamp) {
            if (!Number.isFinite(price)) return;
            const ts = timestamp || Date.now();
            const history = depthAnalytics.underlyingHistory || [];
            history.push({ price, ts });
            const maxSize = depthState.underlyingHistorySize || 8;
            if (history.length > maxSize) history.shift();
            depthAnalytics.underlyingHistory = history;
            if (history.length < 2) return;

            const prev = history[history.length - 2];
            const dt = (ts - prev.ts) / 1000;
            if (dt <= 0) return;

            const speed = (price - prev.price) / dt;
            const accel = speed - (depthState.underlyingSpeed || 0);
            depthState.underlyingSpeed = speed;
            depthState.underlyingAccel = accel;

            const base = history[0].price;
            depthState.underlyingMove = price - base;
        }

        function pushDepthHistory(list, value, maxLen) {
            if (!Number.isFinite(value)) return;
            list.push(value);
            if (list.length > maxLen) list.shift();
        }

        function computeMomentum(history) {
            if (!history || history.length < 2) return 0;
            return history[history.length - 1] - history[0];
        }

        function updateDepthSignals(imbalance, spread, bestBidQty, bestAskQty) {
            const windowSize = depthState.momentumWindow || 8;
            pushDepthHistory(depthAnalytics.imbalanceHistory, imbalance, windowSize);
            pushDepthHistory(depthAnalytics.spreadHistory, spread, Math.max(windowSize, 6));
            pushDepthHistory(depthAnalytics.bidQtyHistory, bestBidQty, 2);
            pushDepthHistory(depthAnalytics.askQtyHistory, bestAskQty, 2);

            const momentum = computeMomentum(depthAnalytics.imbalanceHistory);
            depthState.imbalanceMomentum = momentum;
            if (momentum >= depthState.momentumThreshold) {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ↑ ${momentum.toFixed(0)}%`, 'buy');
            } else if (momentum <= -depthState.momentumThreshold) {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ↓ ${momentum.toFixed(0)}%`, 'sell');
            } else {
                updateSignalBadge(depthUi.signalMomentum, `Momentum ${momentum >= 0 ? '+' : ''}${momentum.toFixed(0)}%`, 'neutral');
            }

            let spreadSignal = 'Spread stable';
            let spreadType = 'neutral';
            const spreadDirection = Number.isFinite(imbalance) ? (imbalance >= 0 ? 'buy' : 'sell') : 'neutral';
            if (Number.isFinite(spread) && depthAnalytics.spreadHistory.length >= 4) {
                const prev = depthAnalytics.spreadHistory.slice(0, -1);
                const prevAvg = prev.reduce((a, b) => a + b, 0) / prev.length;
                if (prevAvg >= depthState.spreadWide && spread <= depthState.spreadTight) {
                    spreadSignal = 'Spread compress';
                    spreadType = spreadDirection;
                } else if (spread >= depthState.spreadWide) {
                    spreadSignal = 'Spread wide';
                } else if (spread <= depthState.spreadTight) {
                    spreadSignal = 'Spread tight';
                } else {
                    spreadSignal = `Spread ${spread.toFixed(2)}`;
                }
            }
            updateSignalBadge(depthUi.signalSpread, spreadSignal, spreadType);

            let liquiditySignal = 'Liquidity stable';
            let liquidityType = 'neutral';
            const prevBidQty = depthAnalytics.bidQtyHistory.length > 1 ? depthAnalytics.bidQtyHistory[0] : null;
            const prevAskQty = depthAnalytics.askQtyHistory.length > 1 ? depthAnalytics.askQtyHistory[0] : null;
            if (Number.isFinite(prevBidQty) && Number.isFinite(bestBidQty) && prevBidQty > 0) {
                const drop = ((prevBidQty - bestBidQty) / prevBidQty) * 100;
                if (drop >= depthState.liquidityDropPct) {
                    liquiditySignal = `Bid pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'sell';
                }
            }
            if (Number.isFinite(prevAskQty) && Number.isFinite(bestAskQty) && prevAskQty > 0) {
                const drop = ((prevAskQty - bestAskQty) / prevAskQty) * 100;
                if (drop >= depthState.liquidityDropPct) {
                    liquiditySignal = `Ask pulled ${drop.toFixed(0)}%`;
                    liquidityType = 'buy';
                }
            }
            updateSignalBadge(depthUi.signalLiquidity, liquiditySignal, liquidityType);

            const momentumScore = Math.min(30, Math.abs(momentum) / depthState.momentumThreshold * 30);
            const imbalanceScore = Number.isFinite(imbalance) ? Math.min(20, Math.abs(imbalance) / 100 * 20) : 0;
            let spreadScore = 10;
            if (Number.isFinite(spread)) {
                if (spread <= depthState.spreadTight) spreadScore = 20;
                else if (spread >= depthState.spreadWide) spreadScore = 5;
                else if (spreadSignal === 'Spread compress') spreadScore = 18;
            }
            let liquidityScore = 8;
            if (liquidityType !== 'neutral') liquidityScore = 15;
            let gammaScore = 0;
            if (depthState.gammaLevel === 'HIGH') gammaScore = 10;
            else if (depthState.gammaLevel === 'MED') gammaScore = 6;
            let volScore = 0;
            if (depthState.volLevel === 'HIGH') volScore = 10;
            else if (depthState.volLevel === 'MED') volScore = 6;

            let gammaSqueezeScore = 0;
            let gammaSignal = 'Gamma Squeeze --';
            let gammaType = 'neutral';
            const speed = depthState.underlyingSpeed || 0;
            const accel = depthState.underlyingAccel || 0;
            const move = depthState.underlyingMove || 0;
            const tick = CONFIG.tickSize || 0.05;
            const speedTicks = Math.abs(speed) / tick;
            const accelTicks = Math.abs(accel) / tick;
            const squeezeActive = depthState.gammaLevel === 'HIGH'
                && depthState.volLevel === 'HIGH'
                && Math.abs(move) >= depthState.underlyingMovePts
                && speedTicks >= depthState.underlyingSpeedHigh
                && accelTicks >= depthState.underlyingAccelHigh;
            if (squeezeActive) {
                const direction = speed >= 0 ? 'buy' : 'sell';
                gammaSignal = `Gamma Squeeze ${direction === 'buy' ? 'Up' : 'Down'}`;
                gammaType = direction;
                gammaSqueezeScore = 12;
            }
            depthState.gammaSqueezeActive = squeezeActive;
            updateSignalBadge(depthUi.signalGamma, gammaSignal, gammaType);

            const score = momentumScore + imbalanceScore + spreadScore + liquidityScore + gammaScore + volScore + gammaSqueezeScore;
            updateScalpScore(score);
        }

        function updateDepthHint() {
            if (!depthUi.hint) return;
            if (!depthState.enabled) {
                depthUi.hint.textContent = 'Depth disabled.';
                return;
            }
            const requested = depthState.requestedLevel || depthState.level || 5;
            const actual = depthState.level || requested;
            if (actual !== requested) {
                depthUi.hint.textContent = `Requested ${requested}L, broker delivered ${actual}L (fallback).`;
            } else {
                depthUi.hint.textContent = 'Read-only. Proxies are experimental.';
            }
        }

        function clearDepthUI() {
            setDepthText(depthUi.topBid, '--');
            setDepthText(depthUi.topAsk, '--');
            setDepthText(depthUi.spread, '--');
            setDepthText(depthUi.imbalance, '--');
            updateDepthAlert(null);
            updateGreeksProxyUI(depthUi.gammaProxy, '--');
            updateGreeksProxyUI(depthUi.volProxy, '--');
            updateScalpScore(0);
            for (let i = 0; i < depthDomCache.maxRows; i++) {
                setDepthText(depthDomCache.bidQty[i], '--');
                setDepthText(depthDomCache.bidPrice[i], '--');
                setDepthText(depthDomCache.askPrice[i], '--');
                setDepthText(depthDomCache.askQty[i], '--');
                if (depthDomCache.rows[i]) depthDomCache.rows[i].style.background = 'transparent';
            }
            updateSignalBadge(depthUi.signalGamma, 'Gamma Squeeze --', 'neutral');
            clearDepthSelection();
            updateDepthQuickUI();
        }

        function subscribeDepth(symbolOverride) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            const symbol = symbolOverride || state.symbol;
            if (!symbol || !state.exchange) return;
            state.ws.send(JSON.stringify({
                action: 'subscribe',
                symbols: [{ symbol: symbol, exchange: state.exchange }],
                mode: 'Depth',
                depth: depthState.level
            }));
        }

        function unsubscribeDepth(symbolOverride) {
            if (!state.ws || state.ws.readyState !== WebSocket.OPEN) return;
            const symbol = symbolOverride || state.symbol;
            if (!symbol || !state.exchange) return;
            state.ws.send(JSON.stringify({
                action: 'unsubscribe',
                symbols: [{ symbol: symbol, exchange: state.exchange }],
                mode: 'Depth'
            }));
        }

        function handleDepthMessage(message) {
            if (!depthState.enabled) return;
            if (!message || message.symbol !== state.symbol) return;
            const depth = message.data?.depth || message.depth || {};
            const bids = depth.buy || depth.bids || [];
            const asks = depth.sell || depth.asks || [];
            const level = message.data?.depth_level || message.depth_level || depthState.level;
            const timestamp = message.data?.timestamp || message.timestamp || Date.now();

            depthState.pending = { bids, asks, level, timestamp };
            scheduleDepthRender();
        }

        function scheduleDepthRender() {
            if (depthState.scheduled) return;
            depthState.scheduled = true;
            requestAnimationFrame(() => {
                depthState.scheduled = false;
                const now = performance.now();
                const elapsed = now - depthState.lastRender;
                if (elapsed < PERF.depthThrottleMs) {
                    setTimeout(scheduleDepthRender, PERF.depthThrottleMs - elapsed);
                    return;
                }
                depthState.lastRender = now;
                const payload = depthState.pending;
                if (!payload) return;
                renderDepth(payload);
            });
        }

        function renderDepth(payload) {
            const bids = Array.isArray(payload.bids) ? payload.bids : [];
            const asks = Array.isArray(payload.asks) ? payload.asks : [];
            let level = Math.min(depthDomCache.maxRows, parseInt(payload.level, 10) || depthState.level || 5);
            depthState.lastUpdate = payload.timestamp || Date.now();
            if (Number.isFinite(level) && level > 0 && level !== depthState.level) {
                depthState.level = level;
                if (depthUi.levelSelect) {
                    depthUi.levelSelect.value = String(level);
                }
                updateDepthHint();
            }

            let bestBid = null;
            let bestAsk = null;
            let bestBidQty = null;
            let bestAskQty = null;
            let bidTotal = 0;
            let askTotal = 0;

            for (let i = 0; i < depthDomCache.maxRows; i++) {
                const row = depthDomCache.rows[i];
                if (!row) continue;
                const visible = i < level;
                if (visible) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                    continue;
                }

                const bid = parseDepthEntry(bids[i]);
                const ask = parseDepthEntry(asks[i]);

                const bidQty = bid ? formatDepthQty(bid.qty) : '--';
                const bidPrice = bid ? formatDepthPrice(bid.price) : '--';
                const askPrice = ask ? formatDepthPrice(ask.price) : '--';
                const askQty = ask ? formatDepthQty(ask.qty) : '--';

                setDepthText(depthDomCache.bidQty[i], bidQty);
                setDepthText(depthDomCache.bidPrice[i], bidPrice);
                setDepthText(depthDomCache.askPrice[i], askPrice);
                setDepthText(depthDomCache.askQty[i], askQty);
                depthDomCache.bidPrice[i].dataset.price = bid && bid.price ? String(bid.price) : '';
                depthDomCache.askPrice[i].dataset.price = ask && ask.price ? String(ask.price) : '';

                const bidQtyVal = bid && Number.isFinite(bid.qty) ? bid.qty : 0;
                const askQtyVal = ask && Number.isFinite(ask.qty) ? ask.qty : 0;
                const qtyTotal = bidQtyVal + askQtyVal;
                if (qtyTotal > 0) {
                    const bidPct = (bidQtyVal / qtyTotal) * 100;
                    row.style.background = `linear-gradient(90deg, rgba(0, 255, 136, 0.12) 0% ${bidPct}%, rgba(255, 107, 107, 0.12) ${bidPct}% 100%)`;
                } else {
                    row.style.background = 'transparent';
                }

                if (bid && Number.isFinite(bid.price) && bestBid === null) {
                    bestBid = bid.price;
                    bestBidQty = bid.qty;
                }
                if (ask && Number.isFinite(ask.price) && bestAsk === null) {
                    bestAsk = ask.price;
                    bestAskQty = ask.qty;
                }
                if (bid && Number.isFinite(bid.qty)) bidTotal += bid.qty;
                if (ask && Number.isFinite(ask.qty)) askTotal += ask.qty;
            }

            depthState.topBidValue = bestBid;
            depthState.topAskValue = bestAsk;

            setDepthText(depthUi.topBid, bestBid !== null ? formatDepthPrice(bestBid) : '--');
            setDepthText(depthUi.topAsk, bestAsk !== null ? formatDepthPrice(bestAsk) : '--');

            if (bestBid !== null && bestAsk !== null) {
                const spread = bestAsk - bestBid;
                setDepthText(depthUi.spread, formatDepthPrice(spread));
            } else {
                setDepthText(depthUi.spread, '--');
            }

            const total = bidTotal + askTotal;
            if (total > 0) {
                const imbalance = ((bidTotal - askTotal) / total) * 100;
                const sign = imbalance >= 0 ? '+' : '';
                depthState.lastImbalancePct = imbalance;
                if (askTotal > 0) {
                    depthState.lastBidAskRatio = bidTotal / askTotal;
                } else {
                    depthState.lastBidAskRatio = null;
                }
                setDepthText(depthUi.imbalance, `${sign}${imbalance.toFixed(0)}%`);
                updateDepthAlert(imbalance);
                updateDepthSignals(imbalance, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            } else {
                depthState.lastImbalancePct = null;
                depthState.lastBidAskRatio = null;
                setDepthText(depthUi.imbalance, '--');
                updateDepthAlert(null);
                updateDepthSignals(null, bestBid !== null && bestAsk !== null ? bestAsk - bestBid : null, bestBidQty, bestAskQty);
            }

            updateDepthStatusUI();
            updateDepthQuickUI();
        }

        function parseDepthEntry(entry) {
            if (!entry) return null;
            const price = parseFloat(
                entry.price ?? entry.rate ?? entry.prc ?? (Array.isArray(entry) ? entry[0] : undefined)
            );
            const qty = parseFloat(
                entry.quantity ?? entry.qty ?? entry.size ?? entry.volume ?? (Array.isArray(entry) ? entry[1] : undefined)
            );
            return {
                price: Number.isFinite(price) ? price : null,
                qty: Number.isFinite(qty) ? qty : null
            };
        }

        function formatDepthPrice(value) {
            if (!Number.isFinite(value)) return '--';
            return value.toFixed(2);
        }

        function formatDepthQty(value) {
            if (!Number.isFinite(value)) return '--';
            return Math.round(value).toString();
        }

        function setDepthText(element, value) {
            if (!element) return;
            if (element.textContent !== value) {
                element.textContent = value;
            }
        }

        function handleDepthRowClick(e) {
            const cell = e.target.closest('.depth-price-cell');
            if (!cell) return;
            const price = parseFloat(cell.dataset.price || cell.textContent);
            if (!Number.isFinite(price)) return;
            const index = parseInt(cell.dataset.index, 10);
            selectDepthPrice(price, Number.isFinite(index) ? index : null, cell.dataset.side || null);
        }

        function selectDepthPrice(price, rowIndex, side) {
            depthState.selectedPrice = price;
            depthState.selectedSide = side;
            depthDomCache.rows.forEach(row => row.classList.remove('selected'));
            if (Number.isFinite(rowIndex) && depthDomCache.rows[rowIndex]) {
                depthDomCache.rows[rowIndex].classList.add('selected');
                depthDomCache.rows[rowIndex].style.boxShadow = 'inset 0 0 0 1px rgba(0, 212, 255, 0.6)';
            }
            updateDepthQuickUI();
        }

        function clearDepthSelection() {
            depthState.selectedPrice = null;
            depthState.selectedSide = null;
            depthDomCache.rows.forEach(row => {
                row.classList.remove('selected');
                row.style.boxShadow = '';
            });
        }

        function isMomentumFavorable(action) {
            const m = depthState.imbalanceMomentum;
            if (!Number.isFinite(m)) return false;
            if (action === 'BUY') return m >= depthState.momentumThreshold;
            return m <= -depthState.momentumThreshold;
        }

        function getDepthOrderSpec(action, modeOverride) {
            if (Number.isFinite(depthState.selectedPrice)) {
                return { pricetype: 'LIMIT', price: depthState.selectedPrice };
            }

            let mode = modeOverride || depthState.orderMode;
            if (mode === 'TAKE' && depthState.limitOnly) {
                mode = 'JOIN';
            }
            const bestBid = depthState.topBidValue;
            const bestAsk = depthState.topAskValue;
            const spread = Number.isFinite(bestBid) && Number.isFinite(bestAsk) ? bestAsk - bestBid : null;

            if (mode === 'TAKE') {
                if (Number.isFinite(spread) && spread <= depthState.takeMaxSpread && isMomentumFavorable(action)) {
                    return { pricetype: 'MARKET', price: null };
                }
            }

            if (mode === 'STEP') {
                if (Number.isFinite(bestBid) && Number.isFinite(bestAsk)) {
                    const tick = CONFIG.tickSize || 0.05;
                    if (action === 'BUY') {
                        let price = roundToTick(bestBid + (tick * depthState.stepInTicks));
                        if (price >= bestAsk) price = bestAsk;
                        return { pricetype: 'LIMIT', price };
                    }
                    let price = roundToTick(bestAsk - (tick * depthState.stepInTicks));
                    if (price <= bestBid) price = bestBid;
                    return { pricetype: 'LIMIT', price };
                }
            }

            if (action === 'BUY') {
                return { pricetype: 'LIMIT', price: bestAsk };
            }
            return { pricetype: 'LIMIT', price: bestBid };
        }

        async function placeDepthOrder(action, options = {}) {
            const mode = options.modeOverride || depthState.orderMode;
            let spec = getDepthOrderSpec(action, mode);
            if (options.reprice && spec.pricetype === 'MARKET') {
                spec = getDepthOrderSpec(action, 'JOIN');
            }
            if (spec.pricetype === 'LIMIT' && (!Number.isFinite(spec.price) || spec.price <= 0)) {
                showToast('Depth price not available', 'error');
                return;
            }
            if (!state.apiKey) {
                showToast('API key not available', 'error');
                return;
            }
            if (spec.pricetype === 'MARKET') {
                await placeDepthSmartOrder(null, action, 'MARKET');
                return;
            }
            await placeDepthSmartOrder(spec.price, action, 'LIMIT', mode, options);
        }

        function createChartContext(side, symbol, container) {
            const overlayRoot = container?.closest('.chart-pane') || container?.parentElement || container;
            return {
                side,
                symbol,
                container,
                overlayRoot,
                chart: null,
                series: null,
                ema9Series: null,
                ema21Series: null,
                supertrendSeries: null,
                vwapSeries: null,
                ema9Last: null,
                ema21Last: null,
                candles: [],
                pendingCandle: null,
                lastCandleTime: 0,
                currentPrice: 0,
                indicatorUpdateScheduled: false,
                lastIndicatorUpdate: 0
            };
        }

        function initChartContext(ctx) {
            const container = ctx.container;
            if (!container) return;

            ctx.chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: container.clientHeight,
                layout: {
                    background: { color: '#0a0e27' },
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: '#1e2235' },
                    horzLines: { color: '#1e2235' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2d3748',
                },
                timeScale: {
                    borderColor: '#2d3748',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            ctx.series = ctx.chart.addCandlestickSeries({
                upColor: '#00ff88',
                downColor: '#ff4560',
                borderVisible: false,
                wickUpColor: '#00ff88',
                wickDownColor: '#ff4560',
            });

            ctx.ema9Series = ctx.chart.addLineSeries({
                color: '#f7c325',
                lineWidth: 1,
                title: 'EMA 9',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.ema21Series = ctx.chart.addLineSeries({
                color: '#7b61ff',
                lineWidth: 1,
                title: 'EMA 21',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.supertrendSeries = ctx.chart.addLineSeries({
                lineWidth: 2,
                title: 'ST',
                lastValueVisible: false,
                priceLineVisible: false,
            });
            ctx.vwapSeries = ctx.chart.addLineSeries({
                color: '#00bcd4',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'VWAP',
                lastValueVisible: false,
                priceLineVisible: false,
            });

            const oneDayAgo = Math.floor(Date.now() / 1000) - (24 * 60 * 60);
            ctx.series.setData([{
                time: oneDayAgo,
                open: 100,
                high: 200,
                low: 50,
                close: 150
            }]);

            // Optimized: Throttle overlay updates during chart pan/zoom
            const throttledOverlayUpdate = throttle(updateAllOverlays, 50);
            ctx.chart.timeScale().subscribeVisibleLogicalRangeChange(throttledOverlayUpdate);
        }

        // Initialize chart(s)
        function initChart() {
            const ceContainer = document.getElementById('chartCE');
            const peContainer = document.getElementById('chartPE');

            const split = state.splitMode && state.ceSymbol && state.peSymbol;
            if (!split && ui.chartPanePE) {
                ui.chartPanePE.style.display = 'none';
                if (ui.chartSplit) {
                    ui.chartSplit.style.gridTemplateRows = '1fr';
                }
            }

            if (split) {
                if (state.ceSymbol && ceContainer) {
                    chartContexts.CE = createChartContext('CE', state.ceSymbol, ceContainer);
                    initChartContext(chartContexts.CE);
                }
                if (state.peSymbol && peContainer) {
                    chartContexts.PE = createChartContext('PE', state.peSymbol, peContainer);
                    initChartContext(chartContexts.PE);
                }
            } else {
                const singleContainer = ceContainer || peContainer;
                if (singleContainer && state.symbol) {
                    const side = state.activeSide || (state.optionType || 'CE').toUpperCase();
                    chartContexts[side] = createChartContext(side, state.symbol, singleContainer);
                    initChartContext(chartContexts[side]);
                }
            }

            setActiveSide(state.activeSide);

            // Handle window resize (debounced for performance)
            window.addEventListener('resize', debounce(() => {
                Object.values(chartContexts).forEach(ctx => {
                    if (!ctx?.chart || !ctx.container) return;
                    ctx.chart.applyOptions({
                        width: ctx.container.clientWidth,
                        height: ctx.container.clientHeight,
                    });
                });
            }, PERF.resizeDebounceMs));

            if (ui.loading) ui.loading.classList.add('hidden');
        }

        // Note: WebSocket connection is established in the main connectWebSocket() function below (line ~1326)

        // Update P&L (optimized: uses cached DOM reference)
        function updatePnL() {
            if (!state.position || !ui.pnlValue) return;

            const qty = state.position.netqty || 0;
            const pnl = (state.currentPrice - state.entryPrice) * qty;

            ui.pnlValue.textContent = `₹${pnl.toFixed(2)}`;
            ui.pnlValue.className = 'pnl-display ' + (pnl >= 0 ? 'price-positive' : 'price-negative');
        }

        // Toast notifications
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ========== AUTO TRADE ENGINE ==========

        function clampNumber(value, min, max, fallback) {
            const num = Number(value);
            if (!Number.isFinite(num)) return fallback;
            return Math.min(max, Math.max(min, num));
        }

        function enforceRrGuard() {
            if (!autoState.rrGuardEnabled) return;
            if (!Number.isFinite(state.tpPoints) || !Number.isFinite(state.slPoints)) return;
            if (state.tpPoints >= state.slPoints) return;
            state.tpPoints = state.slPoints;
            const tpInput = document.getElementById('tpPointsInput');
            if (tpInput) {
                tpInput.value = String(state.tpPoints);
            }
        }

        function updateAutoUI() {
            if (!autoUi.panel) return;
            enforceBrokerPnlMode();
            if (autoUi.statusPill) {
                const label = autoState.enabled ? (autoState.serverMode ? 'SERVER' : 'ON') : 'OFF';
                autoUi.statusPill.textContent = label;
                autoUi.statusPill.classList.toggle('on', autoState.enabled);
                autoUi.statusPill.classList.toggle('server', autoState.serverMode && autoState.enabled);
                autoUi.statusPill.classList.toggle('off', !autoState.enabled);
            }
            if (autoUi.toggleBtn) {
                autoUi.toggleBtn.textContent = autoState.enabled ? 'AutoTrade ON' : 'AutoTrade Off';
                autoUi.toggleBtn.classList.toggle('active', autoState.enabled);
            }
            if (autoUi.modePill) {
                autoUi.modePill.textContent = autoState.paperMode ? 'PAPER' : 'LIVE';
                autoUi.modePill.classList.toggle('paper', autoState.paperMode);
                autoUi.modePill.classList.toggle('live', !autoState.paperMode);
            }
            if (autoUi.serverToggle) {
                autoUi.serverToggle.checked = autoState.serverMode;
            }
            if (autoUi.brokerPnlToggle) {
                autoUi.brokerPnlToggle.checked = autoState.useBrokerPnl;
                autoUi.brokerPnlToggle.disabled = autoState.paperMode || autoState.serverMode;
            }
            if (autoUi.backendPill) {
                autoUi.backendPill.textContent = autoState.serverMode ? 'SERVER' : 'LOCAL';
                autoUi.backendPill.classList.toggle('active', autoState.serverMode);
            }
            updateAutoStatsUI();
        }

        function ensureAutoPnlDate() {
            const today = new Date().toISOString().split('T')[0];
            if (autoState.pnlDate === today) return;
            autoState.pnlDate = today;
            autoState.realizedPnl = 0;
            autoState.dailyLossHit = false;
            autoState.tradeTimestamps = [];
            autoState.pnlResetTs = Date.now();
        }

        function shouldUseBrokerPnl() {
            return !!(autoState.useBrokerPnl && !autoState.paperMode && !autoState.serverMode);
        }

        function enforceBrokerPnlMode() {
            const shouldEnable = !autoState.serverMode && !autoState.paperMode;
            if (autoState.useBrokerPnl !== shouldEnable) {
                autoState.useBrokerPnl = shouldEnable;
            }
            syncBrokerPnlPolling();
        }

        function startBrokerPnlPoll() {
            stopBrokerPnlPoll();
            autoState.brokerPnlTimer = setInterval(fetchBrokerPnl, 5000);
            fetchBrokerPnl();
        }

        function stopBrokerPnlPoll() {
            if (autoState.brokerPnlTimer) {
                clearInterval(autoState.brokerPnlTimer);
                autoState.brokerPnlTimer = null;
            }
        }

        function syncBrokerPnlPolling() {
            const shouldPoll = shouldUseBrokerPnl();
            if (shouldPoll && !autoState.brokerPnlTimer) {
                startBrokerPnlPoll();
                return;
            }
            if (!shouldPoll && autoState.brokerPnlTimer) {
                stopBrokerPnlPoll();
            }
        }

        function parseNumberSafe(value) {
            const num = Number(value);
            return Number.isFinite(num) ? num : null;
        }

        function parseTradeTimestamp(value) {
            if (!value) return null;
            const ts = Date.parse(value);
            if (!Number.isFinite(ts)) return null;
            return ts;
        }

        function computeRealizedFromTrades(trades) {
            if (!Array.isArray(trades) || trades.length === 0) return 0;
            const today = new Date().toISOString().split('T')[0];
            const rows = trades
                .map(trade => {
                    const ts = parseTradeTimestamp(trade.timestamp || trade.fill_timestamp || trade.fill_time);
                    return { trade, ts };
                })
                .filter(item => {
                    if (!item.ts) return true;
                    const day = new Date(item.ts).toISOString().split('T')[0];
                    return day === today;
                })
                .sort((a, b) => (a.ts || 0) - (b.ts || 0));

            const positions = new Map();
            let realized = 0;

            rows.forEach(({ trade }) => {
                const symbol = trade.symbol || trade.tradingsymbol || '';
                const exchange = trade.exchange || '';
                const key = `${symbol}|${exchange}`;
                const action = String(trade.action || trade.transaction_type || '').toUpperCase();
                const qty = parseNumberSafe(trade.quantity) || 0;
                const price = parseNumberSafe(trade.average_price ?? trade.price) || 0;
                if (!symbol || !action || !qty || !price) return;

                const signedQty = action === 'BUY' ? qty : -qty;
                const pos = positions.get(key) || { qty: 0, avg: 0 };

                if (pos.qty === 0 || Math.sign(pos.qty) === Math.sign(signedQty)) {
                    const newQty = pos.qty + signedQty;
                    const totalCost = (pos.avg * Math.abs(pos.qty)) + (price * Math.abs(signedQty));
                    pos.avg = newQty !== 0 ? totalCost / Math.abs(newQty) : 0;
                    pos.qty = newQty;
                } else {
                    const closingQty = Math.min(Math.abs(pos.qty), Math.abs(signedQty));
                    const pnlPerUnit = action === 'SELL' ? (price - pos.avg) : (pos.avg - price);
                    realized += pnlPerUnit * closingQty;
                    const remainingQty = pos.qty + signedQty;
                    if (remainingQty === 0) {
                        pos.qty = 0;
                        pos.avg = 0;
                    } else {
                        pos.qty = remainingQty;
                        pos.avg = price;
                    }
                }
                positions.set(key, pos);
            });

            return realized;
        }

        async function fetchLatestTradeFill(symbol, action) {
            if (!state.apiKey || !symbol || !action) return null;
            try {
                const result = await postJson('/api/v1/tradebook', { apikey: state.apiKey });
                const trades = result?.data?.data || [];
                const normalized = String(action).toUpperCase();
                const filtered = trades.filter(trade => {
                    const tradeSymbol = trade.symbol || trade.tradingsymbol;
                    const tradeAction = String(trade.action || trade.transaction_type || '').toUpperCase();
                    return tradeSymbol === symbol && tradeAction === normalized;
                });
                if (!filtered.length) return null;
                filtered.sort((a, b) => {
                    const ta = parseTradeTimestamp(a.timestamp || a.fill_timestamp || a.fill_time) || 0;
                    const tb = parseTradeTimestamp(b.timestamp || b.fill_timestamp || b.fill_time) || 0;
                    return tb - ta;
                });
                const latest = filtered[0];
                const price = parseNumberSafe(latest.average_price ?? latest.price);
                const qty = parseNumberSafe(latest.quantity);
                return { price, qty };
            } catch (e) {
                return null;
            }
        }

        async function logLiveExitWithFill(params) {
            const {
                side,
                symbol,
                action,
                qty,
                entryPrice,
                reason,
                fallbackPrice
            } = params;
            const exitKey = `${side || ''}|${symbol || ''}|${reason || ''}`;
            if (!autoState.lastExitLog) {
                autoState.lastExitLog = { key: null, ts: 0 };
            }
            const now = Date.now();
            if (autoState.lastExitLog.key === exitKey && now - autoState.lastExitLog.ts < 1500) {
                return;
            }
            let price = fallbackPrice;
            const fill = await fetchLatestTradeFill(symbol, action);
            if (fill?.price) {
                price = fill.price;
            }
            const entryFromCache = autoState.liveEntry?.[side]?.avg || entryPrice;
            const entryQty = autoState.liveEntry?.[side]?.qty || qty;
            const signedQty = action === 'BUY' ? -qty : qty;
            const pnl = Number.isFinite(entryFromCache) && Number.isFinite(price)
                ? (price - entryFromCache) * signedQty
                : null;
            const pendingExit = autoState.pendingExitMeta?.[side] || null;
            const tradeId = pendingExit?.tradeId || autoState.activeTradeId?.[side] || null;
            const holdMs = pendingExit?.holdMs || (autoState.positionEntryTs?.[side] ? Math.max(0, Date.now() - autoState.positionEntryTs[side]) : null);
            logAutoTrade({
                type: 'EXIT',
                mode: 'LIVE',
                side,
                symbol,
                action,
                qty,
                price,
                pnl,
                reason,
                tradeId,
                holdMs,
                // Market context for analytics/ML
                regime: autoState.currentRegime || 'UNKNOWN',
                trailStage: autoState.trailCurrentStage?.[side] || 0,
                consecutiveLosses: autoState.consecutiveLosses || 0,
                winStreak: autoState.winStreak || 0,
                sessionPnl: parseFloat((autoState.realizedPnl || 0).toFixed(0)),
                tradeNumber: autoState.tradeHistory?.length || 0,
                highWaterMark: autoState.positionHighPrice?.[side] || 0
            });
            autoState.lastExitLog = { key: exitKey, ts: now };
            if (autoState.pendingExitMeta) autoState.pendingExitMeta[side] = null;
            if (autoState.activeTradeId) autoState.activeTradeId[side] = null;
            reduceLiveEntry(side, qty);
            if (pnl != null) {
                autoState.lastSignal[side] = `${reason || 'Exit'} ${pnl >= 0 ? '+' : ''}${Number(pnl).toFixed(0)}`;
                updateAutoStatsUI();
            }
        }

        async function fetchBrokerPnl() {
            if (!shouldUseBrokerPnl()) return;
            if (!state.apiKey) return;
            if (autoState.brokerPnlFetching) return;

            autoState.brokerPnlFetching = true;
            autoState.brokerPnlError = null;

            let realized = 0;
            let open = 0;
            let source = 'BROKER';
            let hasBrokerData = false;

            try {
                const result = await postJson('/api/v1/funds', { apikey: state.apiKey });
                const data = result?.data?.data || result?.data || {};
                const m2mRealized = parseNumberSafe(data.m2mrealized ?? data.m2m_realized ?? data.m2mrealised);
                const m2mUnrealized = parseNumberSafe(data.m2munrealized ?? data.m2m_unrealized ?? data.m2munrealised);
                if (m2mRealized !== null || m2mUnrealized !== null) {
                    realized = m2mRealized ?? 0;
                    open = m2mUnrealized ?? 0;
                    source = 'FUNDS';
                    hasBrokerData = true;
                    autoState.brokerPnl = { total: realized + open, open, realized, source };
                    autoState.brokerPnlUpdatedTs = Date.now();
                    updateAutoStatsUI();
                    autoState.brokerPnlFetching = false;
                    return;
                }
            } catch (e) {
                autoState.brokerPnlError = e?.message || 'Funds fetch failed';
            }

            try {
                const result = await postJson('/api/v1/positionbook', { apikey: state.apiKey });
                const positions = result?.data?.data || [];
                let hasData = false;
                const ltpBySymbol = new Map();
                Object.values(chartContexts || {}).forEach(ctx => {
                    if (!ctx?.symbol) return;
                    if (Number.isFinite(ctx.currentPrice) && ctx.currentPrice > 0) {
                        ltpBySymbol.set(ctx.symbol, ctx.currentPrice);
                    }
                });
                positions.forEach(pos => {
                    const qty = parseNumberSafe(pos.quantity ?? pos.netqty ?? pos.net_qty ?? pos.qty) || 0;
                    if (!qty) return;
                    let pnl = parseNumberSafe(pos.pnl);
                    if (pnl === null) {
                        const ltp = parseNumberSafe(pos.ltp)
                            ?? ltpBySymbol.get(pos.symbol)
                            ?? ltpBySymbol.get(pos.tradingsymbol);
                        const avg = parseNumberSafe(pos.average_price ?? pos.avg_price ?? pos.net_avg_price);
                        if (ltp !== null && avg !== null) {
                            pnl = (ltp - avg) * qty;
                        }
                    } else {
                        const ltp = parseNumberSafe(pos.ltp)
                            ?? ltpBySymbol.get(pos.symbol)
                            ?? ltpBySymbol.get(pos.tradingsymbol);
                        const avg = parseNumberSafe(pos.average_price ?? pos.avg_price ?? pos.net_avg_price);
                        if (ltp !== null && avg !== null) {
                            pnl = (ltp - avg) * qty;
                        }
                    }
                    if (pnl === null) return;
                    hasData = true;
                    open += pnl;
                });
                if (hasData) {
                    hasBrokerData = true;
                }
                source = 'POSITIONBOOK';
            } catch (e) {
                autoState.brokerPnlError = e?.message || 'Positionbook fetch failed';
            }

            let tradebookRealized = null;
            const now = Date.now();
            if (now - autoState.brokerTradebookTs > 10000) {
                try {
                    const result = await postJson('/api/v1/tradebook', { apikey: state.apiKey });
                    const trades = result?.data?.data || [];
                    autoState.brokerTradebookCache = trades;
                    autoState.brokerTradebookTs = now;
                } catch (e) {
                    // ignore
                }
            }
            if (autoState.brokerTradebookCache.length) {
                tradebookRealized = computeRealizedFromTrades(autoState.brokerTradebookCache);
            }
            if (Number.isFinite(tradebookRealized)) {
                realized = tradebookRealized;
                source = source === 'POSITIONBOOK' ? 'TRADEBOOK+POS' : 'TRADEBOOK';
                hasBrokerData = true;
            }

            if (!hasBrokerData) {
                try {
                    const result = await postJson('/pnltracker/api/pnl', {});
                    const mtm = parseNumberSafe(result?.data?.data?.current_mtm);
                    if (mtm !== null) {
                        const total = mtm;
                        const realizedFallback = Number.isFinite(realized) ? realized : 0;
                        const openFallback = total - realizedFallback;
                        autoState.brokerPnl = {
                            total,
                            open: openFallback,
                            realized: realizedFallback,
                            source: 'PNLTRACKER'
                        };
                        autoState.brokerPnlUpdatedTs = Date.now();
                        updateAutoStatsUI();
                        autoState.brokerPnlFetching = false;
                        return;
                    }
                } catch (e) {
                    autoState.brokerPnlError = e?.message || 'PnL tracker fetch failed';
                }
            }

            autoState.brokerPnl = { total: realized + open, open, realized, source };
            autoState.brokerPnlUpdatedTs = Date.now();
            updateAutoStatsUI();
            autoState.brokerPnlFetching = false;
        }

        function getAutoPnlSnapshot() {
            if (autoState.serverMode) {
                const pnl = autoState.backendStatus.pnl || {};
                return {
                    total: Number(pnl.daily || 0),
                    open: Number(pnl.open || 0),
                    realized: Number(pnl.realized || 0),
                    source: 'SERVER'
                };
            }
            if (shouldUseBrokerPnl()) {
                const pnl = autoState.brokerPnl || {};
                const brokerRealized = Number(pnl.realized || 0);
                const brokerOpen = Number(pnl.open || 0);
                const brokerTotal = Number(pnl.total || 0);
                const hasBrokerData = brokerTotal !== 0 || brokerRealized !== 0 || brokerOpen !== 0;
                // If broker data is available and non-zero, use it
                if (hasBrokerData) {
                    return {
                        total: brokerTotal,
                        open: brokerOpen,
                        realized: brokerRealized,
                        source: pnl.source || 'BROKER'
                    };
                }
                // Fallback to local tracking when broker returns all zeros
                const localOpen = getAutoOpenPnl();
                const localRealized = autoState.realizedPnl;
                return {
                    total: localRealized + localOpen,
                    open: localOpen,
                    realized: localRealized,
                    source: 'LOCAL'
                };
            }
            const open = getAutoOpenPnl();
            const realized = autoState.realizedPnl;
            return {
                total: realized + open,
                open,
                realized,
                source: 'LOCAL'
            };
        }

        function resetAutoPnl(reason = 'Auto P&L reset') {
            autoState.realizedPnl = 0;
            autoState.dailyLossHit = false;
            autoState.tradeTimestamps = [];
            autoState.pnlResetTs = Date.now();
            autoState.pnlDate = new Date().toISOString().split('T')[0];
            autoState.lastSignal = { CE: null, PE: null };
            updateAutoStatsUI();
            if (reason) {
                showToast(reason, 'info');
            }
        }

        function updateAutoStatsUI() {
            ensureAutoPnlDate();
            const pnlSnapshot = getAutoPnlSnapshot();
            if (shouldUseBrokerPnl()) {
                const stale = Date.now() - (autoState.brokerPnlUpdatedTs || 0) > 6000;
                if (stale && !autoState.brokerPnlFetching) {
                    fetchBrokerPnl();
                }
            }
            if (autoUi.dailyPnl) {
                autoUi.dailyPnl.textContent = `₹${pnlSnapshot.total.toFixed(0)}`;
                autoUi.dailyPnl.style.color = pnlSnapshot.total >= 0 ? 'var(--success)' : 'var(--danger)';
            }
            if (autoUi.openPnl) {
                autoUi.openPnl.textContent = `₹${pnlSnapshot.open.toFixed(0)}`;
                autoUi.openPnl.style.color = pnlSnapshot.open >= 0 ? 'var(--success)' : 'var(--danger)';
            }
            if (autoUi.realizedPnl) {
                autoUi.realizedPnl.textContent = `₹${pnlSnapshot.realized.toFixed(0)}`;
                autoUi.realizedPnl.style.color = pnlSnapshot.realized >= 0 ? 'var(--success)' : 'var(--danger)';
            }
            if (autoUi.netPnl) {
                const tradeCount = autoState.tradeHistory?.length || 0;
                const totalOrders = tradeCount * 2;
                const brokerage = totalOrders * 20;
                const stt = autoState.tradeHistory?.reduce((s, t) => s + Math.abs(t.exit || 0) * Math.abs(t.qty || 0) * 0.000625, 0) || 0;
                const exchg = autoState.tradeHistory?.reduce((s, t) => s + ((Math.abs(t.entry || 0) + Math.abs(t.exit || 0)) * Math.abs(t.qty || 0) * 0.00053), 0) || 0;
                const gst = (brokerage + exchg) * 0.18;
                const estCharges = brokerage + stt + exchg + gst;
                const netPnl = pnlSnapshot.realized - estCharges;
                autoUi.netPnl.textContent = `₹${netPnl.toFixed(0)}`;
                autoUi.netPnl.style.color = netPnl >= 0 ? 'var(--success)' : 'var(--danger)';
            }
            if (autoUi.pnlSince) {
                if (autoState.serverMode) {
                    autoUi.pnlSince.textContent = pnlSnapshot.source;
                } else if (shouldUseBrokerPnl()) {
                    autoUi.pnlSince.textContent = pnlSnapshot.source || 'BROKER';
                } else if (autoState.pnlResetTs) {
                    autoUi.pnlSince.textContent = new Date(autoState.pnlResetTs).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                } else {
                    autoUi.pnlSince.textContent = '--';
                }
            }
            if (autoUi.cooldownStatus) {
                const remaining = Math.max(0, autoState.cooldownUntil - Date.now());
                autoUi.cooldownStatus.textContent = remaining > 0 ? `${Math.ceil(remaining / 1000)}s` : '--';
            }
            if (autoUi.tradesPerMin) {
                pruneAutoTradesWindow();
                autoUi.tradesPerMin.textContent = String(autoState.tradeTimestamps.length);
            }
            if (autoUi.lastSignal) {
                const activeSignal = autoState.lastSignal[state.activeSide] || '--';
                autoUi.lastSignal.textContent = activeSignal;
            }
            if (autoUi.entryGate) {
                if (autoState.serverMode && autoState.enabled) {
                    autoUi.entryGate.textContent = 'Server agent';
                } else if (autoState.assistOnly) {
                    autoUi.entryGate.textContent = 'Suggest only';
                } else {
                    const reason = autoState.lastBlockReason[state.activeSide] || '--';
                    autoUi.entryGate.textContent = reason;
                }
            }
            if (autoUi.backendState) {
                autoUi.backendState.textContent = autoState.backendStatus.enabled ? 'ON' : 'OFF';
            }
            if (autoUi.backendPlaybook) {
                autoUi.backendPlaybook.textContent = autoState.backendStatus.playbook || '--';
            }
            if (autoUi.backendSignal) {
                autoUi.backendSignal.textContent = autoState.backendStatus.lastSignal || '--';
            }
            if (autoUi.backendPnl) {
                const pnl = autoState.backendStatus.pnl?.daily ?? 0;
                autoUi.backendPnl.textContent = `₹${Number(pnl).toFixed(0)}`;
            }
            if (autoUi.learningCurrentArm) {
                const arm = autoState.backendStatus.learning?.current_arm;
                autoUi.learningCurrentArm.textContent = arm ? `Arm ${arm}` : 'Arm --';
            }
            if (autoState.checklistEnabled) {
                renderAutoChecklist(state.activeSide);
            }
            // Update new Phase 5 indicator widgets
            updateAutoIndicatorsUI();
        }

        function getAdvisorModelPresets(provider) {
            switch (provider) {
                case 'openai':
                    return ['gpt-4o-mini', 'gpt-4.1-mini', 'gpt-4o'];
                case 'anthropic':
                    return ['claude-3-5-sonnet', 'claude-3-5-haiku', 'claude-3-opus'];
                case 'ollama':
                    return ['qwen2.5:3b', 'qwen2.5:7b', 'llama3.1:8b', 'llama3:8b', 'mistral:7b'];
                default:
                    return [];
            }
        }

        function updateAdvisorPresets(provider) {
            if (!autoUi.advisorModelPreset) return;
            const presets = getAdvisorModelPresets(provider);
            autoUi.advisorModelPreset.innerHTML = '<option value="">Select model</option>';
            presets.forEach(model => {
                const opt = document.createElement('option');
                opt.value = model;
                opt.textContent = model;
                autoUi.advisorModelPreset.appendChild(opt);
            });
            if (autoState.advisorModel && presets.includes(autoState.advisorModel)) {
                autoUi.advisorModelPreset.value = autoState.advisorModel;
            }
        }

        async function testAdvisor() {
            if (!autoState.advisorEnabled) {
                showToast('Enable LLM Advisor first', 'info');
                return;
            }
            let provider = autoState.advisorProvider;
            if (provider === 'stub') {
                showToast('Testing local stub', 'info');
                const result = await postJson('/ai_scalper/advisor_stub', {
                    volatility: 0.8,
                    playbook: 'baseline'
                });
                if (result.ok) {
                    showToast(`Stub ok: ${result.data?.notes || 'ok'}`, 'success');
                } else {
                    showToast('Stub failed', 'error');
                }
                return;
            }

            if (!autoState.advisorModel) {
                showToast('Set LLM model first', 'error');
                return;
            }
            const payload = {
                provider: autoState.advisorProvider === 'custom' ? 'http' : autoState.advisorProvider,
                url: autoState.advisorProvider === 'custom' ? autoState.advisorUrl : null,
                model: autoState.advisorModel || null,
                base_url: autoState.advisorBaseUrl || null
            };
            showToast('Testing advisor...', 'info');
            const result = await postJson('/ai_scalper/test_advisor', payload);
            if (result.ok && result.data?.status === 'success') {
                showToast(`Advisor ok: ${result.data?.notes || 'ok'}`, 'success');
            } else {
                showToast(result.data?.message || 'Advisor test failed', 'error');
            }
        }

        async function fetchAdvisorKeyStatus() {
            try {
                const response = await fetch('/ai_scalper/key_status');
                if (!response.ok) return;
                const data = await response.json();
                updateKeyPill(autoUi.keyOpenAI, data.openai);
                updateKeyPill(autoUi.keyAnthropic, data.anthropic);
                updateKeyPill(autoUi.keyOllama, data.ollama);
            } catch (e) {
                // ignore
            }
        }

        function updateKeyPill(el, present) {
            if (!el) return;
            el.classList.toggle('ok', !!present);
            el.classList.toggle('miss', !present);
        }

        async function postJson(url, payload) {
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload || {})
            });
            let data = null;
            try {
                data = await response.json();
            } catch (e) { }
            return { ok: response.ok, data };
        }

        async function fetchBackendStatus() {
            if (!autoState.serverMode) return;
            try {
                const response = await fetch('/ai_scalper/status');
                if (!response.ok) return;
                const data = await response.json();
                autoState.backendStatus = {
                    running: !!data.running,
                    enabled: !!data.enabled,
                    playbook: data.playbook || '--',
                    lastSignal: data.last_signal || data.lastSignal || '--',
                    pnl: data.pnl || { daily: 0, open: 0, realized: 0 },
                    learning: data.learning || {}
                };
                autoState.enabled = !!data.enabled;
                updateAutoUI();
            } catch (e) {
                // ignore
            }
        }

        function startBackendPoll() {
            stopBackendPoll();
            autoState.backendPollTimer = setInterval(fetchBackendStatus, 2000);
            fetchBackendStatus();
            startLearningPoll();
            refreshLearningDashboard();
        }

        function stopBackendPoll() {
            if (autoState.backendPollTimer) {
                clearInterval(autoState.backendPollTimer);
                autoState.backendPollTimer = null;
            }
            stopLearningPoll();
        }

        function buildServerPayload() {
            let advisorProvider = 'none';
            let advisorUrl = null;
            let advisorModel = autoState.advisorModel || null;
            let advisorBaseUrl = autoState.advisorBaseUrl || null;

            if (autoState.advisorEnabled) {
                if (autoState.advisorProvider === 'stub') {
                    advisorProvider = 'http';
                    advisorUrl = '/ai_scalper/advisor_stub';
                    advisorModel = null;
                    advisorBaseUrl = null;
                } else if (autoState.advisorProvider === 'custom') {
                    advisorProvider = 'http';
                    advisorUrl = autoState.advisorUrl || '/ai_scalper/advisor_stub';
                } else {
                    advisorProvider = autoState.advisorProvider;
                }
            }
            return {
                apikey: state.apiKey,
                ce_symbol: state.ceSymbol,
                pe_symbol: state.peSymbol,
                underlying: state.underlying,
                exchange: state.underlyingExchange,
                underlying_exchange: state.underlyingExchange,
                option_exchange: state.exchange,
                expiry: state.expiry,
                lot_size: state.lotSize || 1,
                entry_lots: autoState.entryLots,
                scale_lots: autoState.scaleLots,
                max_lots_per_strike: autoState.maxLotsPerStrike,
                min_entry_gap_ms: autoState.minEntryGapMs,
                max_trades_per_min: autoState.maxTradesPerMin,
                max_qty: autoState.maxQty,
                min_move_pts: autoState.minMovePts,
                cooldown_after_loss_s: Math.round(autoState.cooldownMs / 1000),
                flip_cooldown_s: Math.round(autoState.flipCooldownMs / 1000),
                min_flip_hold_s: Math.round(autoState.minFlipHoldMs / 1000),
                per_trade_max_loss: autoState.perTradeMaxLoss,
                daily_max_loss: autoState.dailyMaxLoss,
                momentum_ticks: autoState.momentumTicks,
                candle_confirm_enabled: autoState.candleConfirmEnabled,
                candle_confirm_mode: autoState.candleConfirmMode,
                candle_confirm_ticks: autoState.candleMomentumTicks,
                underlying_direction_filter: autoState.underlyingFilterEnabled,
                underlying_momentum_ticks: autoState.underlyingMomentumTicks,
                relative_strength_enabled: autoState.relativeStrengthEnabled,
                relative_strength_diff: autoState.relativeStrengthDiff,
                index_bias_mode: autoState.indexBiasMode,
                index_bias_min_score: autoState.indexBiasMinScore,
                index_ema_enabled: autoState.indexEmaEnabled,
                index_vwap_enabled: autoState.indexVwapEnabled,
                index_rsi_enabled: autoState.indexRsiEnabled,
                index_adx_enabled: autoState.indexAdxEnabled,
                index_supertrend_enabled: autoState.indexSupertrendEnabled,
                index_rsi_bull: autoState.indexRsiBull,
                index_rsi_bear: autoState.indexRsiBear,
                index_adx_min: autoState.indexAdxMin,
                index_vwap_buffer: autoState.indexVwapBuffer,
                avg_window_s: Math.round(autoState.avgWindowMs / 1000),
                avg_interval_s: Math.round(autoState.avgIntervalMs / 1000),
                avg_enabled: autoState.avgEnabled,
                avg_only_profit: autoState.avgOnlyProfit,
                trail_distance: autoState.trailDistance,
                trail_step: autoState.trailStep,
                trailing_enabled: autoState.trailingEnabled,
                breakeven_enabled: autoState.breakevenEnabled,
                breakeven_delay_s: autoState.breakevenDelayMs / 1000,
                breakeven_buffer_pts: autoState.breakevenBufferPts,
                profit_lock_pts: autoState.profitLockPts,
                profit_lock_rs: autoState.profitLockRs,
                trailing_override_tp: autoState.trailingOverrideTP,
                tp_points: state.tpPoints,
                sl_points: state.slPoints,
                assist_only: autoState.assistOnly,
                paper_mode: autoState.paperMode,
                trade_mode: autoState.mode,
                reverse_trades: autoState.reverseTrades,
                rr_guard_enabled: autoState.rrGuardEnabled,
                strike_offset: autoState.strikeOffset,
                expiry_otm: autoState.expiryOtm,
                auto_roll: autoState.autoRoll,
                auto_roll_nifty: autoState.autoRollNifty,
                auto_roll_sensex: autoState.autoRollSensex,
                spread_max_nifty: autoState.spreadMaxNifty,
                spread_max_sensex: autoState.spreadMaxSensex,
                time_exit_tighten_pts: autoState.timeExitTightenPts,
                max_trade_duration_s: Math.round(autoState.tradeMaxDurationMs / 1000),
                enable_imbalance: autoState.imbalanceEnabled,
                imbalance_ratio: autoState.imbalanceRatio,
                enable_spread_filter: true,
                enable_depth: depthState.enabled,
                depth_level: depthState.level,
                tick_size: CONFIG.tickSize,
                advisor_enabled: autoState.advisorEnabled,
                advisor_auto_apply: autoState.advisorAutoApply,
                advisor_provider: advisorProvider,
                advisor_url: advisorUrl,
                advisor_model: advisorModel,
                advisor_base_url: advisorBaseUrl,
                learning_enabled: autoState.learningEnabled,
                learning_auto_apply: autoState.learningAutoApply,
                learning_exploration: autoState.learningExploration,
                learning_interval_s: Math.round(autoState.learningIntervalMs / 1000),
                learning_min_trades: autoState.learningMinTrades,
                telegram_alerts_enabled: autoState.telegramAlertsEnabled,
                telegram_alerts_entry: autoState.telegramAlertEntry,
                telegram_alerts_exit: autoState.telegramAlertExit,
                telegram_alerts_tune: autoState.telegramAlertTune
            };
        }

        async function setServerAutoEnabled(enabled) {
            if (enabled) {
                if (!state.symbol || !state.underlying || !state.expiry) {
                    showToast('Load a symbol first (open with chart params)', 'error');
                    return;
                }
                if (!state.apiKey) {
                    showToast('API key missing - connect first', 'error');
                    return;
                }
                if (autoState.advisorEnabled) {
                    const provider = autoState.advisorProvider;
                    const needsModel = provider === 'openai' || provider === 'anthropic' || provider === 'ollama';
                    if (needsModel && !autoState.advisorModel) {
                        showToast('LLM model required for selected provider', 'error');
                        // fallback to local auto mode
                        autoState.serverMode = false;
                        if (autoUi.serverToggle) autoUi.serverToggle.checked = false;
                        showToast('Server start failed - switched to local auto', 'info');
                        return;
                    }
                }
                const payload = buildServerPayload();
                const result = await postJson('/ai_scalper/start', payload);
                if (!result.ok || result.data?.status === 'error') {
                    showToast(result.data?.message || 'Server auto start failed', 'error');
                    autoState.serverMode = false;
                    if (autoUi.serverToggle) autoUi.serverToggle.checked = false;
                    showToast('Server start failed - switched to local auto', 'info');
                    return;
                }
                autoState.enabled = true;
                startBackendPoll();
                showToast('Server agent started', 'success');
            } else {
                const result = await postJson('/ai_scalper/stop', { reason: 'Manual stop' });
                if (!result.ok && result.data?.status === 'error') {
                    showToast(result.data?.message || 'Server auto stop failed', 'error');
                }
                autoState.enabled = false;
                autoState.backendStatus.enabled = false;
                updateAutoUI();
                showToast('Server agent stopped', 'info');
            }
        }

        async function handleAutoToggle() {
            if (autoState.serverMode) {
                await setServerAutoEnabled(!autoState.enabled);
                updateAutoUI();
                return;
            }
            setAutoEnabled(!autoState.enabled);
        }

        async function pushServerUpdate(payload) {
            if (!autoState.serverMode) return;
            await postJson('/ai_scalper/update', payload || {});
        }

        function notifyServerRestartNeeded() {
            if (!autoState.serverMode || !autoState.enabled) return;
            const now = Date.now();
            if (now - autoState.serverRestartNoticeTs < 5000) return;
            autoState.serverRestartNoticeTs = now;
            showToast('Server agent running: config changes apply after restart', 'info');
        }

        function initAutoPanel() {
            if (!autoUi.panel) return;

            setPresetDefaultsFromUnderlying();
            if (autoUi.entryLots) autoUi.entryLots.value = String(autoState.entryLots);
            if (autoUi.maxLots) autoUi.maxLots.value = String(autoState.maxLotsPerStrike);
            if (autoUi.minGap) autoUi.minGap.value = String(autoState.minEntryGapMs);
            if (autoUi.maxTrades) autoUi.maxTrades.value = String(autoState.maxTradesPerMin);
            if (autoUi.maxQty) autoUi.maxQty.value = String(autoState.maxQty);
            if (autoUi.minMove) autoUi.minMove.value = String(autoState.minMovePts);
            if (autoUi.cooldown) autoUi.cooldown.value = String(Math.round(autoState.cooldownMs / 1000));
            if (autoUi.perTradeLoss) autoUi.perTradeLoss.value = String(autoState.perTradeMaxLoss);
            if (autoUi.dailyLoss) autoUi.dailyLoss.value = String(autoState.dailyMaxLoss);
            if (autoUi.autoTpPoints) autoUi.autoTpPoints.value = String(state.tpPoints);
            if (autoUi.autoSlPoints) autoUi.autoSlPoints.value = String(state.slPoints);
            if (autoUi.momentumTicks) autoUi.momentumTicks.value = String(autoState.momentumTicks);
            if (autoUi.candleTicks) autoUi.candleTicks.value = String(autoState.candleMomentumTicks);
            if (autoUi.candleMode) autoUi.candleMode.value = autoState.candleConfirmMode;
            if (autoUi.underlyingTicks) autoUi.underlyingTicks.value = String(autoState.underlyingMomentumTicks);
            if (autoUi.minFlipHold) autoUi.minFlipHold.value = String(Math.round(autoState.minFlipHoldMs / 1000));
            if (autoUi.avgWindow) autoUi.avgWindow.value = String(Math.round(autoState.avgWindowMs / 1000));
            if (autoUi.avgInterval) autoUi.avgInterval.value = String(autoState.avgIntervalMs);
            if (autoUi.trailDistance) autoUi.trailDistance.value = String(autoState.trailDistance);
            if (autoUi.trailStep) autoUi.trailStep.value = String(autoState.trailStep);
            if (autoUi.beDelay) autoUi.beDelay.value = String(autoState.breakevenDelayMs);
            if (autoUi.beBuffer) autoUi.beBuffer.value = String(autoState.breakevenBufferPts);
            if (autoUi.profitLock) autoUi.profitLock.value = String(autoState.profitLockPts);
            if (autoUi.profitLockRs) autoUi.profitLockRs.value = String(autoState.profitLockRs);
            if (autoUi.strikeOffset) autoUi.strikeOffset.value = autoState.strikeOffset;
            if (autoUi.indexBiasMode) autoUi.indexBiasMode.value = autoState.indexBiasMode;
            if (autoUi.indexBiasMin) autoUi.indexBiasMin.value = String(autoState.indexBiasMinScore);
            if (autoUi.indexRsiBull) autoUi.indexRsiBull.value = String(autoState.indexRsiBull);
            if (autoUi.indexRsiBear) autoUi.indexRsiBear.value = String(autoState.indexRsiBear);
            if (autoUi.indexAdxMin) autoUi.indexAdxMin.value = String(autoState.indexAdxMin);
            if (autoUi.indexVwapBuffer) autoUi.indexVwapBuffer.value = String(autoState.indexVwapBuffer);
            if (autoUi.indexEmaToggle) autoUi.indexEmaToggle.checked = autoState.indexEmaEnabled;
            if (autoUi.indexVwapToggle) autoUi.indexVwapToggle.checked = autoState.indexVwapEnabled;
            if (autoUi.indexRsiToggle) autoUi.indexRsiToggle.checked = autoState.indexRsiEnabled;
            if (autoUi.indexAdxToggle) autoUi.indexAdxToggle.checked = autoState.indexAdxEnabled;
            if (autoUi.indexSupertrendToggle) autoUi.indexSupertrendToggle.checked = autoState.indexSupertrendEnabled;
            syncProfitLockPtsInput();
            if (autoUi.presetSelect) {
                autoUi.presetSelect.value = autoState.presetKey || '';
            }
            if (autoState.presetKey && !autoState.presetApplied) {
                applyAutoPreset(autoState.presetKey, { silent: true });
            }
            if (autoUi.underlyingFilter) autoUi.underlyingFilter.checked = autoState.underlyingFilterEnabled;
            if (autoUi.candleConfirm) autoUi.candleConfirm.checked = autoState.candleConfirmEnabled;
            if (autoUi.relativeStrength) autoUi.relativeStrength.checked = autoState.relativeStrengthEnabled;
            if (autoUi.checklistToggle) autoUi.checklistToggle.checked = autoState.checklistEnabled;
            if (autoUi.checklistPanel) autoUi.checklistPanel.style.display = autoState.checklistEnabled ? 'block' : 'none';
            if (autoUi.reverseToggle) autoUi.reverseToggle.checked = autoState.reverseTrades;
            if (autoUi.avgEnabledToggle) autoUi.avgEnabledToggle.checked = autoState.avgEnabled;
            if (autoUi.avgOnlyProfitToggle) autoUi.avgOnlyProfitToggle.checked = autoState.avgOnlyProfit;
            if (autoUi.rrGuardToggle) autoUi.rrGuardToggle.checked = autoState.rrGuardEnabled;
            if (autoUi.imbalanceToggle) autoUi.imbalanceToggle.checked = autoState.imbalanceEnabled;
            if (autoUi.imbalanceRatio) autoUi.imbalanceRatio.value = String(autoState.imbalanceRatio);
            if (autoUi.trailingToggle) autoUi.trailingToggle.checked = autoState.trailingEnabled;
            if (autoUi.breakevenToggle) autoUi.breakevenToggle.checked = autoState.breakevenEnabled;
            if (autoUi.overrideTp) autoUi.overrideTp.checked = autoState.trailingOverrideTP;
            if (autoUi.paperToggle) autoUi.paperToggle.checked = autoState.paperMode;
            if (autoUi.brokerPnlToggle) autoUi.brokerPnlToggle.checked = autoState.useBrokerPnl;
            if (autoUi.expiryOtm) autoUi.expiryOtm.checked = autoState.expiryOtm;
            if (autoUi.assistToggle) autoUi.assistToggle.checked = autoState.assistOnly;
            if (autoUi.advisorToggle) autoUi.advisorToggle.checked = autoState.advisorEnabled;
            if (autoUi.advisorAutoApply) autoUi.advisorAutoApply.checked = autoState.advisorAutoApply;
            if (autoUi.advisorProvider) autoUi.advisorProvider.value = autoState.advisorProvider;
            updateAdvisorPresets(autoState.advisorProvider);
            if (autoUi.advisorModel) autoUi.advisorModel.value = autoState.advisorModel || '';
            if (autoUi.advisorBaseUrl) autoUi.advisorBaseUrl.value = autoState.advisorBaseUrl || '';
            if (autoUi.advisorUrl) autoUi.advisorUrl.value = autoState.advisorUrl || '';
            if (autoUi.learningToggle) autoUi.learningToggle.checked = autoState.learningEnabled;
            if (autoUi.learningAutoApply) autoUi.learningAutoApply.checked = autoState.learningAutoApply;
            if (autoUi.learningExplore) autoUi.learningExplore.value = String(autoState.learningExploration);
            if (autoUi.learningInterval) autoUi.learningInterval.value = String(Math.round(autoState.learningIntervalMs / 1000));
            if (autoUi.learningMinTrades) autoUi.learningMinTrades.value = String(autoState.learningMinTrades);
            if (autoUi.telegramToggle) autoUi.telegramToggle.checked = autoState.telegramAlertsEnabled;
            if (autoUi.telegramEntry) autoUi.telegramEntry.checked = autoState.telegramAlertEntry;
            if (autoUi.telegramExit) autoUi.telegramExit.checked = autoState.telegramAlertExit;
            if (autoUi.telegramTune) autoUi.telegramTune.checked = autoState.telegramAlertTune;

            enforceRrGuard();
            syncBrokerPnlPolling();

            if (autoUi.toggleBtn) {
                autoUi.toggleBtn.addEventListener('click', () => {
                    handleAutoToggle();
                });
            }

            if (autoUi.serverToggle) {
                autoUi.serverToggle.addEventListener('change', async (e) => {
                    const enable = e.target.checked;
                    if (enable) {
                        if (autoState.enabled) {
                            setAutoEnabled(false, 'Switched to server agent');
                        }
                        autoState.serverMode = true;
                        startBackendPoll();
                        showToast('Server agent mode enabled', 'info');
                    } else {
                        if (autoState.enabled) {
                            await setServerAutoEnabled(false);
                        }
                        autoState.serverMode = false;
                        stopBackendPoll();
                        autoState.backendStatus = {
                            running: false,
                            enabled: false,
                            playbook: '--',
                            lastSignal: '--',
                            pnl: { daily: 0, open: 0, realized: 0 }
                        };
                        showToast('Local auto mode enabled', 'info');
                    }
                    updateAutoUI();
                    syncBrokerPnlPolling();
                });
            }

            if (autoUi.modeGroup) {
                autoUi.modeGroup.querySelectorAll('.auto-mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        setAutoMode(btn.dataset.mode);
                    });
                });
            }
            if (autoUi.presetApply) {
                autoUi.presetApply.addEventListener('click', () => {
                    const key = autoUi.presetSelect?.value;
                    if (!key) {
                        showToast('Select a preset first', 'info');
                        return;
                    }
                    applyAutoPreset(key);
                });
            }
            if (autoUi.presetSelect) {
                autoUi.presetSelect.addEventListener('change', (e) => {
                    autoState.presetKey = e.target.value || '';
                });
            }

            if (autoUi.paperToggle) {
                autoUi.paperToggle.addEventListener('change', (e) => {
                    setAutoPaperMode(e.target.checked);
                });
            }
            if (autoUi.brokerPnlToggle) {
                autoUi.brokerPnlToggle.addEventListener('change', (e) => {
                    if (!autoState.paperMode && !autoState.serverMode && !e.target.checked) {
                        showToast('Broker P&L is always ON in live mode', 'info');
                        e.target.checked = true;
                    }
                    autoState.useBrokerPnl = e.target.checked;
                    syncBrokerPnlPolling();
                    updateAutoStatsUI();
                });
            }
            if (autoUi.assistToggle) {
                autoUi.assistToggle.addEventListener('change', (e) => {
                    autoState.assistOnly = e.target.checked;
                    showToast(autoState.assistOnly ? 'Auto: Suggest only' : 'Auto: Live execution', 'info');
                    if (autoState.serverMode && autoState.enabled) {
                        pushServerUpdate({ assist_only: autoState.assistOnly });
                    }
                });
            }
            if (autoUi.advisorToggle) {
                autoUi.advisorToggle.addEventListener('change', (e) => {
                    autoState.advisorEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorAutoApply) {
                autoUi.advisorAutoApply.addEventListener('change', (e) => {
                    autoState.advisorAutoApply = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorProvider) {
                autoUi.advisorProvider.addEventListener('change', (e) => {
                    autoState.advisorProvider = e.target.value;
                    if (autoState.advisorProvider === 'stub') {
                        autoState.advisorUrl = '/ai_scalper/advisor_stub';
                    }
                    updateAdvisorPresets(autoState.advisorProvider);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorModelPreset) {
                autoUi.advisorModelPreset.addEventListener('change', (e) => {
                    const selected = e.target.value;
                    if (selected) {
                        autoState.advisorModel = selected;
                        if (autoUi.advisorModel) autoUi.advisorModel.value = selected;
                        notifyServerRestartNeeded();
                    }
                });
            }
            if (autoUi.advisorModel) {
                autoUi.advisorModel.addEventListener('change', (e) => {
                    autoState.advisorModel = (e.target.value || '').trim();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorBaseUrl) {
                autoUi.advisorBaseUrl.addEventListener('change', (e) => {
                    autoState.advisorBaseUrl = (e.target.value || '').trim();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorUrl) {
                autoUi.advisorUrl.addEventListener('change', (e) => {
                    const raw = (e.target.value || '').trim();
                    autoState.advisorUrl = raw || '/ai_scalper/advisor_stub';
                    if (autoState.advisorProvider === 'custom') {
                        autoState.advisorProvider = 'custom';
                    }
                    e.target.value = autoState.advisorUrl;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorStubBtn) {
                autoUi.advisorStubBtn.addEventListener('click', () => {
                    autoState.advisorUrl = '/ai_scalper/advisor_stub';
                    autoState.advisorProvider = 'stub';
                    if (autoUi.advisorUrl) autoUi.advisorUrl.value = autoState.advisorUrl;
                    if (autoUi.advisorProvider) autoUi.advisorProvider.value = autoState.advisorProvider;
                    updateAdvisorPresets(autoState.advisorProvider);
                    showToast('LLM Advisor set to local stub', 'info');
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.advisorTestBtn) {
                autoUi.advisorTestBtn.addEventListener('click', () => {
                    testAdvisor();
                });
            }

            if (autoUi.learningToggle) {
                autoUi.learningToggle.addEventListener('change', (e) => {
                    autoState.learningEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.learningAutoApply) {
                autoUi.learningAutoApply.addEventListener('change', (e) => {
                    autoState.learningAutoApply = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.learningExplore) {
                autoUi.learningExplore.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 0, 0.5, autoState.learningExploration);
                    autoState.learningExploration = val;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.learningInterval) {
                autoUi.learningInterval.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 15, 300, autoState.learningIntervalMs / 1000);
                    autoState.learningIntervalMs = val * 1000;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.learningMinTrades) {
                autoUi.learningMinTrades.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 3, 50, autoState.learningMinTrades);
                    autoState.learningMinTrades = val;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.telegramToggle) {
                autoUi.telegramToggle.addEventListener('change', (e) => {
                    autoState.telegramAlertsEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.telegramEntry) {
                autoUi.telegramEntry.addEventListener('change', (e) => {
                    autoState.telegramAlertEntry = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.telegramExit) {
                autoUi.telegramExit.addEventListener('change', (e) => {
                    autoState.telegramAlertExit = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.telegramTune) {
                autoUi.telegramTune.addEventListener('change', (e) => {
                    autoState.telegramAlertTune = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }

            fetchAdvisorKeyStatus();
            setInterval(fetchAdvisorKeyStatus, 10000);

            if (autoUi.logExportBtn) {
                autoUi.logExportBtn.addEventListener('click', () => {
                    exportAutoTradeLog();
                });
            }
            if (autoUi.logExportDbBtn) {
                autoUi.logExportDbBtn.addEventListener('click', () => {
                    exportAutoTradeLogDb();
                });
            }
            if (autoUi.logModeFilter) {
                autoUi.logModeFilter.addEventListener('change', () => {
                    loadAutoTradeLog({ reset: true });
                });
            }
            if (autoUi.pnlResetBtn) {
                autoUi.pnlResetBtn.addEventListener('click', () => {
                    resetAutoPnl('Auto P&L reset');
                });
            }
            loadAutoTradeLog();

            if (autoUi.learningRefreshBtn) {
                autoUi.learningRefreshBtn.addEventListener('click', () => {
                    refreshLearningDashboard();
                });
            }
            if (autoUi.learningReplayBtn) {
                autoUi.learningReplayBtn.addEventListener('click', () => {
                    runReplay();
                });
            }
            if (autoUi.learningReplayExport) {
                autoUi.learningReplayExport.addEventListener('click', () => {
                    exportLearningReplay();
                });
            }
            if (autoUi.learningTradesRefreshBtn) {
                autoUi.learningTradesRefreshBtn.addEventListener('click', () => {
                    refreshLearningDashboard();
                });
            }

            if (autoUi.entryLots) {
                autoUi.entryLots.addEventListener('change', (e) => {
                    autoState.entryLots = clampNumber(e.target.value, 1, 5, autoState.entryLots);
                    e.target.value = String(autoState.entryLots);
                    syncProfitLockPtsInput();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.maxLots) {
                autoUi.maxLots.addEventListener('change', (e) => {
                    autoState.maxLotsPerStrike = clampNumber(e.target.value, 1, 10, autoState.maxLotsPerStrike);
                    e.target.value = String(autoState.maxLotsPerStrike);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.minGap) {
                autoUi.minGap.addEventListener('change', (e) => {
                    autoState.minEntryGapMs = clampNumber(e.target.value, 500, 5000, autoState.minEntryGapMs);
                    e.target.value = String(autoState.minEntryGapMs);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.maxTrades) {
                autoUi.maxTrades.addEventListener('change', (e) => {
                    autoState.maxTradesPerMin = clampNumber(e.target.value, 1, 60, autoState.maxTradesPerMin);
                    e.target.value = String(autoState.maxTradesPerMin);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.maxQty) {
                autoUi.maxQty.addEventListener('change', (e) => {
                    autoState.maxQty = clampNumber(e.target.value, 0, 100000, autoState.maxQty);
                    e.target.value = String(autoState.maxQty);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.minMove) {
                autoUi.minMove.addEventListener('change', (e) => {
                    autoState.minMovePts = clampNumber(e.target.value, 0, 100, autoState.minMovePts);
                    e.target.value = String(autoState.minMovePts);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.cooldown) {
                autoUi.cooldown.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 5, 120, autoState.cooldownMs / 1000);
                    autoState.cooldownMs = val * 1000;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.perTradeLoss) {
                autoUi.perTradeLoss.addEventListener('change', (e) => {
                    autoState.perTradeMaxLoss = clampNumber(e.target.value, 100, 100000, autoState.perTradeMaxLoss);
                    e.target.value = String(autoState.perTradeMaxLoss);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.dailyLoss) {
                autoUi.dailyLoss.addEventListener('change', (e) => {
                    autoState.dailyMaxLoss = clampNumber(e.target.value, 500, 200000, autoState.dailyMaxLoss);
                    e.target.value = String(autoState.dailyMaxLoss);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.autoTpPoints) {
                autoUi.autoTpPoints.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 1, 200, state.tpPoints);
                    state.tpPoints = val;
                    e.target.value = String(val);
                    const tpInput = document.getElementById('tpPointsInput');
                    if (tpInput) tpInput.value = String(val);
                    enforceRrGuard();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.autoSlPoints) {
                autoUi.autoSlPoints.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 1, 200, state.slPoints);
                    state.slPoints = val;
                    e.target.value = String(val);
                    const slInput = document.getElementById('slPointsInput');
                    if (slInput) slInput.value = String(val);
                    enforceRrGuard();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.momentumTicks) {
                autoUi.momentumTicks.addEventListener('change', (e) => {
                    autoState.momentumTicks = clampNumber(e.target.value, 2, 8, autoState.momentumTicks);
                    e.target.value = String(autoState.momentumTicks);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.candleTicks) {
                autoUi.candleTicks.addEventListener('change', (e) => {
                    autoState.candleMomentumTicks = clampNumber(e.target.value, 3, 12, autoState.candleMomentumTicks);
                    e.target.value = String(autoState.candleMomentumTicks);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.candleMode) {
                autoUi.candleMode.addEventListener('change', (e) => {
                    autoState.candleConfirmMode = (e.target.value || 'EMA9').toUpperCase();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.underlyingTicks) {
                autoUi.underlyingTicks.addEventListener('change', (e) => {
                    autoState.underlyingMomentumTicks = clampNumber(e.target.value, 1, 6, autoState.underlyingMomentumTicks);
                    e.target.value = String(autoState.underlyingMomentumTicks);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.minFlipHold) {
                autoUi.minFlipHold.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 1, 10, autoState.minFlipHoldMs / 1000);
                    autoState.minFlipHoldMs = val * 1000;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.avgWindow) {
                autoUi.avgWindow.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 5, 30, autoState.avgWindowMs / 1000);
                    autoState.avgWindowMs = val * 1000;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.avgInterval) {
                autoUi.avgInterval.addEventListener('change', (e) => {
                    autoState.avgIntervalMs = clampNumber(e.target.value, 1000, 5000, autoState.avgIntervalMs);
                    autoState.avgIntervalMinMs = Math.max(1000, autoState.avgIntervalMs - 500);
                    autoState.avgIntervalMaxMs = autoState.avgIntervalMs + 500;
                    e.target.value = String(autoState.avgIntervalMs);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.trailDistance) {
                autoUi.trailDistance.addEventListener('change', (e) => {
                    autoState.trailDistance = clampNumber(e.target.value, 0.5, 50, autoState.trailDistance);
                    e.target.value = String(autoState.trailDistance);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.trailStep) {
                autoUi.trailStep.addEventListener('change', (e) => {
                    autoState.trailStep = clampNumber(e.target.value, CONFIG.tickSize, 5, autoState.trailStep);
                    e.target.value = String(autoState.trailStep);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.beDelay) {
                autoUi.beDelay.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 0, 10000, autoState.breakevenDelayMs);
                    autoState.breakevenDelayMs = val;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.beBuffer) {
                autoUi.beBuffer.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 0, 10, autoState.breakevenBufferPts);
                    autoState.breakevenBufferPts = val;
                    e.target.value = String(val);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.profitLock) {
                autoUi.profitLock.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 0, 20, autoState.profitLockPts);
                    autoState.profitLockPts = val;
                    e.target.value = String(val);
                    if (autoState.profitLockRs) {
                        autoState.profitLockRs = 0;
                        if (autoUi.profitLockRs) autoUi.profitLockRs.value = '0';
                    }
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.profitLockRs) {
                autoUi.profitLockRs.addEventListener('change', (e) => {
                    const val = clampNumber(e.target.value, 0, 100000, autoState.profitLockRs);
                    autoState.profitLockRs = val;
                    e.target.value = String(val);
                    syncProfitLockPtsInput();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.strikeOffset) {
                autoUi.strikeOffset.addEventListener('change', (e) => {
                    autoState.strikeOffset = e.target.value || 'ATM';
                    if (autoState.enabled) {
                        updateAutoSymbols(getAutoEffectiveOffset());
                    }
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexBiasMode) {
                autoUi.indexBiasMode.addEventListener('change', (e) => {
                    autoState.indexBiasMode = (e.target.value || 'OFF').toUpperCase();
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexBiasMin) {
                autoUi.indexBiasMin.addEventListener('change', (e) => {
                    autoState.indexBiasMinScore = clampNumber(e.target.value, 1, 5, autoState.indexBiasMinScore);
                    e.target.value = String(autoState.indexBiasMinScore);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexRsiBull) {
                autoUi.indexRsiBull.addEventListener('change', (e) => {
                    autoState.indexRsiBull = clampNumber(e.target.value, 50, 80, autoState.indexRsiBull);
                    e.target.value = String(autoState.indexRsiBull);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexRsiBear) {
                autoUi.indexRsiBear.addEventListener('change', (e) => {
                    autoState.indexRsiBear = clampNumber(e.target.value, 20, 50, autoState.indexRsiBear);
                    e.target.value = String(autoState.indexRsiBear);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexAdxMin) {
                autoUi.indexAdxMin.addEventListener('change', (e) => {
                    autoState.indexAdxMin = clampNumber(e.target.value, 10, 50, autoState.indexAdxMin);
                    e.target.value = String(autoState.indexAdxMin);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexVwapBuffer) {
                autoUi.indexVwapBuffer.addEventListener('change', (e) => {
                    autoState.indexVwapBuffer = clampNumber(e.target.value, 0, 2000, autoState.indexVwapBuffer);
                    e.target.value = String(autoState.indexVwapBuffer);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexEmaToggle) {
                autoUi.indexEmaToggle.addEventListener('change', (e) => {
                    autoState.indexEmaEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexVwapToggle) {
                autoUi.indexVwapToggle.addEventListener('change', (e) => {
                    autoState.indexVwapEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexRsiToggle) {
                autoUi.indexRsiToggle.addEventListener('change', (e) => {
                    autoState.indexRsiEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexAdxToggle) {
                autoUi.indexAdxToggle.addEventListener('change', (e) => {
                    autoState.indexAdxEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.indexSupertrendToggle) {
                autoUi.indexSupertrendToggle.addEventListener('change', (e) => {
                    autoState.indexSupertrendEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.underlyingFilter) {
                autoUi.underlyingFilter.addEventListener('change', (e) => {
                    autoState.underlyingFilterEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.candleConfirm) {
                autoUi.candleConfirm.addEventListener('change', (e) => {
                    autoState.candleConfirmEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.relativeStrength) {
                autoUi.relativeStrength.addEventListener('change', (e) => {
                    autoState.relativeStrengthEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.checklistToggle) {
                autoUi.checklistToggle.addEventListener('change', (e) => {
                    autoState.checklistEnabled = e.target.checked;
                    if (autoUi.checklistPanel) {
                        autoUi.checklistPanel.style.display = autoState.checklistEnabled ? 'block' : 'none';
                    }
                    if (autoState.checklistEnabled) {
                        renderAutoChecklist(state.activeSide);
                    }
                });
            }
            if (autoUi.reverseToggle) {
                autoUi.reverseToggle.addEventListener('change', (e) => {
                    autoState.reverseTrades = e.target.checked;
                    showToast(autoState.reverseTrades ? 'Auto: Reverse entries ON' : 'Auto: Reverse entries OFF', 'info');
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.avgEnabledToggle) {
                autoUi.avgEnabledToggle.addEventListener('change', (e) => {
                    autoState.avgEnabled = e.target.checked;
                    if (!autoState.avgEnabled) {
                        autoState.avgSession.CE = null;
                        autoState.avgSession.PE = null;
                    }
                    showToast(autoState.avgEnabled ? 'Auto: Averaging ON' : 'Auto: Averaging OFF', 'info');
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.avgOnlyProfitToggle) {
                autoUi.avgOnlyProfitToggle.addEventListener('change', (e) => {
                    autoState.avgOnlyProfit = e.target.checked;
                    showToast(autoState.avgOnlyProfit ? 'Auto: Avg only +PnL' : 'Auto: Avg any time', 'info');
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.rrGuardToggle) {
                autoUi.rrGuardToggle.addEventListener('change', (e) => {
                    autoState.rrGuardEnabled = e.target.checked;
                    enforceRrGuard();
                    showToast(autoState.rrGuardEnabled ? 'Auto: TP ≥ SL guard ON' : 'Auto: TP ≥ SL guard OFF', 'info');
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.imbalanceToggle) {
                autoUi.imbalanceToggle.addEventListener('change', (e) => {
                    autoState.imbalanceEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.imbalanceRatio) {
                autoUi.imbalanceRatio.addEventListener('change', (e) => {
                    autoState.imbalanceRatio = clampNumber(e.target.value, 1, 5, autoState.imbalanceRatio);
                    e.target.value = String(autoState.imbalanceRatio);
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.trailingToggle) {
                autoUi.trailingToggle.addEventListener('change', (e) => {
                    autoState.trailingEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.breakevenToggle) {
                autoUi.breakevenToggle.addEventListener('change', (e) => {
                    autoState.breakevenEnabled = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.overrideTp) {
                autoUi.overrideTp.addEventListener('change', (e) => {
                    autoState.trailingOverrideTP = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }
            if (autoUi.expiryOtm) {
                autoUi.expiryOtm.addEventListener('change', (e) => {
                    autoState.expiryOtm = e.target.checked;
                    notifyServerRestartNeeded();
                });
            }

            updateAutoUI();
        }

        function setAutoMode(mode) {
            const normalized = mode === 'CE' ? 'CE' : mode === 'PE' ? 'PE' : 'AUTO';
            autoState.mode = normalized;
            if (autoUi.modeGroup) {
                autoUi.modeGroup.querySelectorAll('.auto-mode-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === normalized);
                });
            }
            showToast(`Auto mode: ${normalized}`, 'info');
            if (autoState.serverMode && autoState.enabled) {
                pushServerUpdate({ trade_mode: normalized });
            }
        }

        function setAutoPaperMode(isPaper) {
            autoState.paperMode = !!isPaper;
            enforceBrokerPnlMode();
            updateAutoUI();
            showToast(autoState.paperMode ? 'Auto: Paper mode' : 'Auto: Live mode', 'info');
            if (autoState.serverMode && autoState.enabled) {
                pushServerUpdate({ paper_mode: autoState.paperMode });
            }
        }

        function setAutoEnabled(enabled, reason = '') {
            if (autoState.serverMode) {
                return;
            }
            if (enabled && autoState.dailyLossHit) {
                autoState.dailyLossHit = false;
            }
            if (enabled) {
                if (!state.symbol || !state.underlying || !state.expiry) {
                    showToast('Load a symbol first (open with chart params)', 'error');
                    autoState.enabled = false;
                    updateAutoUI();
                    return;
                }
                if (!state.apiKey) {
                    showToast('API key missing - connect first', 'error');
                    autoState.enabled = false;
                    updateAutoUI();
                    return;
                }
            }
            autoState.enabled = !!enabled;
            autoState.lastEntryTs = 0;
            autoState.cooldownUntil = 0;
            if (!autoState.enabled) {
                clearAutoSessions();
                cancelAutoPendingOrders();
                closeAutoPositions(reason || 'Auto disabled');
            } else {
                updateAutoSymbols(getAutoEffectiveOffset());
            }
            updateAutoUI();
            if (reason) {
                showToast(reason, autoState.enabled ? 'success' : 'info');
            }
        }

        function clearAutoSessions() {
            autoState.avgSession.CE = null;
            autoState.avgSession.PE = null;
            autoState.trailingAnchor.CE = null;
            autoState.trailingAnchor.PE = null;
            autoState.activeTradeId.CE = null;
            autoState.activeTradeId.PE = null;
            autoState.pendingExitMeta.CE = null;
            autoState.pendingExitMeta.PE = null;
            autoState.pendingOrders.clear();
            autoState.pendingPositionTag.CE = null;
            autoState.pendingPositionTag.PE = null;
            autoState.paperPositions.CE = null;
            autoState.paperPositions.PE = null;
            autoState.positionEntryTs.CE = null;
            autoState.positionEntryTs.PE = null;
            autoState.momentumDir.CE = null;
            autoState.momentumDir.PE = null;
            autoState.momentumCount.CE = 0;
            autoState.momentumCount.PE = 0;
            autoState.lastTick.CE = null;
            autoState.lastTick.PE = null;
            autoState.underlyingMomentumDir = null;
            autoState.underlyingMomentumCount = 0;
            autoState.underlyingLastTick = null;
            autoState.tradeTimestamps = [];
        }

        function cancelAutoPendingOrders() {
            if (state.orders.size === 0) return;
            state.orders.forEach(order => {
                if (order.autoTag) {
                    cancelSingleOrder(order.orderId, order.symbol);
                }
            });
        }

        function pruneAutoTradesWindow() {
            const cutoff = Date.now() - 60000;
            autoState.tradeTimestamps = autoState.tradeTimestamps.filter(ts => ts >= cutoff);
        }

        function getAutoMaxQty() {
            if (autoState.maxQty && autoState.maxQty > 0) return autoState.maxQty;
            const lotSize = state.lotSize || 1;
            return Math.max(1, Math.round(autoState.maxLotsPerStrike * lotSize));
        }

        function getAutoAvgIntervalMs() {
            const min = autoState.avgIntervalMinMs;
            const max = autoState.avgIntervalMaxMs;
            if (Number.isFinite(min) && Number.isFinite(max) && max > min) {
                return Math.round(min + Math.random() * (max - min));
            }
            return autoState.avgIntervalMs;
        }

        const AUTO_PRESETS = {
            sensex_expiry: {
                label: 'Sensex Expiry (fast)',
                momentumTicks: 6,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 3000,
                maxTradesPerMin: 6,
                minMovePts: 1,
                minFlipHoldMs: 5000,
                avgWindowMs: 15000,
                avgIntervalMs: 5000,
                trailDistance: 3.5,
                trailStep: 0.1,
                beDelayMs: 2000,
                beBufferPts: 0.5,
                profitLockRs: 60,
                tpPoints: 10,
                slPoints: 5,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: true,
                relativeStrengthEnabled: true,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.5,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 45000,
                flipCooldownMs: 15000,
                tradeMaxDurationMs: 180000,
                // Regime thresholds tuned for SENSEX expiry (wide swings)
                regimeVolatileThreshold: 8,
                regimeRangingThreshold: 3,
                // Trailing stages: fast breakeven, aggressive trail
                trailStage1Trigger: 2,
                trailStage2Trigger: 4,
                trailStage2SL: 1,
                trailStage3Trigger: 6,
                trailStage3Distance: 3,
                trailStage4Distance: 2,
                trailAccelMovePts: 4,
                trailAccelTimeMs: 8000,
                trailAccelDistance: 1.5,
                winStreakTrailDistance: 4
            },
            sensex_normal: {
                label: 'Sensex Normal',
                momentumTicks: 6,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 4000,
                maxTradesPerMin: 5,
                minMovePts: 1,
                minFlipHoldMs: 5000,
                avgWindowMs: 15000,
                avgIntervalMs: 5000,
                trailDistance: 3,
                trailStep: 0.1,
                beDelayMs: 3000,
                beBufferPts: 0.5,
                profitLockRs: 60,
                tpPoints: 9,
                slPoints: 5,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: true,
                relativeStrengthEnabled: true,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.5,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2.5,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 45000,
                flipCooldownMs: 15000,
                tradeMaxDurationMs: 180000,
                // Regime thresholds tuned for SENSEX normal (moderate swings)
                regimeVolatileThreshold: 5,
                regimeRangingThreshold: 2,
                // Trailing stages: slightly wider for normal pace
                trailStage1Trigger: 2.5,
                trailStage2Trigger: 4,
                trailStage2SL: 1,
                trailStage3Trigger: 6,
                trailStage3Distance: 3,
                trailStage4Distance: 2,
                trailAccelMovePts: 4,
                trailAccelTimeMs: 10000,
                trailAccelDistance: 1.5,
                winStreakTrailDistance: 4
            },
            nifty_expiry: {
                label: 'Nifty Expiry (fast)',
                momentumTicks: 6,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 3000,
                maxTradesPerMin: 6,
                minMovePts: 0.5,
                minFlipHoldMs: 5000,
                avgWindowMs: 15000,
                avgIntervalMs: 5000,
                trailDistance: 3,
                trailStep: 0.1,
                beDelayMs: 2000,
                beBufferPts: 0.5,
                profitLockRs: 60,
                tpPoints: 10,
                slPoints: 4,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: true,
                relativeStrengthEnabled: true,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.0,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 45000,
                flipCooldownMs: 15000,
                tradeMaxDurationMs: 180000,
                // Regime thresholds tuned for NIFTY expiry (fast moves)
                regimeVolatileThreshold: 6,
                regimeRangingThreshold: 2,
                // Trailing stages: fastest breakeven, tightest trail
                trailStage1Trigger: 1.5,
                trailStage2Trigger: 3,
                trailStage2SL: 0.5,
                trailStage3Trigger: 5,
                trailStage3Distance: 2.5,
                trailStage4Distance: 1.5,
                trailAccelMovePts: 3,
                trailAccelTimeMs: 8000,
                trailAccelDistance: 1,
                winStreakTrailDistance: 3.5
            },
            nifty_normal: {
                label: 'Nifty Normal',
                momentumTicks: 6,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 4000,
                maxTradesPerMin: 5,
                minMovePts: 0.5,
                minFlipHoldMs: 5000,
                avgWindowMs: 15000,
                avgIntervalMs: 5000,
                trailDistance: 2.5,
                trailStep: 0.1,
                beDelayMs: 3000,
                beBufferPts: 0.5,
                profitLockRs: 60,
                tpPoints: 8,
                slPoints: 4,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: true,
                relativeStrengthEnabled: true,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.0,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2.5,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 45000,
                flipCooldownMs: 15000,
                tradeMaxDurationMs: 180000,
                // Regime thresholds tuned for NIFTY normal (moderate moves)
                regimeVolatileThreshold: 4,
                regimeRangingThreshold: 1.5,
                // Trailing stages: balanced for normal pace
                trailStage1Trigger: 2,
                trailStage2Trigger: 3.5,
                trailStage2SL: 0.5,
                trailStage3Trigger: 5,
                trailStage3Distance: 2.5,
                trailStage4Distance: 1.5,
                trailAccelMovePts: 3.5,
                trailAccelTimeMs: 10000,
                trailAccelDistance: 1.5,
                winStreakTrailDistance: 3.5
            },
            sniper_quality: {
                label: '🎯 Sniper (Quality)',
                momentumTicks: 10,
                candleTicks: 8,
                underlyingTicks: 3,
                minGapMs: 180000,
                maxTradesPerMin: 1,
                minMovePts: 0.5,
                minFlipHoldMs: 10000,
                avgWindowMs: 30000,
                avgIntervalMs: 8000,
                trailDistance: 4,
                trailStep: 0.1,
                beDelayMs: 3000,
                beBufferPts: 0.5,
                profitLockRs: 100,
                tpPoints: 15,
                slPoints: 5,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: true,
                relativeStrengthEnabled: true,
                imbalanceEnabled: true,
                trailStaged: true,
                momentumMinMovePts: 2.5,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 4.0,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 120000,
                flipCooldownMs: 180000,
                tradeMaxDurationMs: 300000,
                consecutiveLossBreaker: 2,
                regimeTradingMode: 'trending_only',
                regimeVolatileThreshold: 6,
                regimeRangingThreshold: 2.5,
                trailStage1Trigger: 3.0,
                trailStage2Trigger: 5.0,
                trailStage2SL: 1.5,
                trailStage3Trigger: 10.0,
                trailStage3Distance: 4.0,
                trailStage4Distance: 3.0,
                trailAccelMovePts: 6,
                trailAccelTimeMs: 15000,
                trailAccelDistance: 2.5,
                winStreakTrailDistance: 5.0
            },
            momentum_scalper: {
                label: '⚡ Momentum Scalper',
                momentumTicks: 4,
                candleTicks: 3,
                underlyingTicks: 1,
                minGapMs: 5000,
                maxTradesPerMin: 10,
                minMovePts: 0.5,
                minFlipHoldMs: 3000,
                avgWindowMs: 10000,
                avgIntervalMs: 3000,
                trailDistance: 1.5,
                trailStep: 0.1,
                beDelayMs: 1000,
                beBufferPts: 0.5,
                profitLockRs: 40,
                tpPoints: 6,
                slPoints: 3,
                underlyingFilterEnabled: false,
                candleConfirmEnabled: false,
                relativeStrengthEnabled: false,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 0.5,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 1.0,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 15000,
                flipCooldownMs: 8000,
                tradeMaxDurationMs: 120000,
                consecutiveLossBreaker: 4,
                regimeTradingMode: 'all',
                regimeVolatileThreshold: 5,
                regimeRangingThreshold: 2,
                trailStage1Trigger: 1.0,
                trailStage2Trigger: 2.0,
                trailStage2SL: 0.5,
                trailStage3Trigger: 3.5,
                trailStage3Distance: 1.5,
                trailStage4Distance: 1.0,
                trailAccelMovePts: 2.5,
                trailAccelTimeMs: 5000,
                trailAccelDistance: 0.5,
                winStreakTrailDistance: 2.0
            },
            balanced_trader: {
                label: '⚖️ Balanced Trader',
                momentumTicks: 7,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 10000,
                maxTradesPerMin: 3,
                minMovePts: 0.5,
                minFlipHoldMs: 6000,
                avgWindowMs: 20000,
                avgIntervalMs: 5000,
                trailDistance: 2.5,
                trailStep: 0.1,
                beDelayMs: 2500,
                beBufferPts: 0.5,
                profitLockRs: 60,
                tpPoints: 10,
                slPoints: 4,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: false,
                relativeStrengthEnabled: false,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.5,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2.5,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 45000,
                flipCooldownMs: 30000,
                tradeMaxDurationMs: 180000,
                consecutiveLossBreaker: 3,
                regimeTradingMode: 'trending_volatile',
                regimeVolatileThreshold: 5,
                regimeRangingThreshold: 2,
                trailStage1Trigger: 2.0,
                trailStage2Trigger: 3.5,
                trailStage2SL: 1.0,
                trailStage3Trigger: 6.0,
                trailStage3Distance: 2.5,
                trailStage4Distance: 1.5,
                trailAccelMovePts: 4,
                trailAccelTimeMs: 10000,
                trailAccelDistance: 1.5,
                winStreakTrailDistance: 3.5
            },
            auto_adaptive: {
                label: '🤖 Auto (Adaptive)',
                // Base config - will be overridden by adaptive logic
                momentumTicks: 7,
                candleTicks: 5,
                underlyingTicks: 2,
                minGapMs: 10000,
                maxTradesPerMin: 5,
                minMovePts: 0.5,
                minFlipHoldMs: 5000,
                avgWindowMs: 15000,
                avgIntervalMs: 4000,
                trailDistance: 2.0,
                trailStep: 0.1,
                beDelayMs: 2000,
                beBufferPts: 0.5,
                profitLockRs: 50,
                tpPoints: 8,
                slPoints: 4,
                underlyingFilterEnabled: true,
                candleConfirmEnabled: false,
                relativeStrengthEnabled: false,
                imbalanceEnabled: false,
                trailStaged: true,
                momentumMinMovePts: 1.0,
                noTradeZoneEnabled: true,
                noTradeZoneRangePts: 2.0,
                partialExitEnabled: false,
                regimeDetectionEnabled: true,
                cooldownMs: 30000,
                flipCooldownMs: 20000,
                tradeMaxDurationMs: 150000,
                consecutiveLossBreaker: 3,
                regimeTradingMode: 'all',
                regimeVolatileThreshold: 5,
                regimeRangingThreshold: 2,
                trailStage1Trigger: 1.5,
                trailStage2Trigger: 3.0,
                trailStage2SL: 1.0,
                trailStage3Trigger: 5.0,
                trailStage3Distance: 2.0,
                trailStage4Distance: 1.2,
                trailAccelMovePts: 3.5,
                trailAccelTimeMs: 8000,
                trailAccelDistance: 1.0,
                winStreakTrailDistance: 3.0,
                // Adaptive-specific flags
                isAdaptive: true
            }
        };

        function setPresetDefaultsFromUnderlying() {
            if (autoState.presetKey) return;
            const underlying = (state.underlying || '').toUpperCase();
            const expiry = isExpiryDay();
            if (underlying.includes('SENSEX')) {
                autoState.presetKey = expiry ? 'sensex_expiry' : 'sensex_normal';
            } else if (underlying.includes('NIFTY')) {
                autoState.presetKey = expiry ? 'nifty_expiry' : 'nifty_normal';
            }
        }

        function applyAutoPreset(presetKey, options = {}) {
            const preset = AUTO_PRESETS[presetKey];
            if (!preset) return;

            autoState.presetKey = presetKey;
            autoState.momentumTicks = preset.momentumTicks ?? autoState.momentumTicks;
            autoState.candleMomentumTicks = preset.candleTicks ?? autoState.candleMomentumTicks;
            autoState.underlyingMomentumTicks = preset.underlyingTicks ?? autoState.underlyingMomentumTicks;
            autoState.minEntryGapMs = preset.minGapMs ?? autoState.minEntryGapMs;
            autoState.maxTradesPerMin = preset.maxTradesPerMin ?? autoState.maxTradesPerMin;
            autoState.minMovePts = preset.minMovePts ?? autoState.minMovePts;
            autoState.minFlipHoldMs = preset.minFlipHoldMs ?? autoState.minFlipHoldMs;
            autoState.avgWindowMs = preset.avgWindowMs ?? autoState.avgWindowMs;
            autoState.avgIntervalMs = preset.avgIntervalMs ?? autoState.avgIntervalMs;
            autoState.avgIntervalMinMs = Math.max(1000, autoState.avgIntervalMs - 500);
            autoState.avgIntervalMaxMs = autoState.avgIntervalMs + 500;
            autoState.trailDistance = preset.trailDistance ?? autoState.trailDistance;
            autoState.trailStep = Math.max(CONFIG.tickSize, preset.trailStep ?? autoState.trailStep);
            autoState.breakevenDelayMs = preset.beDelayMs ?? autoState.breakevenDelayMs;
            autoState.breakevenBufferPts = preset.beBufferPts ?? autoState.breakevenBufferPts;
            autoState.profitLockRs = preset.profitLockRs ?? autoState.profitLockRs;
            if (autoState.profitLockRs > 0) {
                autoState.profitLockPts = 0;
            }
            autoState.underlyingFilterEnabled = preset.underlyingFilterEnabled ?? autoState.underlyingFilterEnabled;
            autoState.candleConfirmEnabled = preset.candleConfirmEnabled ?? autoState.candleConfirmEnabled;
            autoState.relativeStrengthEnabled = preset.relativeStrengthEnabled ?? autoState.relativeStrengthEnabled;
            autoState.imbalanceEnabled = preset.imbalanceEnabled ?? autoState.imbalanceEnabled;

            // New Phase 2-6 fields
            autoState.trailStaged = preset.trailStaged ?? autoState.trailStaged;
            autoState.momentumMinMovePts = preset.momentumMinMovePts ?? autoState.momentumMinMovePts;
            autoState.noTradeZoneEnabled = preset.noTradeZoneEnabled ?? autoState.noTradeZoneEnabled;
            autoState.noTradeZoneRangePts = preset.noTradeZoneRangePts ?? autoState.noTradeZoneRangePts;
            autoState.partialExitEnabled = preset.partialExitEnabled ?? autoState.partialExitEnabled;
            autoState.regimeDetectionEnabled = preset.regimeDetectionEnabled ?? autoState.regimeDetectionEnabled;
            if (preset.cooldownMs != null) autoState.cooldownMs = preset.cooldownMs;
            if (preset.flipCooldownMs != null) autoState.flipCooldownMs = preset.flipCooldownMs;
            if (preset.tradeMaxDurationMs != null) autoState.tradeMaxDurationMs = preset.tradeMaxDurationMs;

            // Regime detection thresholds
            if (preset.regimeVolatileThreshold != null) autoState.regimeVolatileThreshold = preset.regimeVolatileThreshold;
            if (preset.regimeRangingThreshold != null) autoState.regimeRangingThreshold = preset.regimeRangingThreshold;

            // Trailing stage params
            if (preset.trailStage1Trigger != null) autoState.trailStage1Trigger = preset.trailStage1Trigger;
            if (preset.trailStage2Trigger != null) autoState.trailStage2Trigger = preset.trailStage2Trigger;
            if (preset.trailStage2SL != null) autoState.trailStage2SL = preset.trailStage2SL;
            if (preset.trailStage3Trigger != null) autoState.trailStage3Trigger = preset.trailStage3Trigger;
            if (preset.trailStage3Distance != null) autoState.trailStage3Distance = preset.trailStage3Distance;
            if (preset.trailStage4Distance != null) autoState.trailStage4Distance = preset.trailStage4Distance;
            if (preset.trailAccelMovePts != null) autoState.trailAccelMovePts = preset.trailAccelMovePts;
            if (preset.trailAccelTimeMs != null) autoState.trailAccelTimeMs = preset.trailAccelTimeMs;
            if (preset.trailAccelDistance != null) autoState.trailAccelDistance = preset.trailAccelDistance;
            if (preset.winStreakTrailDistance != null) autoState.winStreakTrailDistance = preset.winStreakTrailDistance;

            // Regime trading mode
            if (preset.regimeTradingMode != null) autoState.regimeTradingMode = preset.regimeTradingMode;
            if (preset.consecutiveLossBreaker != null) autoState.consecutiveLossBreaker = preset.consecutiveLossBreaker;

            if (preset.tpPoints != null) {
                state.tpPoints = preset.tpPoints;
            }
            if (preset.slPoints != null) {
                state.slPoints = preset.slPoints;
            }

            if (autoUi.momentumTicks) autoUi.momentumTicks.value = String(autoState.momentumTicks);
            if (autoUi.candleTicks) autoUi.candleTicks.value = String(autoState.candleMomentumTicks);
            if (autoUi.underlyingTicks) autoUi.underlyingTicks.value = String(autoState.underlyingMomentumTicks);
            if (autoUi.minGap) autoUi.minGap.value = String(autoState.minEntryGapMs);
            if (autoUi.maxTrades) autoUi.maxTrades.value = String(autoState.maxTradesPerMin);
            if (autoUi.minMove) autoUi.minMove.value = String(autoState.minMovePts);
            if (autoUi.minFlipHold) autoUi.minFlipHold.value = String(Math.round(autoState.minFlipHoldMs / 1000));
            if (autoUi.avgWindow) autoUi.avgWindow.value = String(Math.round(autoState.avgWindowMs / 1000));
            if (autoUi.avgInterval) autoUi.avgInterval.value = String(autoState.avgIntervalMs);
            if (autoUi.trailDistance) autoUi.trailDistance.value = String(autoState.trailDistance);
            if (autoUi.trailStep) autoUi.trailStep.value = String(autoState.trailStep);
            if (autoUi.beDelay) autoUi.beDelay.value = String(autoState.breakevenDelayMs);
            if (autoUi.beBuffer) autoUi.beBuffer.value = String(autoState.breakevenBufferPts);
            if (autoUi.profitLockRs) autoUi.profitLockRs.value = String(autoState.profitLockRs);
            if (autoUi.autoTpPoints) autoUi.autoTpPoints.value = String(state.tpPoints);
            if (autoUi.autoSlPoints) autoUi.autoSlPoints.value = String(state.slPoints);
            if (autoUi.underlyingFilter) autoUi.underlyingFilter.checked = autoState.underlyingFilterEnabled;
            if (autoUi.candleConfirm) autoUi.candleConfirm.checked = autoState.candleConfirmEnabled;
            if (autoUi.relativeStrength) autoUi.relativeStrength.checked = autoState.relativeStrengthEnabled;
            if (autoUi.imbalanceToggle) autoUi.imbalanceToggle.checked = autoState.imbalanceEnabled;

            enforceRrGuard();
            syncProfitLockPtsInput();
            updateAutoUI();
            autoState.presetApplied = true;
            if (!options.silent) {
                showToast(`Preset applied: ${preset.label}`, 'success');
            }
            if (autoState.serverMode && autoState.enabled) {
                notifyServerRestartNeeded();
            }
        }

        function updateLiveEntryFill(side, qty, price) {
            if (!side || !Number.isFinite(qty) || qty <= 0) return;
            if (!Number.isFinite(price) || price <= 0) return;
            const entry = autoState.liveEntry?.[side];
            if (!entry) return;
            const totalCost = (entry.avg * entry.qty) + (price * qty);
            entry.qty += qty;
            entry.avg = entry.qty > 0 ? totalCost / entry.qty : 0;
        }

        function reduceLiveEntry(side, qtyClosed) {
            const entry = autoState.liveEntry?.[side];
            if (!entry || !Number.isFinite(qtyClosed) || qtyClosed <= 0) return;
            if (qtyClosed >= entry.qty) {
                entry.qty = 0;
                entry.avg = 0;
                return;
            }
            entry.qty = Math.max(0, entry.qty - qtyClosed);
        }

        function getAutoProfitLockPts(qtyOverride = null) {
            const qty = qtyOverride || Math.round((autoState.entryLots || 1) * (state.lotSize || 1));
            const lockRs = Number(autoState.profitLockRs) || 0;
            if (lockRs > 0 && qty > 0) {
                return lockRs / qty;
            }
            return Number(autoState.profitLockPts) || 0;
        }

        function syncProfitLockPtsInput() {
            if (!autoUi.profitLock) return;
            if (!autoState.profitLockRs) return;
            const pts = getAutoProfitLockPts();
            if (Number.isFinite(pts)) {
                autoUi.profitLock.value = pts.toFixed(2);
            }
        }

        function isExpiryDay() {
            const expiryDate = parseExpiryDate(state.expiry);
            if (!expiryDate) return false;
            const now = new Date();
            return now.getFullYear() === expiryDate.getFullYear()
                && now.getMonth() === expiryDate.getMonth()
                && now.getDate() === expiryDate.getDate();
        }

        function getAutoSpreadMax() {
            const underlying = (state.underlying || '').toUpperCase();
            const base = underlying.includes('SENSEX') ? autoState.spreadMaxSensex : autoState.spreadMaxNifty;
            if (isExpiryAfterCutoff()) return base * 1.5;
            return base;
        }

        function autoSpreadOk(side) {
            if (side !== state.activeSide) return true;
            if (!Number.isFinite(depthState.topBidValue) || !Number.isFinite(depthState.topAskValue)) return true;
            const spread = depthState.topAskValue - depthState.topBidValue;
            return spread <= getAutoSpreadMax();
        }

        function getExpiryTimeProfile() {
            if (!isExpiryDay()) return null;
            const now = new Date();
            const minutes = now.getHours() * 60 + now.getMinutes();
            if (minutes >= 15 * 60) {
                return { tpPoints: 2, slPoints: 3 };
            }
            if (minutes >= 14 * 60 + 30) {
                return { tpPoints: 2, slPoints: 4 };
            }
            if (minutes >= 14 * 60) {
                return { tpPoints: 3, slPoints: 5 };
            }
            return null;
        }

        function getAutoTPSLPoints() {
            const profile = getExpiryTimeProfile();
            if (profile) {
                if (autoState.rrGuardEnabled && profile.tpPoints < profile.slPoints) {
                    return { tpPoints: profile.slPoints, slPoints: profile.slPoints };
                }
                return profile;
            }
            return { tpPoints: state.tpPoints, slPoints: state.slPoints };
        }

        function getAutoDailyPnl() {
            return autoState.realizedPnl + getAutoOpenPnl();
        }

        // Per-trade entry price: prefer auto-trade's own liveEntry tracking over broker position average
        function getAutoEntryPrice(side) {
            const liveAvg = autoState.liveEntry?.[side]?.avg;
            if (!autoState.paperMode && Number.isFinite(liveAvg) && liveAvg > 0) return liveAvg;
            const paper = autoState.paperPositions?.[side];
            if (autoState.paperMode && paper) return parseFloat(paper.average_price) || 0;
            const posState = getPositionState(side);
            return posState.entryPrice || parseFloat(posState.position?.average_price) || 0;
        }

        function getAutoOpenPnl() {
            let pnl = 0;
            ['CE', 'PE'].forEach(side => {
                const posState = getPositionState(side);
                const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
                if (!position || !position.auto) return;
                const qty = parseInt(position.quantity) || 0;
                if (!qty) return;
                const ctx = getContextForSide(side);
                const price = ctx?.currentPrice || 0;
                const entry = getAutoEntryPrice(side);
                if (!price || !entry) return;
                pnl += (price - entry) * qty;
            });
            return pnl;
        }

        function getAutoPositionPnl(side) {
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (!position || !position.auto) return null;
            const qty = parseInt(position.quantity) || 0;
            if (!qty) return 0;
            const ctx = getContextForSide(side);
            const price = ctx?.currentPrice || 0;
            const entry = getAutoEntryPrice(side);
            if (!price || !entry) return null;
            return (price - entry) * qty;
        }

        function isAutoPositionActive(side) {
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            return !!(position && position.auto);
        }

        function recordAutoEntry(side, lots, entryPrice) {
            autoState.lastEntryTs = Date.now();
            pruneAutoTradesWindow();
            autoState.tradeTimestamps.push(Date.now());

            if (!autoState.positionEntryTs[side]) {
                autoState.positionEntryTs[side] = Date.now();
            }
            if (!autoState.activeTradeId[side]) {
                autoState.activeTradeId[side] = generateEventId();
            }

            if (autoState.avgEnabled) {
                if (!autoState.avgSession[side]) {
                    autoState.avgSession[side] = {
                        startTs: Date.now(),
                        endTs: Date.now() + autoState.avgWindowMs,
                        nextTs: Date.now() + getAutoAvgIntervalMs(),
                        lotsAdded: lots
                    };
                } else {
                    autoState.avgSession[side].lotsAdded += lots;
                    autoState.avgSession[side].nextTs = Date.now() + getAutoAvgIntervalMs();
                }
            } else {
                autoState.avgSession[side] = null;
            }

            if (Number.isFinite(entryPrice)) {
                autoState.trailingAnchor[side] = entryPrice;
            }
            updateAutoStatsUI();
        }

        function recordAutoExit(side, exitPrice, reason, options = {}) {
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            const qty = parseInt(position?.quantity) || 0;
            const entry = getAutoEntryPrice(side);
            if (!qty || !entry || !Number.isFinite(exitPrice)) return;
            // Per-trade P&L: strictly (exit - entry) × qty, no cumulative mixing
            const pnl = (exitPrice - entry) * qty;
            // Sanity guard: cap at 2× SL worth of loss
            const maxReasonableLoss = qty * (state.slPoints || 5) * 2;
            const sanitizedPnl = (pnl < -maxReasonableLoss) ? -maxReasonableLoss : pnl;
            const entryTs = autoState.positionEntryTs?.[side] || 0;
            const holdMs = entryTs ? Math.max(0, Date.now() - entryTs) : null;
            const tradeId = autoState.activeTradeId?.[side] || null;
            // Always track local realized P&L for accurate display fallback
            autoState.realizedPnl += sanitizedPnl;
            // Track consecutive wins/losses
            if (sanitizedPnl >= 0) {
                autoState.consecutiveLosses = 0;
                autoState.winStreak = (autoState.winStreak || 0) + 1;
            } else {
                autoState.winStreak = 0;
                autoState.consecutiveLosses = (autoState.consecutiveLosses || 0) + 1;
                autoState.maxConsecLosses = Math.max(autoState.maxConsecLosses || 0, autoState.consecutiveLosses);
                if (autoState.consecutiveLosses >= autoState.consecutiveLossBreaker) {
                    autoState.cooldownUntil = Date.now() + autoState.consecutiveLossCooldownMs;
                    showToast(`${autoState.consecutiveLosses} consecutive losses — extended cooldown ${Math.round(autoState.consecutiveLossCooldownMs / 1000)}s`, 'error');
                }
            }
            // Track for re-entry
            if (sanitizedPnl > 0 && autoState.reEntryEnabled) {
                autoState.lastProfitableExitTs[side] = Date.now();
                autoState.lastProfitableExitSide[side] = side;
            }
            // Record trade in history for stats
            const tradeRecord = {
                side, entry, exit: exitPrice, qty, pnl: sanitizedPnl,
                reason, holdMs, ts: Date.now(), tradeId
            };
            autoState.tradeHistory.push(tradeRecord);
            if (autoState.tradeHistory.length > 200) autoState.tradeHistory.shift();
            // Equity curve
            autoState.equityCurve.push({ ts: Date.now(), pnl: autoState.realizedPnl });
            if (autoState.equityCurve.length > autoState.maxEquityCurvePoints) autoState.equityCurve.shift();

            autoState.avgSession[side] = null;
            autoState.trailingAnchor[side] = null;
            autoState.positionEntryTs[side] = null;
            if (autoState.lastExitPrice) {
                autoState.lastExitPrice[side] = exitPrice;
            }
            if (sanitizedPnl <= -autoState.perTradeMaxLoss) {
                autoState.cooldownUntil = Date.now() + autoState.cooldownMs;
            }
            if (!options.skipLog) {
                logAutoTrade({
                    type: 'EXIT',
                    mode: position?.paper ? 'PAPER' : 'LIVE',
                    side,
                    symbol: position?.symbol || getContextForSide(side)?.symbol || state.symbol,
                    action: 'SELL',
                    qty,
                    price: exitPrice,
                    pnl: sanitizedPnl,
                    reason,
                    exitReason: reason || 'Auto exit',
                    tradeId,
                    holdMs,
                    // Preset info
                    preset: autoState.presetKey || 'custom',
                    presetLabel: AUTO_PRESETS[autoState.presetKey]?.label || 'Custom',
                    adaptivePreset: autoState.currentAdaptivePreset || null,
                    adaptivePresetLabel: autoState.currentAdaptivePreset ? AUTO_PRESETS[autoState.currentAdaptivePreset]?.label : null,
                    // Exit quality metrics
                    regime: autoState.currentRegime || 'UNKNOWN',
                    regimeMode: autoState.regimeTradingMode || 'all',
                    trailStage: autoState.trailCurrentStage[side] || 0,
                    trailStaged: autoState.trailStaged,
                    entryPrice: entry,
                    exitPrice: exitPrice,
                    profitPts: parseFloat((exitPrice - entry).toFixed(2)),
                    profitPct: parseFloat(((exitPrice - entry) / entry * 100).toFixed(2)),
                    tpPoints: state.tpPoints,
                    slPoints: state.slPoints,
                    riskRewardRatio: state.tpPoints && state.slPoints ? parseFloat((state.tpPoints / state.slPoints).toFixed(2)) : null,
                    // Trade performance
                    consecutiveLosses: autoState.consecutiveLosses || 0,
                    winStreak: autoState.winStreak || 0,
                    sessionPnl: parseFloat((autoState.realizedPnl || 0).toFixed(0)),
                    tradeNumber: autoState.tradeHistory?.length || 0,
                    highWaterMark: autoState.positionHighPrice[side] || 0,
                    maxProfitPts: autoState.positionHighPrice[side] ? parseFloat((autoState.positionHighPrice[side] - entry).toFixed(2)) : null,
                    maxDrawdownPts: autoState.positionHighPrice[side] ? parseFloat((autoState.positionHighPrice[side] - exitPrice).toFixed(2)) : null,
                    partialExitDone: autoState.partialExitDone[side] || false,
                    // Trade quality score (1-5 stars based on outcome)
                    tradeQuality: sanitizedPnl >= state.tpPoints * qty * 0.8 ? 5 : // near full TP
                        sanitizedPnl >= state.tpPoints * qty * 0.5 ? 4 : // partial TP
                            sanitizedPnl > 0 ? 3 : // small profit
                                sanitizedPnl >= -state.slPoints * qty * 0.5 ? 2 : // small loss
                                    1 // full SL or worse
                });
                autoState.activeTradeId[side] = null;
                autoState.pendingExitMeta[side] = null;
            } else {
                autoState.pendingExitMeta[side] = { tradeId, holdMs };
                autoState.activeTradeId[side] = null;
            }
            // Reset AFTER logging so exit log captures the values
            autoState.positionHighPrice[side] = 0;
            autoState.trailCurrentStage[side] = 0;
            autoState.partialExitDone[side] = false;
            autoState.lastSignal[side] = `${reason || 'Exit'} ${sanitizedPnl >= 0 ? '+' : ''}${sanitizedPnl.toFixed(0)}`;
            updateAutoStatsUI();
            updateAutoSummaryStats();
            renderEquityCurve();
            showTradePopup(tradeRecord);
        }

        function handleAutoUnderlyingTick(ltp) {
            autoState.lastUnderlying = ltp;
            updateAutoUnderlyingMomentum(ltp);
            if (!autoState.enabled || !autoState.autoRoll) return;
            if (!Number.isFinite(ltp)) return;
            if (!autoState.lastRollUnderlying) {
                autoState.lastRollUnderlying = ltp;
                return;
            }
            const step = getUnderlyingStep();
            if (!step) return;
            if (Math.abs(ltp - autoState.lastRollUnderlying) >= step) {
                if (!autoCanRoll()) return;
                autoState.lastRollUnderlying = ltp;
                updateAutoSymbols(getAutoEffectiveOffset());
            }
        }

        function getUnderlyingStep() {
            const underlying = (state.underlying || '').toUpperCase();
            if (underlying.includes('SENSEX')) return autoState.autoRollSensex;
            return autoState.autoRollNifty;
        }

        function normalizeExpiry(raw) {
            if (!raw) return null;
            const cleaned = raw.toUpperCase().replace(/[^A-Z0-9]/g, '');
            if (cleaned.length === 7) return cleaned;
            if (cleaned.length >= 9) {
                return `${cleaned.slice(0, 2)}${cleaned.slice(2, 5)}${cleaned.slice(-2)}`;
            }
            return cleaned;
        }

        function parseExpiryDate(expiry) {
            const normalized = normalizeExpiry(expiry);
            if (!normalized || normalized.length < 7) return null;
            const match = normalized.match(/(\d{2})([A-Z]{3})(\d{2})/);
            if (!match) return null;
            const day = parseInt(match[1], 10);
            const monStr = match[2];
            const year = 2000 + parseInt(match[3], 10);
            const months = {
                JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5,
                JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11
            };
            const month = months[monStr];
            if (month === undefined) return null;
            return new Date(year, month, day);
        }

        function isExpiryAfterCutoff() {
            if (!autoState.expiryOtm) return false;
            const expiryDate = parseExpiryDate(state.expiry);
            if (!expiryDate) return false;
            const now = new Date();
            if (now.getFullYear() !== expiryDate.getFullYear() ||
                now.getMonth() !== expiryDate.getMonth() ||
                now.getDate() !== expiryDate.getDate()) {
                return false;
            }
            return now.getHours() >= 14;
        }

        function getAutoEffectiveOffset() {
            if (isExpiryAfterCutoff()) return 'OTM3';
            return autoState.strikeOffset || 'ATM';
        }

        function autoCanRoll() {
            if (state.orders.size > 0 || state.fakeLimitOrders.size > 0) return false;
            const hasPosition = ['CE', 'PE'].some(side => {
                const posState = getPositionState(side);
                const qty = parseInt(posState.position?.quantity) || 0;
                return qty !== 0;
            });
            return !hasPosition;
        }

        async function updateAutoSymbols(offset) {
            if (!autoState.enabled) return;
            if (!state.apiKey || !state.underlying || !state.underlyingExchange || !state.expiry) return;
            const expiry = normalizeExpiry(state.expiry);
            if (!expiry) return;

            try {
                const prevSymbol = state.symbol;
                const payloadBase = {
                    apikey: state.apiKey,
                    underlying: state.underlying,
                    exchange: state.underlyingExchange,
                    expiry_date: expiry,
                    offset: offset
                };
                const [ceResp, peResp] = await Promise.all([
                    fetch('/api/v1/optionsymbol', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...payloadBase, option_type: 'CE' })
                    }),
                    fetch('/api/v1/optionsymbol', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...payloadBase, option_type: 'PE' })
                    })
                ]);

                const ceResult = await ceResp.json();
                const peResult = await peResp.json();

                if (ceResult.status !== 'success' || peResult.status !== 'success') {
                    console.warn('Auto symbol resolve failed', ceResult, peResult);
                    return;
                }

                applySymbolUpdate('CE', ceResult.symbol, ceResult);
                applySymbolUpdate('PE', peResult.symbol, peResult);

                if (state.ws && state.ws.readyState === WebSocket.OPEN) {
                    state.ws.send(JSON.stringify({
                        action: 'subscribe',
                        symbols: [
                            { symbol: ceResult.symbol, exchange: state.exchange },
                            { symbol: peResult.symbol, exchange: state.exchange }
                        ],
                        mode: 'LTP'
                    }));
                }
                if (depthState.enabled && prevSymbol && prevSymbol !== state.symbol) {
                    unsubscribeDepth(prevSymbol);
                    subscribeDepth();
                }
                updateDepthSymbolUI();
                const strikeMatch = ceResult.symbol.match(/(\d+)(?=(CE|PE)$)/);
                if (strikeMatch) {
                    state.strike = strikeMatch[1];
                    document.getElementById('symbolTitle').textContent =
                        `${state.underlying} ${state.strike} CE/PE - ${state.expiry}`;
                }
            } catch (error) {
                console.error('Auto symbol update error:', error);
            }
        }

        function resetChartContextData(ctx) {
            if (!ctx?.series) return;
            ctx.candles = [];
            ctx.pendingCandle = null;
            ctx.currentPrice = 0;
            ctx.ema9Last = null;
            ctx.ema21Last = null;
            ctx.series.setData([]);
            ctx.ema9Series?.setData([]);
            ctx.ema21Series?.setData([]);
            ctx.supertrendSeries?.setData([]);
            ctx.vwapSeries?.setData([]);
            const oneDayAgo = Math.floor(Date.now() / 1000) - (24 * 60 * 60);
            ctx.series.setData([{
                time: oneDayAgo,
                open: 100,
                high: 200,
                low: 50,
                close: 150
            }]);
        }

        function applySymbolUpdate(side, symbol, meta) {
            if (!symbol) return;
            const ctx = getContextForSide(side);
            if (side === 'CE') {
                state.ceSymbol = symbol;
            } else {
                state.peSymbol = symbol;
            }
            if (ctx) {
                ctx.symbol = symbol;
                resetChartContextData(ctx);
            }
            clearPositionVisuals(side);
            if (meta && Number.isFinite(meta.lotsize)) {
                state.lotSize = parseInt(meta.lotsize, 10) || state.lotSize;
                syncProfitLockPtsInput();
            }
            if (meta && Number.isFinite(meta.tick_size)) {
                const rawTick = parseFloat(meta.tick_size);
                const normalizedTick = rawTick > 1 ? rawTick / 100 : rawTick;
                if (Number.isFinite(normalizedTick) && normalizedTick > 0) {
                    CONFIG.tickSize = normalizedTick;
                    autoState.trailStep = CONFIG.tickSize;
                    if (autoUi.trailStep) {
                        autoUi.trailStep.value = String(autoState.trailStep);
                    }
                }
            }

            if (state.activeSide === side) {
                state.symbol = symbol;
            }
        }

        function updateAutoMomentum(side, price) {
            const last = autoState.lastTick[side];
            if (!Number.isFinite(last)) {
                autoState.lastTick[side] = price;
                return;
            }
            let dir = null;
            if (price > last) dir = 'up';
            if (price < last) dir = 'down';
            if (!dir) {
                autoState.lastTick[side] = price;
                return;
            }
            if (autoState.momentumDir[side] === dir) {
                autoState.momentumCount[side] += 1;
            } else {
                autoState.momentumDir[side] = dir;
                autoState.momentumCount[side] = 1;
                autoState.momentumStartPrice = autoState.momentumStartPrice || {};
                autoState.momentumStartPrice[side] = last;
            }
            // Track recent prices for no-trade zone and regime detection
            if (!autoState.recentPrices[side]) autoState.recentPrices[side] = [];
            autoState.recentPrices[side].push({ price, ts: Date.now() });
            // Prune old entries every 20 ticks to avoid array churn
            if (autoState.recentPrices[side].length % 20 === 0) {
                const cutoff = Date.now() - Math.max(autoState.noTradeZoneWindowMs || 30000, autoState.regimeWindowMs || 60000);
                const arr = autoState.recentPrices[side];
                let i = 0;
                while (i < arr.length && arr[i].ts < cutoff) i++;
                if (i > 0) autoState.recentPrices[side] = arr.slice(i);
            }
            autoState.lastTick[side] = price;
        }

        function getMomentumVelocity(side) {
            const count = autoState.momentumCount[side] || 0;
            if (count < 2) return 0;
            const startPrice = autoState.momentumStartPrice?.[side];
            const currentPrice = autoState.lastTick[side];
            if (!Number.isFinite(startPrice) || !Number.isFinite(currentPrice)) return 0;
            return Math.abs(currentPrice - startPrice);
        }

        function isNoTradeZone(side) {
            if (!autoState.noTradeZoneEnabled) return false;
            const prices = autoState.recentPrices[side];
            if (!prices || prices.length < 5) return false;
            const cutoff = Date.now() - (autoState.noTradeZoneWindowMs || 30000);
            const windowPrices = prices.filter(p => p.ts >= cutoff);
            if (windowPrices.length < 5) return false;
            const values = windowPrices.map(p => p.price);
            const high = Math.max(...values);
            const low = Math.min(...values);
            return (high - low) < autoState.noTradeZoneRangePts;
        }

        function updateAutoUnderlyingMomentum(price) {
            const last = autoState.underlyingLastTick;
            if (!Number.isFinite(last)) {
                autoState.underlyingLastTick = price;
                return;
            }
            let dir = null;
            if (price > last) dir = 'up';
            if (price < last) dir = 'down';
            if (!dir) {
                autoState.underlyingLastTick = price;
                return;
            }
            if (autoState.underlyingMomentumDir === dir) {
                autoState.underlyingMomentumCount += 1;
            } else {
                autoState.underlyingMomentumDir = dir;
                autoState.underlyingMomentumCount = 1;
            }
            autoState.underlyingLastTick = price;
        }

        function getAutoMomentumThreshold() {
            if (autoState.candleConfirmEnabled) {
                return Math.max(autoState.momentumTicks, autoState.candleMomentumTicks);
            }
            return autoState.momentumTicks;
        }

        function autoUnderlyingOk(side) {
            if (!autoState.underlyingFilterEnabled) return true;
            if (!state.underlying) return true;
            if (!autoState.underlyingMomentumDir) return false;
            if (autoState.underlyingMomentumCount < autoState.underlyingMomentumTicks) return false;
            return side === 'CE'
                ? autoState.underlyingMomentumDir === 'up'
                : autoState.underlyingMomentumDir === 'down';
        }

        function getIndexBiasSnapshot() {
            const mode = (autoState.indexBiasMode || 'OFF').toUpperCase();
            const snapshot = { mode, score: 0, biasDir: null, signals: [], ready: false };
            if (mode === 'OFF') return snapshot;
            const minScore = Math.max(1, autoState.indexBiasMinScore || 1);
            const price = indexState.lastPrice;
            let score = 0;
            let readyCount = 0;
            const signals = [];
            const addSignal = (label, dir) => {
                if (dir > 0) {
                    score += 1;
                    signals.push(`${label}↑`);
                } else if (dir < 0) {
                    score -= 1;
                    signals.push(`${label}↓`);
                } else {
                    signals.push(`${label}·`);
                }
            };

            if (autoState.indexEmaEnabled) {
                if (Number.isFinite(indexState.ema9Last) && Number.isFinite(indexState.ema21Last)) {
                    readyCount += 1;
                    if (indexState.ema9Last > indexState.ema21Last) addSignal('EMA', 1);
                    else if (indexState.ema9Last < indexState.ema21Last) addSignal('EMA', -1);
                    else addSignal('EMA', 0);
                } else {
                    signals.push('EMA?');
                }
            }
            if (autoState.indexVwapEnabled) {
                const buffer = autoState.indexVwapBuffer || 0;
                if (Number.isFinite(price) && Number.isFinite(indexState.vwapLast)) {
                    readyCount += 1;
                    if (price > indexState.vwapLast + buffer) addSignal('VWAP', 1);
                    else if (price < indexState.vwapLast - buffer) addSignal('VWAP', -1);
                    else addSignal('VWAP', 0);
                } else {
                    signals.push('VWAP?');
                }
            }
            if (autoState.indexRsiEnabled) {
                const bull = autoState.indexRsiBull ?? 55;
                const bear = autoState.indexRsiBear ?? 45;
                if (Number.isFinite(indexState.rsiLast)) {
                    readyCount += 1;
                    if (indexState.rsiLast >= bull) addSignal('RSI', 1);
                    else if (indexState.rsiLast <= bear) addSignal('RSI', -1);
                    else addSignal('RSI', 0);
                } else {
                    signals.push('RSI?');
                }
            }
            if (autoState.indexAdxEnabled) {
                const adxMin = autoState.indexAdxMin ?? 18;
                if (Number.isFinite(indexState.adxLast) && Number.isFinite(indexState.diPlusLast) && Number.isFinite(indexState.diMinusLast)) {
                    readyCount += 1;
                    if (indexState.adxLast >= adxMin) {
                        if (indexState.diPlusLast > indexState.diMinusLast) addSignal('ADX', 1);
                        else if (indexState.diMinusLast > indexState.diPlusLast) addSignal('ADX', -1);
                        else addSignal('ADX', 0);
                    } else {
                        signals.push(`ADX<${adxMin}`);
                    }
                } else {
                    signals.push('ADX?');
                }
            }
            if (autoState.indexSupertrendEnabled) {
                if (Number.isFinite(price) && Number.isFinite(indexState.supertrendLast)) {
                    readyCount += 1;
                    if (price > indexState.supertrendLast) addSignal('ST', 1);
                    else if (price < indexState.supertrendLast) addSignal('ST', -1);
                    else addSignal('ST', 0);
                } else {
                    signals.push('ST?');
                }
            }

            snapshot.score = score;
            snapshot.ready = readyCount > 0;
            if (score >= minScore) snapshot.biasDir = 'BULL';
            else if (score <= -minScore) snapshot.biasDir = 'BEAR';
            snapshot.signals = signals;
            return snapshot;
        }

        function autoIndexBiasOk(side) {
            const snapshot = getIndexBiasSnapshot();
            if (snapshot.mode === 'OFF') return { ok: true, snapshot };
            if (!snapshot.biasDir) {
                if (snapshot.mode === 'STRONG') {
                    return { ok: false, snapshot, reason: 'Index bias neutral' };
                }
                return { ok: true, snapshot, reason: 'Index bias neutral' };
            }
            const bull = snapshot.biasDir === 'BULL';
            const wantsBull = side === 'CE';
            let ok = true;
            if (snapshot.mode === 'STRONG') {
                ok = bull === wantsBull;
            } else if (bull && side === 'PE') {
                ok = false;
            } else if (!bull && side === 'CE') {
                ok = false;
            }
            const reason = ok ? 'Index bias ok' : `Index bias ${bull ? 'bull' : 'bear'}`;
            return { ok, snapshot, reason };
        }

        function autoCandleConfirmOk(side) {
            if (!autoState.candleConfirmEnabled) return true;
            const ctx = getContextForSide(side);
            if (!ctx || !ctx.candles || ctx.candles.length < 2) return false;
            const last = ctx.candles[ctx.candles.length - 1];
            const prev = ctx.candles[ctx.candles.length - 2];
            if (!last || !prev) return false;
            const mode = (autoState.candleConfirmMode || 'EMA9').toUpperCase();
            if (mode === 'EMA9') {
                if (Number.isFinite(ctx.ema9Last)) {
                    return last.close > ctx.ema9Last;
                }
                return last.close > prev.close;
            }
            return last.close > prev.close;
        }

        function getAutoMomentumStrength(side) {
            const dir = autoState.momentumDir[side];
            const count = autoState.momentumCount[side] || 0;
            return dir === 'up' ? count : 0;
        }

        function autoRelativeStrengthOk(side) {
            if (!autoState.relativeStrengthEnabled) return true;
            const other = side === 'CE' ? 'PE' : 'CE';
            const strength = getAutoMomentumStrength(side);
            const otherStrength = getAutoMomentumStrength(other);
            return strength >= otherStrength + autoState.relativeStrengthDiff;
        }

        function autoMinHoldMet(side) {
            const entryTs = autoState.positionEntryTs[side];
            if (!entryTs) return true;
            return Date.now() - entryTs >= autoState.minFlipHoldMs;
        }

        function autoSideAllowed(side) {
            if (autoState.mode === 'AUTO') return true;
            return autoState.mode === side;
        }

        function getAutoGuardrailBlockReason(side, lots, isReEntry) {
            const now = Date.now();
            if (state.isClosingPosition) return 'Closing position';
            // Re-entry uses shorter cooldown
            const effectiveCooldown = isReEntry ? Math.min(autoState.cooldownMs, autoState.reEntryWindowMs) : 0;
            if (!isReEntry && autoState.cooldownUntil && now < autoState.cooldownUntil) return 'Cooldown active';
            if (autoState.flipCooldownUntil && now < autoState.flipCooldownUntil) return 'Flip cooldown';
            const minGap = isReEntry ? Math.min(autoState.minEntryGapMs, 5000) : autoState.minEntryGapMs;
            if (now - autoState.lastEntryTs < minGap) return `Min gap ${minGap}ms`;
            // Consecutive loss breaker: enforce longer cooldown after consecutive losses
            if (autoState.consecutiveLosses >= autoState.consecutiveLossBreaker) {
                const boostedCooldown = autoState.cooldownMs * 3;
                if (autoState.cooldownUntil && now < autoState.cooldownUntil + boostedCooldown) {
                    return `Loss breaker (${autoState.consecutiveLosses} losses)`;
                }
            }
            pruneAutoTradesWindow();
            if (autoState.tradeTimestamps.length >= autoState.maxTradesPerMin) return 'Max trades/min';

            // Regime trading mode check
            if (autoState.regimeTradingMode === 'trending_only') {
                if (autoState.currentRegime !== 'TRENDING') {
                    return `Regime: ${autoState.currentRegime || 'UNKNOWN'} (needs TRENDING)`;
                }
            } else if (autoState.regimeTradingMode === 'trending_volatile') {
                if (autoState.currentRegime === 'RANGING') {
                    return `Regime: RANGING (needs TRENDING or VOLATILE)`;
                }
            }

            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (position && !position.auto) return 'Manual position open';
            const existingQty = Math.abs(parseInt(position?.quantity) || 0);
            const lotSize = state.lotSize || 1;
            const nextQty = existingQty + Math.round(lots * lotSize);
            const maxQty = getAutoMaxQty();
            if (nextQty > maxQty) return `Max qty ${maxQty}`;
            return null;
        }

        function autoCanEnter(side, lots, isReEntry) {
            return !getAutoGuardrailBlockReason(side, lots, isReEntry);
        }

        function autoMinMoveOk(side, price) {
            const minMove = autoState.minMovePts;
            if (!Number.isFinite(minMove) || minMove <= 0) return true;
            const lastExit = autoState.lastExitPrice?.[side];
            if (!Number.isFinite(lastExit)) return true;
            return Math.abs(price - lastExit) >= minMove;
        }

        function autoImbalanceOk(side) {
            if (!autoState.imbalanceEnabled) return true;
            if (side !== state.activeSide) return false;
            if (!Number.isFinite(depthState.lastBidAskRatio)) return false;
            return depthState.lastBidAskRatio >= autoState.imbalanceRatio;
        }

        function renderAutoChecklist(side = state.activeSide) {
            if (!autoState.checklistEnabled || !autoUi.checklistList || !autoUi.checklistPanel) return;
            const items = [];
            const addItem = (label, ok, detail) => {
                const status = ok ? 'OK' : 'NO';
                const note = detail ? ` ${detail}` : '';
                items.push(`<div class="auto-log-item"><span class="tag">${status}</span> ${label}${note}</div>`);
            };

            addItem('Auto enabled', autoState.enabled, autoState.enabled ? 'ON' : 'OFF');
            if (autoState.serverMode && autoState.enabled) {
                addItem('Server agent', false, 'Local auto paused');
            }
            if (autoState.assistOnly) {
                addItem('Suggest only', false, 'No orders');
            }
            const reverseTarget = side === 'CE' ? 'PE' : 'CE';
            addItem('Reverse trades', true, autoState.reverseTrades ? `${side}→${reverseTarget}` : 'OFF');
            if (!autoState.avgEnabled) {
                addItem('Averaging', true, 'OFF');
            } else {
                addItem('Averaging', true, autoState.avgOnlyProfit ? '+PnL only' : 'Any time');
            }
            addItem('TP ≥ SL guard', true, autoState.rrGuardEnabled ? 'ON' : 'OFF');
            addItem('BE SL', true, autoState.breakevenEnabled ? 'ON' : 'OFF');

            const requiredTicks = getAutoMomentumThreshold();
            const momentumDir = autoState.momentumDir[side];
            const momentumCount = autoState.momentumCount[side] || 0;
            const momentumReady = momentumDir === 'up' && momentumCount >= requiredTicks;
            addItem(`Momentum ${momentumCount}/${requiredTicks}`, momentumReady, momentumDir ? momentumDir.toUpperCase() : '--');

            if (!autoState.underlyingFilterEnabled) {
                addItem('Underlying filter', true, 'OFF');
            } else {
                const ok = autoUnderlyingOk(side);
                let detail = 'OK';
                if (!autoState.underlyingMomentumDir) {
                    detail = 'No underlying ticks';
                } else {
                    detail = `${autoState.underlyingMomentumDir.toUpperCase()} ${autoState.underlyingMomentumCount}/${autoState.underlyingMomentumTicks}`;
                }
                addItem('Underlying filter', ok, detail);
            }

            const biasSide = autoState.reverseTrades ? (side === 'CE' ? 'PE' : 'CE') : side;
            const biasSnapshot = getIndexBiasSnapshot();
            if (biasSnapshot.mode === 'OFF') {
                addItem('Index bias', true, 'OFF');
            } else {
                const biasCheck = autoIndexBiasOk(biasSide);
                let detail = biasSnapshot.biasDir ? `${biasSnapshot.biasDir} ${biasSnapshot.score}` : `Neutral ${biasSnapshot.score}`;
                if (!biasSnapshot.ready) {
                    detail = 'Need index candles';
                } else if (biasSnapshot.signals.length) {
                    detail = `${detail} (${biasSnapshot.signals.join(', ')})`;
                }
                addItem('Index bias', biasCheck.ok, detail);
            }

            if (!autoState.candleConfirmEnabled) {
                addItem('Candle confirm', true, 'OFF');
            } else {
                const ctx = getContextForSide(side);
                const ok = autoCandleConfirmOk(side);
                let detail = 'OK';
                if (!ctx || !ctx.candles || ctx.candles.length < 2) {
                    detail = 'Need 2 candles';
                } else if (!ok) {
                    detail = 'Last close below confirm';
                }
                addItem('Candle confirm', ok, detail);
            }

            if (!autoState.relativeStrengthEnabled) {
                addItem('Relative strength', true, 'OFF');
            } else {
                const other = side === 'CE' ? 'PE' : 'CE';
                const strength = getAutoMomentumStrength(side);
                const otherStrength = getAutoMomentumStrength(other);
                const ok = strength >= otherStrength + autoState.relativeStrengthDiff;
                addItem('Relative strength', ok, `${strength} vs ${otherStrength} (+${autoState.relativeStrengthDiff})`);
            }

            let spreadOk = true;
            let spreadDetail = 'No depth';
            if (Number.isFinite(depthState.topBidValue) && Number.isFinite(depthState.topAskValue)) {
                const spread = depthState.topAskValue - depthState.topBidValue;
                spreadDetail = spread.toFixed(2);
                spreadOk = autoSpreadOk(side);
            }
            addItem('Spread filter', spreadOk, spreadDetail);

            if (!autoState.imbalanceEnabled) {
                addItem('Imbalance filter', true, 'OFF');
            } else {
                const ratio = depthState.lastBidAskRatio;
                const ok = autoImbalanceOk(side);
                const detail = Number.isFinite(ratio) ? ratio.toFixed(2) : 'No depth';
                addItem('Imbalance filter', ok, detail);
            }

            // New Phase 3-6 checklist items
            const vel = getMomentumVelocity(side);
            const minVel = autoState.momentumMinMovePts || 1.5;
            addItem('Velocity', vel >= minVel, `${vel.toFixed(1)}/${minVel}`);

            if (autoState.noTradeZoneEnabled) {
                const ntz = isNoTradeZone(side);
                addItem('No-trade zone', !ntz, ntz ? 'Ranging — skip' : 'OK');
            }

            if (autoState.regimeDetectionEnabled) {
                addItem('Regime', true, autoState.currentRegime || 'UNKNOWN');
            }

            if (autoState.consecutiveLosses > 0) {
                const breaked = autoState.consecutiveLosses >= autoState.consecutiveLossBreaker;
                addItem('Consec losses', !breaked, `${autoState.consecutiveLosses}/${autoState.consecutiveLossBreaker}`);
            }

            if (autoState.trailStaged) {
                const trailStage = autoState.trailCurrentStage[side] || 0;
                const stageLabels = ['—', 'BE', 'Lock', 'Trail', 'Tight', 'Accel'];
                addItem('Trail stage', trailStage > 0, stageLabels[trailStage] || '—');
            }

            const moveSide = autoState.reverseTrades ? (side === 'CE' ? 'PE' : 'CE') : side;
            const moveCtx = getContextForSide(moveSide);
            const movePrice = moveCtx?.currentPrice;
            if (!autoState.minMovePts || autoState.minMovePts <= 0) {
                addItem('Min move', true, 'OFF');
            } else if (!Number.isFinite(movePrice) || movePrice <= 0) {
                addItem('Min move', false, 'No price');
            } else {
                const ok = autoMinMoveOk(moveSide, movePrice);
                const lastExit = autoState.lastExitPrice?.[moveSide];
                const detail = Number.isFinite(lastExit) ? `${Math.abs(movePrice - lastExit).toFixed(2)}/${autoState.minMovePts}` : 'No last exit';
                addItem('Min move', ok, detail);
            }

            const guardrailSide = autoState.reverseTrades ? (side === 'CE' ? 'PE' : 'CE') : side;
            const guardrailReason = getAutoGuardrailBlockReason(guardrailSide, autoState.entryLots);
            const guardrailDetail = guardrailReason || (autoState.reverseTrades ? `OK (${guardrailSide})` : 'OK');
            addItem('Guardrails', !guardrailReason, guardrailDetail);

            if (autoUi.checklistSide) {
                autoUi.checklistSide.textContent = side;
            }
            autoUi.checklistList.innerHTML = items.join('') || '<div class="auto-log-item">No data</div>';
            autoUi.checklistPanel.style.display = 'block';
        }

        function handleAutoTradeTick(side, ltp) {
            if (autoState.serverMode && autoState.enabled) return;
            const signalSide = side;
            const tradeSide = autoState.reverseTrades ? (signalSide === 'CE' ? 'PE' : 'CE') : signalSide;
            const otherTradeSide = tradeSide === 'CE' ? 'PE' : 'CE';
            const tradeCtx = getContextForSide(tradeSide);
            const tradePrice = tradeCtx?.currentPrice;
            autoState.lastAnyTickTs = Date.now();
            updateAutoMomentum(signalSide, ltp);
            updateAutoTrailing(signalSide, ltp);
            checkAutoRisk(signalSide, ltp);
            checkAutoTimeExit(signalSide, ltp);
            checkAutoPartialExit(signalSide, ltp);
            // Throttle expensive UI and regime updates to max once per 250ms
            const now = Date.now();
            if (!autoState._lastRegimeUpdateTs || now - autoState._lastRegimeUpdateTs >= 250) {
                updateRegimeDetection(signalSide);
                autoState._lastRegimeUpdateTs = now;
            }
            if (!autoState._lastStatsUiTs || now - autoState._lastStatsUiTs >= 250) {
                updateAutoStatsUI();
                autoState._lastStatsUiTs = now;
            }

            if (!autoState.enabled || autoState.dailyLossHit) {
                if (autoState.dailyLossHit) {
                    autoState.lastBlockReason[signalSide] = 'Daily loss hit';
                }
                return;
            }
            if (!autoSideAllowed(signalSide)) {
                autoState.lastBlockReason[signalSide] = `Mode locked (${autoState.mode})`;
                return;
            }
            if (autoState.flipCooldownUntil && Date.now() < autoState.flipCooldownUntil) {
                autoState.lastBlockReason[signalSide] = 'Flip cooldown';
                return;
            }

            // Momentum-based exit override: strong reverse momentum closes position
            const exitSide = autoState.reverseTrades ? tradeSide : signalSide;
            const exitMomentumThreshold = getAutoMomentumThreshold();
            if (isAutoPositionActive(exitSide) &&
                autoState.momentumDir[signalSide] === 'down' &&
                autoState.momentumCount[signalSide] >= exitMomentumThreshold) {
                if (!autoMinHoldMet(exitSide)) return;
                closeAutoPosition(exitSide, 'Momentum Flip');
                autoState.flipCooldownUntil = Date.now() + autoState.flipCooldownMs;
                return;
            }

            // Entry requirements with adaptive threshold
            let requiredTicks = getAutoMomentumThreshold();
            // Consecutive loss breaker: require more ticks after losses
            if (autoState.consecutiveLosses >= autoState.consecutiveLossBreaker) {
                requiredTicks += autoState.consecutiveLossMomentumBoost;
            }
            // Regime adaptation
            if (autoState.regimeDetectionEnabled && autoState.currentRegime === 'RANGING') {
                requiredTicks += 2;
            }

            const momentumReady = autoState.momentumDir[signalSide] === 'up' &&
                autoState.momentumCount[signalSide] >= requiredTicks;
            if (!momentumReady) {
                autoState.lastBlockReason[signalSide] = `Waiting momentum ${autoState.momentumCount[signalSide] || 0}/${requiredTicks}`;
                return;
            }

            // Momentum velocity filter: require minimum price movement over the momentum ticks
            const velocity = getMomentumVelocity(signalSide);
            const minVelocity = autoState.momentumMinMovePts || 1.5;
            if (velocity < minVelocity) {
                autoState.lastBlockReason[signalSide] = `Velocity ${velocity.toFixed(1)}/${minVelocity}`;
                return;
            }

            // No-trade zone filter
            if (isNoTradeZone(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'No-trade zone (ranging)';
                return;
            }

            if (!autoUnderlyingOk(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'Underlying filter';
                autoState.lastSignal[signalSide] = 'Underlying filter';
                return;
            }
            if (!autoCandleConfirmOk(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'Candle confirm';
                autoState.lastSignal[signalSide] = 'Candle confirm';
                return;
            }
            if (!autoRelativeStrengthOk(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'Rel strength';
                autoState.lastSignal[signalSide] = 'Rel strength';
                return;
            }
            const indexBias = autoIndexBiasOk(tradeSide);
            if (!indexBias.ok) {
                autoState.lastBlockReason[signalSide] = indexBias.reason || 'Index bias';
                autoState.lastSignal[signalSide] = indexBias.reason || 'Index bias';
                return;
            }
            if (!autoSpreadOk(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'Spread wide';
                autoState.lastSignal[signalSide] = 'Spread wide';
                return;
            }
            if (!autoImbalanceOk(signalSide)) {
                autoState.lastBlockReason[signalSide] = 'Imbalance weak';
                return;
            }

            if (!Number.isFinite(tradePrice) || tradePrice <= 0) {
                autoState.lastBlockReason[signalSide] = 'No trade price';
                return;
            }
            if (!autoMinMoveOk(tradeSide, tradePrice)) {
                autoState.lastBlockReason[signalSide] = `Min move ${autoState.minMovePts}`;
                return;
            }

            const hasAutoPos = isAutoPositionActive(tradeSide);
            if (hasAutoPos) {
                attemptAutoAverage(tradeSide);
                return;
            }

            // Re-entry after profitable exit: allow faster re-entry
            const isReEntry = autoState.reEntryEnabled &&
                autoState.lastProfitableExitTs[tradeSide] &&
                (Date.now() - autoState.lastProfitableExitTs[tradeSide]) < autoState.reEntryWindowMs;

            if (autoState.mode === 'AUTO' && isAutoPositionActive(otherTradeSide)) {
                if (!autoMinHoldMet(otherTradeSide)) return;
                closeAutoPosition(otherTradeSide, 'Flip');
                autoState.flipCooldownUntil = Date.now() + autoState.flipCooldownMs;
                return;
            }

            if (autoCanEnter(tradeSide, autoState.entryLots, isReEntry)) {
                const entryReason = autoState.reverseTrades ? 'Momentum (Reversed)' : (isReEntry ? 'Re-entry' : 'Momentum');
                const signalNote = autoState.reverseTrades ? `Momentum ${autoState.momentumCount[signalSide]} → ${tradeSide}` : `Momentum ${autoState.momentumCount[signalSide]} v${velocity.toFixed(1)}`;
                autoState.lastBlockReason[signalSide] = autoState.reverseTrades ? `Entry ok → ${tradeSide}` : 'Entry ok';
                autoState.lastSignal[signalSide] = signalNote;
                placeAutoEntry(tradeSide, autoState.entryLots, entryReason);
                return;
            }
            autoState.lastBlockReason[signalSide] = 'Guardrails (cooldown/min gap/max trades)';
        }

        function attemptAutoAverage(side) {
            if (!autoState.avgEnabled) return;
            if (autoState.avgOnlyProfit) {
                const pnl = getAutoPositionPnl(side);
                if (!Number.isFinite(pnl) || pnl <= 0) return;
            }
            const session = autoState.avgSession[side];
            if (!session) return;
            const now = Date.now();
            if (now > session.endTs) return;
            if (now < session.nextTs) return;
            if (session.lotsAdded >= autoState.maxLotsPerStrike) return;
            const requiredTicks = getAutoMomentumThreshold();
            const momentumReady = autoState.momentumDir[side] === 'up' &&
                autoState.momentumCount[side] >= requiredTicks;
            if (!momentumReady) return;
            if (!autoUnderlyingOk(side)) return;
            if (!autoCandleConfirmOk(side)) return;
            if (!autoIndexBiasOk(side).ok) return;
            if (!autoSpreadOk(side)) return;
            if (!autoCanEnter(side, autoState.scaleLots)) return;
            placeAutoEntry(side, autoState.scaleLots, 'Average');
        }

        function placeAutoEntry(side, lots, reason) {
            const ctx = getContextForSide(side);
            if (!ctx || !Number.isFinite(ctx.currentPrice) || ctx.currentPrice <= 0) return;
            const price = ctx.currentPrice;
            autoState.lastEntryTs = Date.now();
            autoState.lastSignal[side] = reason;

            if (autoState.assistOnly) {
                showToast(`Suggest BUY ${side} @ ₹${price.toFixed(2)}`, 'info');
                return;
            }

            const { tpPoints, slPoints } = getAutoTPSLPoints();
            const qty = Math.round(lots * (state.lotSize || 1));

            if (autoState.paperMode) {
                enterPaperPosition(side, price, lots, tpPoints, slPoints);
                recordAutoEntry(side, lots, price);
                logAutoTrade({
                    type: 'ENTRY',
                    mode: 'PAPER',
                    side,
                    symbol: ctx.symbol,
                    action: 'BUY',
                    qty,
                    price,
                    tpPoints,
                    slPoints,
                    reason,
                    tradeId: autoState.activeTradeId?.[side] || null,
                    // Market context for analytics/ML
                    preset: autoState.presetKey || 'custom',
                    presetLabel: AUTO_PRESETS[autoState.presetKey]?.label || 'Custom',
                    adaptivePreset: autoState.currentAdaptivePreset || null,
                    adaptivePresetLabel: autoState.currentAdaptivePreset ? AUTO_PRESETS[autoState.currentAdaptivePreset]?.label : null,
                    entryReason: reason || 'Auto momentum',
                    momentumTicks: autoState.momentumTicks,
                    momentumCount: autoState.momentumCount[side] || 0,
                    momentumThreshold: getAutoMomentumThreshold(),
                    regime: autoState.currentRegime || 'UNKNOWN',
                    regimeMode: autoState.regimeTradingMode || 'all',
                    momentumVelocity: parseFloat(getMomentumVelocity(side).toFixed(2)),
                    noTradeZoneActive: isNoTradeZone(),
                    underlyingFilterOk: autoState.underlyingFilterEnabled ? autoUnderlyingOk(side) : null,
                    candleConfirmOk: autoState.candleConfirmEnabled ? autoCandleOk(side) : null,
                    relativeStrengthOk: autoState.relativeStrengthEnabled ? autoRelativeStrengthOk(side) : null,
                    consecutiveLosses: autoState.consecutiveLosses || 0,
                    winStreak: autoState.winStreak || 0,
                    sessionPnl: parseFloat((autoState.realizedPnl || 0).toFixed(0)),
                    tradeNumber: (autoState.tradeHistory?.length || 0) + 1,
                    bidAskRatio: parseFloat((depthState.lastBidAskRatio || 0).toFixed(2)),
                    spread: Number.isFinite(depthState.topAskValue) && Number.isFinite(depthState.topBidValue)
                        ? parseFloat((depthState.topAskValue - depthState.topBidValue).toFixed(2)) : null,
                    isReEntry: reason === 'Re-entry'
                });
                updateAutoUI();
                return;
            }

            placeOrderAtPrice(price, 'BUY', {
                side,
                symbol: ctx.symbol,
                orderType: 'MARKET',
                lots,
                autoTag: true,
                tpPoints,
                slPoints,
                reason
            });
            recordAutoEntry(side, lots, price);
            updateAutoUI();
        }

        function enterPaperPosition(side, entryPrice, lots, tpPoints = state.tpPoints, slPoints = state.slPoints) {
            const qty = Math.round(lots * (state.lotSize || 1));
            const existing = autoState.paperPositions[side];
            const prevQty = existing ? (parseInt(existing.quantity) || 0) : 0;
            const prevAvg = existing ? (parseFloat(existing.average_price) || entryPrice) : entryPrice;
            const newQty = prevQty + qty;
            const avgPrice = newQty > 0 ? ((prevAvg * prevQty) + (entryPrice * qty)) / newQty : entryPrice;
            const position = {
                symbol: getContextForSide(side)?.symbol || state.symbol,
                quantity: String(newQty || qty),
                average_price: avgPrice,
                auto: true,
                paper: true
            };
            const tpsl = {
                action: 'BUY',
                tpOrder: { price: avgPrice + tpPoints },
                slOrder: { price: avgPrice - slPoints },
                tpPoints: tpPoints,
                slPoints: slPoints,
                tpAuto: true,
                slAuto: true
            };
            updatePositionDisplay(position, tpsl, side);
            autoState.paperPositions[side] = position;
            autoState.trailingAnchor[side] = avgPrice;
        }

        function closeAutoPosition(side, reason) {
            const posState = getPositionState(side);
            if (!posState.position || !posState.position.auto) return;
            if (posState.position.paper) {
                closePaperPosition(side, reason);
            } else {
                closePosition(side);
            }
        }

        function closePaperPosition(side, reason) {
            const ctx = getContextForSide(side);
            const exitPrice = ctx?.currentPrice || 0;
            recordAutoExit(side, exitPrice, reason || 'Paper exit');
            clearPositionVisuals(side);
            autoState.paperPositions[side] = null;
            updateAutoUI();
        }

        function closeAutoPositions(reason) {
            ['CE', 'PE'].forEach(side => {
                closeAutoPosition(side, reason);
            });
        }

        function checkAutoRisk(side, price) {
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (!position || !position.auto) return;
            const qty = parseInt(position.quantity) || 0;
            const entry = getAutoEntryPrice(side);
            if (!qty || !entry || !price) return;
            const pnl = (price - entry) * qty;

            if (pnl <= -autoState.perTradeMaxLoss) {
                autoState.cooldownUntil = Date.now() + autoState.cooldownMs;
                closeAutoPosition(side, 'Max Loss');
            }

            const dailyPnl = getAutoDailyPnl();
            if (dailyPnl <= -autoState.dailyMaxLoss && !autoState.dailyLossHit) {
                autoState.dailyLossHit = true;
                setAutoEnabled(false, 'Daily max loss hit - auto stopped');
            }
        }

        // === Phase 4: Partial exit ===
        function checkAutoPartialExit(side, price) {
            // Already handled inside updateAutoTrailing for staged trail
        }

        function executePartialExit(side, price) {
            if (autoState.partialExitDone[side]) return;
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (!position || !position.auto) return;
            const totalQty = Math.abs(parseInt(position.quantity) || 0);
            if (totalQty <= 0) return;
            const lotSize = state.lotSize || 1;
            const exitQty = Math.max(lotSize, Math.floor(totalQty * (autoState.partialExitPct / 100) / lotSize) * lotSize);
            if (exitQty >= totalQty) return; // Don't exit everything as partial
            autoState.partialExitDone[side] = true;
            const entry = getAutoEntryPrice(side);
            const pnl = (price - entry) * exitQty;
            logAutoTrade({
                type: 'PARTIAL_EXIT',
                mode: position?.paper ? 'PAPER' : 'LIVE',
                side,
                symbol: position?.symbol || getContextForSide(side)?.symbol || '',
                action: parseInt(position.quantity) > 0 ? 'SELL' : 'BUY',
                qty: exitQty,
                price,
                pnl,
                reason: 'Partial Exit',
                trailStage: autoState.trailCurrentStage[side] || 0,
                entryPrice: entry,
                totalQty: totalQty,
                regime: autoState.currentRegime || 'UNKNOWN'
            });
            // In paper mode, just reduce qty
            if (autoState.paperMode) {
                const isLong = parseInt(position.quantity) > 0;
                const newQty = isLong ? totalQty - exitQty : -(totalQty - exitQty);
                position.quantity = String(newQty);
                if (autoState.paperPositions[side]) autoState.paperPositions[side].quantity = String(newQty);
            } else {
                // Place a partial close order via API
                const action = parseInt(position.quantity) > 0 ? 'SELL' : 'BUY';
                const ctx = getContextForSide(side);
                placeOrderAtPrice(price, action, {
                    side,
                    symbol: position?.symbol || ctx?.symbol || state.symbol,
                    lots: Math.round(exitQty / (state.lotSize || 1)),
                    autoTag: true,
                    strategy: 'auto_trading'
                });
            }
        }

        // === Phase 6: Regime Detection ===
        function updateRegimeDetection(side) {
            if (!autoState.regimeDetectionEnabled) return;
            const prices = autoState.recentPrices[side];
            if (!prices || prices.length < 10) {
                autoState.currentRegime = 'UNKNOWN';
                return;
            }
            // Use regime window (default 60s), fall back to available data
            const windowCutoff = Date.now() - (autoState.regimeWindowMs || 60000);
            const windowPrices = prices.filter(p => p.ts >= windowCutoff);
            const values = (windowPrices.length >= 10 ? windowPrices : prices).map(p => p.price);
            const high = Math.max(...values);
            const low = Math.min(...values);
            const range = high - low;
            // Count directional ticks
            let upTicks = 0, downTicks = 0;
            for (let i = 1; i < values.length; i++) {
                if (values[i] > values[i - 1]) upTicks++;
                else if (values[i] < values[i - 1]) downTicks++;
            }
            const total = upTicks + downTicks;
            const directionality = total > 0 ? Math.abs(upTicks - downTicks) / total : 0;
            if (range >= autoState.regimeVolatileThreshold) {
                autoState.currentRegime = directionality > 0.3 ? 'TRENDING' : 'VOLATILE';
            } else if (range < autoState.regimeRangingThreshold) {
                autoState.currentRegime = 'RANGING';
            } else {
                autoState.currentRegime = directionality > 0.25 ? 'TRENDING' : 'RANGING';
            }

            // Update adaptive preset if auto_adaptive is selected
            updateAdaptivePreset();
        }

        // === Adaptive Preset Selection Logic ===
        function updateAdaptivePreset() {
            // Only run if auto_adaptive preset is active
            if (autoState.presetKey !== 'auto_adaptive') return;

            // Throttle updates to every 10s
            const now = Date.now();
            if (now - autoState.adaptiveLastUpdate < 10000) return;
            autoState.adaptiveLastUpdate = now;

            const regime = autoState.currentRegime;
            const consecLosses = autoState.consecutiveLosses || 0;
            const winStreak = autoState.winStreak || 0;
            const history = autoState.tradeHistory || [];

            // Calculate recent performance (last 10 trades)
            const recentTrades = history.slice(-10);
            const recentWins = recentTrades.filter(t => t.pnl > 0).length;
            const recentWinRate = recentTrades.length > 0 ? (recentWins / recentTrades.length) : 0.5;

            let targetPreset = null;
            let reason = '';

            // Decision tree for adaptive preset selection
            if (consecLosses >= 3) {
                // After 3+ losses, go ultra-conservative (Sniper)
                targetPreset = 'sniper_quality';
                reason = `3+ consecutive losses - switching to quality-only mode`;
            } else if (consecLosses >= 2) {
                // After 2 losses, go conservative (Balanced)
                targetPreset = 'balanced_trader';
                reason = `2 consecutive losses - reducing frequency`;
            } else if (winStreak >= 4 && regime === 'TRENDING') {
                // Hot streak in trending market - exploit with Scalper
                targetPreset = 'momentum_scalper';
                reason = `Win streak ${winStreak} in ${regime} market - capitalizing`;
            } else if (recentWinRate >= 0.7 && recentTrades.length >= 5) {
                // Recent high win rate - can be aggressive
                targetPreset = regime === 'TRENDING' ? 'momentum_scalper' : 'balanced_trader';
                reason = `High win rate (${(recentWinRate * 100).toFixed(0)}%) - staying aggressive`;
            } else if (recentWinRate <= 0.3 && recentTrades.length >= 5) {
                // Recent low win rate - go conservative
                targetPreset = 'sniper_quality';
                reason = `Low win rate (${(recentWinRate * 100).toFixed(0)}%) - filtering strictly`;
            } else {
                // Default: regime-based selection
                switch (regime) {
                    case 'TRENDING':
                        targetPreset = 'sniper_quality'; // Quality entries with trend
                        reason = `${regime} regime - quality trend trades`;
                        break;
                    case 'VOLATILE':
                        targetPreset = 'balanced_trader'; // Balanced approach in volatility
                        reason = `${regime} regime - balanced selective trading`;
                        break;
                    case 'RANGING':
                        targetPreset = 'momentum_scalper'; // Quick scalps in range
                        reason = `${regime} regime - quick range scalps`;
                        break;
                    default:
                        targetPreset = 'balanced_trader'; // Default to balanced
                        reason = `${regime} regime - balanced approach`;
                }
            }

            // If preset changed, apply it and notify
            if (targetPreset && targetPreset !== autoState.currentAdaptivePreset) {
                const oldPreset = autoState.currentAdaptivePreset;
                autoState.currentAdaptivePreset = targetPreset;

                // Apply the target preset config (without changing presetKey to keep auto_adaptive active)
                const presetConfig = AUTO_PRESETS[targetPreset];
                if (presetConfig) {
                    // Apply all config fields except label and isAdaptive
                    Object.keys(presetConfig).forEach(key => {
                        if (key !== 'label' && key !== 'isAdaptive') {
                            autoState[key] = presetConfig[key];
                        }
                    });

                    console.log(`🤖 Adaptive: ${oldPreset || 'none'} → ${targetPreset} (${reason})`);
                    showToast(`🤖 Adaptive: ${AUTO_PRESETS[targetPreset]?.label || targetPreset}\n${reason}`, 'info', 4000);

                    // Log the adaptation decision
                    logAutoTrade({
                        type: 'ADAPTIVE',
                        fromPreset: oldPreset || 'none',
                        toPreset: targetPreset,
                        toPresetLabel: AUTO_PRESETS[targetPreset]?.label,
                        reason,
                        regime,
                        consecutiveLosses: consecLosses,
                        winStreak,
                        recentWinRate: parseFloat((recentWinRate * 100).toFixed(1)),
                        recentTrades: recentTrades.length
                    });
                }
            }
        }

        // === Phase 5: UI Stats Updates ===
        function updateAutoSummaryStats() {
            const history = autoState.tradeHistory;
            if (!history || history.length === 0) return;
            const wins = history.filter(t => t.pnl > 0);
            const losses = history.filter(t => t.pnl <= 0);
            // Estimated charges: ₹20/order × 2 legs, STT 0.0625% on sell, exchange ~0.053%, GST 18%
            const totalOrders = history.length * 2;
            const brokerage = totalOrders * 20;
            const stt = history.reduce((s, t) => s + Math.abs(t.exit || 0) * Math.abs(t.qty || 0) * 0.000625, 0);
            const exchg = history.reduce((s, t) => s + ((Math.abs(t.entry || 0) + Math.abs(t.exit || 0)) * Math.abs(t.qty || 0) * 0.00053), 0);
            const gst = (brokerage + exchg) * 0.18;
            const estCharges = brokerage + stt + exchg + gst;
            const grossPnl = history.reduce((s, t) => s + t.pnl, 0);
            autoState.summaryStats = {
                totalTrades: history.length,
                winRate: history.length > 0 ? (wins.length / history.length * 100).toFixed(1) : 0,
                avgWinner: wins.length > 0 ? (wins.reduce((s, t) => s + t.pnl, 0) / wins.length).toFixed(0) : 0,
                avgLoser: losses.length > 0 ? (losses.reduce((s, t) => s + t.pnl, 0) / losses.length).toFixed(0) : 0,
                profitFactor: losses.length > 0 ?
                    Math.abs(wins.reduce((s, t) => s + t.pnl, 0) / (losses.reduce((s, t) => s + t.pnl, 0) || 1)).toFixed(2) : '∞',
                maxConsecLoss: autoState.maxConsecLosses || 0,
                winStreak: autoState.winStreak || 0,
                totalPnl: grossPnl.toFixed(0),
                netPnl: (grossPnl - estCharges).toFixed(0),
                estCharges: estCharges.toFixed(0),
                avgHoldMs: (history.reduce((s, t) => s + (t.holdMs || 0), 0) / history.length / 1000).toFixed(1)
            };
            renderAutoSummaryPanel();
        }

        function renderAutoSummaryPanel() {
            const panel = document.getElementById('auto-summary-stats');
            if (!panel) return;
            const s = autoState.summaryStats;
            if (!s) return;
            panel.innerHTML = `
                <div class="auto-stats-grid">
                    <div class="auto-stat"><span class="stat-label">Trades</span><span class="stat-value">${s.totalTrades}</span></div>
                    <div class="auto-stat"><span class="stat-label">Win%</span><span class="stat-value ${parseFloat(s.winRate) >= 50 ? 'stat-green' : 'stat-red'}">${s.winRate}%</span></div>
                    <div class="auto-stat"><span class="stat-label">PF</span><span class="stat-value ${parseFloat(s.profitFactor) >= 1.5 ? 'stat-green' : 'stat-red'}">${s.profitFactor}</span></div>
                    <div class="auto-stat"><span class="stat-label">Gross</span><span class="stat-value ${parseFloat(s.totalPnl) >= 0 ? 'stat-green' : 'stat-red'}">₹${s.totalPnl}</span></div>
                    <div class="auto-stat"><span class="stat-label">Net(est)</span><span class="stat-value ${parseFloat(s.netPnl) >= 0 ? 'stat-green' : 'stat-red'}">₹${s.netPnl}</span></div>
                    <div class="auto-stat"><span class="stat-label">Charges</span><span class="stat-value stat-red">₹${s.estCharges}</span></div>
                    <div class="auto-stat"><span class="stat-label">Avg W</span><span class="stat-value stat-green">₹${s.avgWinner}</span></div>
                    <div class="auto-stat"><span class="stat-label">Avg L</span><span class="stat-value stat-red">₹${s.avgLoser}</span></div>
                    <div class="auto-stat"><span class="stat-label">Streak</span><span class="stat-value">${s.winStreak}W / ${s.maxConsecLoss}L</span></div>
                    <div class="auto-stat"><span class="stat-label">Avg Hold</span><span class="stat-value">${s.avgHoldMs}s</span></div>
                </div>
            `;
        }

        function renderEquityCurve() {
            const canvas = document.getElementById('equity-curve-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const data = autoState.equityCurve;
            if (!data || data.length === 0) { ctx.clearRect(0, 0, canvas.width, canvas.height); return; }
            // Ensure at least 2 points by prepending zero baseline
            const points = data.length === 1 ? [{ ts: data[0].ts - 1, pnl: 0 }, ...data] : data;
            const w = canvas.width = canvas.parentElement?.offsetWidth || 260;
            const h = canvas.height = 60;
            ctx.clearRect(0, 0, w, h);
            const values = points.map(d => d.pnl);
            const minV = Math.min(0, ...values);
            const maxV = Math.max(0, ...values);
            const range = maxV - minV || 1;
            const pad = 4;
            const drawW = w - pad * 2;
            const drawH = h - pad * 2;
            // Zero line
            const zeroY = pad + drawH * (1 - (0 - minV) / range);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(pad, zeroY); ctx.lineTo(w - pad, zeroY); ctx.stroke();
            // Equity line
            ctx.beginPath();
            ctx.strokeStyle = values[values.length - 1] >= 0 ? '#22c55e' : '#ef4444';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < values.length; i++) {
                const x = pad + (i / (values.length - 1)) * drawW;
                const y = pad + drawH * (1 - (values[i] - minV) / range);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
            // Fill under
            const lastX = pad + drawW;
            const lastY = pad + drawH * (1 - (values[values.length - 1] - minV) / range);
            ctx.lineTo(lastX, zeroY); ctx.lineTo(pad, zeroY); ctx.closePath();
            ctx.fillStyle = values[values.length - 1] >= 0 ? 'rgba(34,197,94,0.1)' : 'rgba(239,68,68,0.1)';
            ctx.fill();
            // Latest P&L label
            ctx.fillStyle = values[values.length - 1] >= 0 ? '#22c55e' : '#ef4444';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(`₹${values[values.length - 1].toFixed(0)}`, w - pad, pad + 10);
        }

        function showTradePopup(tradeResult) {
            const existing = document.getElementById('trade-popup-overlay');
            if (existing) existing.remove();
            const pnl = tradeResult.pnl || 0;
            const holdSec = ((tradeResult.holdMs || 0) / 1000).toFixed(1);
            const isProfit = pnl >= 0;
            const div = document.createElement('div');
            div.id = 'trade-popup-overlay';
            div.className = `trade-popup ${isProfit ? 'trade-popup-profit' : 'trade-popup-loss'}`;
            div.innerHTML = `
                <span class="trade-popup-pnl">${isProfit ? '+' : ''}₹${pnl.toFixed(0)}</span>
                <span class="trade-popup-detail">${tradeResult.reason} · ${holdSec}s · ${tradeResult.side}</span>
            `;
            const chartArea = document.querySelector('.chart-wrapper') || document.body;
            chartArea.appendChild(div);
            setTimeout(() => { div.classList.add('trade-popup-fade'); }, 50);
            setTimeout(() => { div.remove(); }, 3000);
        }

        function updateAutoIndicatorsUI() {
            // Update trailing stage indicator
            const stageEl = document.getElementById('trail-stage-indicator');
            if (stageEl) {
                const side = state.activeSide;
                const stage = autoState.trailCurrentStage[side] || 0;
                const labels = ['—', 'BE', 'Lock', 'Trail', 'Tight', 'Accel'];
                stageEl.textContent = labels[stage] || '—';
                stageEl.className = `trail-stage trail-stage-${stage}`;
            }
            // Update regime indicator
            const regimeEl = document.getElementById('regime-indicator');
            if (regimeEl) {
                const regime = autoState.currentRegime || 'UNKNOWN';
                regimeEl.textContent = regime;
                regimeEl.className = `regime-badge regime-${regime.toLowerCase()}`;
            }
            // Update momentum gauge
            const gaugeEl = document.getElementById('momentum-gauge-fill');
            if (gaugeEl) {
                const side = state.activeSide;
                const count = autoState.momentumCount[side] || 0;
                const threshold = getAutoMomentumThreshold();
                const pct = Math.min(100, (count / threshold) * 100);
                gaugeEl.style.width = `${pct}%`;
                gaugeEl.className = `momentum-gauge-fill ${pct >= 100 ? 'gauge-ready' : 'gauge-building'}`;
            }
            // Update velocity display
            const velEl = document.getElementById('momentum-velocity');
            if (velEl) {
                const side = state.activeSide;
                const vel = getMomentumVelocity(side);
                const minVel = autoState.momentumMinMovePts || 1.5;
                velEl.textContent = `${vel.toFixed(1)}/${minVel}`;
                velEl.className = vel >= minVel ? 'stat-green' : 'stat-red';
            }
            // Update consecutive loss indicator
            const lossEl = document.getElementById('consec-loss-indicator');
            if (lossEl) {
                const losses = autoState.consecutiveLosses || 0;
                lossEl.textContent = losses > 0 ? `${losses}L` : '—';
                lossEl.className = losses >= autoState.consecutiveLossBreaker ? 'stat-red blink' : '';
            }
        }

        function checkAutoTimeExit(side, price) {
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (!position || !position.auto) return;
            const entryTs = autoState.positionEntryTs[side];
            if (!entryTs) return;
            const age = Date.now() - entryTs;
            if (age < autoState.tradeMaxDurationMs) return;

            const requiredTicks = getAutoMomentumThreshold();
            const momentumWeak = autoState.momentumDir[side] !== 'up'
                || autoState.momentumCount[side] < requiredTicks;
            if (!momentumWeak) return;

            const qty = parseInt(position.quantity) || 0;
            const entry = getAutoEntryPrice(side);
            if (!qty || !entry || !price) return;
            const pnl = (price - entry) * qty;

            if (pnl > 0) {
                closeAutoPosition(side, 'Timed Exit Profit');
                return;
            }

            const tighten = autoState.timeExitTightenPts;
            const desiredSL = roundToTick(entry - tighten);
            const currentSL = posState.positionTPSL.slPrice ?? (entry - state.slPoints);
            if (desiredSL > currentSL) {
                posState.positionTPSL.slPrice = desiredSL;
                if (posState.positionTPSL.slLine) {
                    posState.positionTPSL.slLine.applyOptions({ price: desiredSL, title: `SL @ ${desiredSL.toFixed(2)}` });
                }
                if (posState.positionTPSL.slOverlay) {
                    updateOverlayPosition(posState.positionTPSL.slOverlay, desiredSL, getContextForSide(side));
                    const label = posState.positionTPSL.slOverlay.querySelector('.order-line-label');
                    if (label) label.textContent = `SL @ ₹${desiredSL.toFixed(2)}`;
                }
            }
        }

        function updateAutoTrailing(side, price) {
            if (!autoState.trailingEnabled) return;
            const posState = getPositionState(side);
            const position = autoState.paperMode ? (autoState.paperPositions[side] || posState.position) : posState.position;
            if (!position || !position.auto) return;
            const qty = parseInt(position.quantity) || 0;
            if (!qty) return;
            const entry = getAutoEntryPrice(side);
            if (!entry || !price) return;
            const isLong = qty > 0;
            const tick = CONFIG.tickSize || 0.05;
            const entryTs = autoState.positionEntryTs?.[side] || 0;
            const beDelayMs = Math.max(0, autoState.breakevenDelayMs || 0);
            const beBuffer = Math.max(0, autoState.breakevenBufferPts || 0);
            const beDelayMet = !beDelayMs || !entryTs || (Date.now() - entryTs) >= beDelayMs;
            const profitLockPts = Math.max(0, getAutoProfitLockPts(Math.abs(qty)));

            // Track high water mark
            if (isLong && price > (autoState.positionHighPrice[side] || 0)) {
                autoState.positionHighPrice[side] = price;
            }
            if (!isLong && (autoState.positionHighPrice[side] === 0 || price < autoState.positionHighPrice[side])) {
                autoState.positionHighPrice[side] = price;
            }

            // Partial exit check
            if (autoState.partialExitEnabled && !autoState.partialExitDone[side]) {
                const profitPts = isLong ? price - entry : entry - price;
                if (profitPts >= autoState.partialExitPts) {
                    executePartialExit(side, price);
                }
            }

            const applySlUpdate = (desiredSL, stage) => {
                posState.positionTPSL.slPrice = desiredSL;
                const inProfit = isLong ? desiredSL >= entry : desiredSL <= entry;
                if (inProfit) {
                    posState.positionTPSL.slTrail = true;
                }
                autoState.trailCurrentStage[side] = stage || autoState.trailCurrentStage[side];
                const stageLabel = autoState.trailStaged ? `S${autoState.trailCurrentStage[side]}` : '';
                const labelPrefix = posState.positionTPSL.slTrail ? `TRAIL${stageLabel}` : 'SL';
                if (posState.positionTPSL.slLine) {
                    posState.positionTPSL.slLine.applyOptions({ price: desiredSL, title: `${labelPrefix} @ ${desiredSL.toFixed(2)}` });
                }
                if (posState.positionTPSL.slOverlay) {
                    updateOverlayPosition(posState.positionTPSL.slOverlay, desiredSL, getContextForSide(side));
                    const label = posState.positionTPSL.slOverlay.querySelector('.order-line-label');
                    if (label) label.textContent = `${labelPrefix} @ ₹${desiredSL.toFixed(2)}`;
                }
            };

            if (isLong) {
                let currentSL = posState.positionTPSL.slPrice ?? (entry - state.slPoints);
                const profitPts = price - entry;
                const elapsed = entryTs ? Date.now() - entryTs : 0;

                // Breakeven: move SL to entry - buffer after delay AND minimum profit
                const beMinProfit = Math.min(autoState.trailStage1Trigger, 1.5);
                if (autoState.breakevenEnabled && beDelayMet && profitPts >= beMinProfit) {
                    const breakevenSL = roundToTick(Math.max(0, entry - beBuffer));
                    if (breakevenSL > currentSL) {
                        applySlUpdate(breakevenSL, 1);
                        currentSL = posState.positionTPSL.slPrice ?? currentSL;
                    }
                }

                // Profit lock
                if (profitLockPts > 0 && profitPts >= profitLockPts) {
                    const lockSL = roundToTick(entry + profitLockPts);
                    if (lockSL > currentSL) {
                        applySlUpdate(lockSL, 2);
                        currentSL = posState.positionTPSL.slPrice ?? currentSL;
                    }
                }

                // Multi-stage trailing
                if (autoState.trailStaged) {
                    let desiredSL = currentSL;
                    let stage = autoState.trailCurrentStage[side] || 0;

                    // Acceleration: fast move = tight trail
                    if (autoState.trailAccelEnabled && elapsed > 0 && elapsed <= autoState.trailAccelTimeMs && profitPts >= autoState.trailAccelMovePts) {
                        desiredSL = roundToTick(price - autoState.trailAccelDistance);
                        stage = 5;
                    }
                    // Win streak: wider trail for runners
                    else if (autoState.winStreak >= autoState.winStreakWideTrail && profitPts >= autoState.trailStage3Trigger) {
                        desiredSL = roundToTick(price - autoState.winStreakTrailDistance);
                        stage = Math.max(stage, 3);
                    }
                    // Stage 4: > stage3 trigger pts profit, tight trail
                    else if (profitPts >= autoState.trailStage3Trigger) {
                        desiredSL = roundToTick(price - autoState.trailStage4Distance);
                        stage = 4;
                    }
                    // Stage 3: > stage2 trigger pts profit
                    else if (profitPts >= autoState.trailStage2Trigger) {
                        desiredSL = roundToTick(price - autoState.trailStage3Distance);
                        stage = 3;
                    }
                    // Stage 2: > stage1 trigger pts profit, lock small profit
                    else if (profitPts >= autoState.trailStage1Trigger) {
                        desiredSL = roundToTick(entry + autoState.trailStage2SL);
                        stage = 2;
                    }
                    // Stage 1: small profit, move to breakeven area
                    else if (profitPts >= beMinProfit && beDelayMet) {
                        desiredSL = roundToTick(entry - beBuffer);
                        stage = 1;
                    }

                    const updatedSL = posState.positionTPSL.slPrice ?? currentSL;
                    if (desiredSL > updatedSL + autoState.trailStep) {
                        applySlUpdate(desiredSL, stage);
                    }
                } else {
                    // Legacy simple trailing
                    if (profitPts < autoState.trailDistance) return;
                    const desiredSL = roundToTick(price - autoState.trailDistance);
                    const updatedSL = posState.positionTPSL.slPrice ?? currentSL;
                    if (desiredSL > updatedSL + autoState.trailStep) {
                        applySlUpdate(desiredSL, 0);
                    }
                }
            } else {
                let currentSL = posState.positionTPSL.slPrice ?? (entry + state.slPoints);
                const profitPts = entry - price;
                const elapsed = entryTs ? Date.now() - entryTs : 0;

                const beMinProfit = Math.min(autoState.trailStage1Trigger, 1.5);
                if (autoState.breakevenEnabled && beDelayMet && profitPts >= beMinProfit) {
                    const breakevenSL = roundToTick(entry + beBuffer);
                    if (breakevenSL < currentSL) {
                        applySlUpdate(breakevenSL, 1);
                        currentSL = posState.positionTPSL.slPrice ?? currentSL;
                    }
                }
                if (profitLockPts > 0 && profitPts >= profitLockPts) {
                    const lockSL = roundToTick(Math.max(0, entry - profitLockPts));
                    if (lockSL < currentSL) {
                        applySlUpdate(lockSL, 2);
                        currentSL = posState.positionTPSL.slPrice ?? currentSL;
                    }
                }

                if (autoState.trailStaged) {
                    let desiredSL = currentSL;
                    let stage = autoState.trailCurrentStage[side] || 0;

                    if (autoState.trailAccelEnabled && elapsed > 0 && elapsed <= autoState.trailAccelTimeMs && profitPts >= autoState.trailAccelMovePts) {
                        desiredSL = roundToTick(price + autoState.trailAccelDistance);
                        stage = 5;
                    } else if (autoState.winStreak >= autoState.winStreakWideTrail && profitPts >= autoState.trailStage3Trigger) {
                        desiredSL = roundToTick(price + autoState.winStreakTrailDistance);
                        stage = Math.max(stage, 3);
                    } else if (profitPts >= autoState.trailStage3Trigger) {
                        desiredSL = roundToTick(price + autoState.trailStage4Distance);
                        stage = 4;
                    } else if (profitPts >= autoState.trailStage2Trigger) {
                        desiredSL = roundToTick(price + autoState.trailStage3Distance);
                        stage = 3;
                    } else if (profitPts >= autoState.trailStage1Trigger) {
                        desiredSL = roundToTick(entry - autoState.trailStage2SL);
                        stage = 2;
                    } else if (profitPts >= beMinProfit && beDelayMet) {
                        desiredSL = roundToTick(entry + beBuffer);
                        stage = 1;
                    }

                    const updatedSL = posState.positionTPSL.slPrice ?? currentSL;
                    if (desiredSL < updatedSL - autoState.trailStep) {
                        applySlUpdate(desiredSL, stage);
                    }
                } else {
                    if (profitPts < autoState.trailDistance) return;
                    const desiredSL = roundToTick(price + autoState.trailDistance);
                    const updatedSL = posState.positionTPSL.slPrice ?? currentSL;
                    if (desiredSL < updatedSL - autoState.trailStep) {
                        applySlUpdate(desiredSL, 0);
                    }
                }
            }
        }

        function checkAutoStaleness() {
            if (!autoState.enabled || !autoState.stopOnStale) return;
            if (state.isMockMode) return; // Skip stall check in mock mode
            if (!autoState.lastAnyTickTs) return;
            const age = Date.now() - autoState.lastAnyTickTs;
            if (age > autoState.staleTimeoutMs) {
                setAutoEnabled(false, 'Auto stopped: data stall');
            }
        }

        setInterval(checkAutoStaleness, 1000);

        // Event Listeners
        function setupEventListeners() {
            if (ui.sideCeBtn) {
                ui.sideCeBtn.addEventListener('click', () => setActiveSide('CE'));
            }
            if (ui.sidePeBtn) {
                ui.sidePeBtn.addEventListener('click', () => setActiveSide('PE'));
            }

            // Quantity controls
            document.getElementById('qtyPlus').addEventListener('click', () => {
                state.quantity++;
                document.getElementById('qtyValue').textContent = state.quantity;
            });

            document.getElementById('qtyMinus').addEventListener('click', () => {
                if (state.quantity > 1) {
                    state.quantity--;
                    document.getElementById('qtyValue').textContent = state.quantity;
                }
            });

            // TP/SL points inputs
            function updatePointsInput(inputId, delta) {
                const input = document.getElementById(inputId);
                if (!input) return;
                const step = parseFloat(input.step) || 0.5;
                const decimals = (step.toString().split('.')[1] || '').length;
                let current = parseFloat(input.value);
                if (!Number.isFinite(current)) {
                    current = inputId === 'tpPointsInput' ? state.tpPoints : state.slPoints;
                }
                let next = current + (delta * step);
                if (next < step) next = step;
                next = Math.round(next / step) * step;
                input.value = next.toFixed(decimals);
                if (inputId === 'tpPointsInput') {
                    state.tpPoints = next;
                } else {
                    state.slPoints = next;
                }
                enforceRrGuard();
            }

            document.getElementById('tpPlus').addEventListener('click', () => updatePointsInput('tpPointsInput', 1));
            document.getElementById('tpMinus').addEventListener('click', () => updatePointsInput('tpPointsInput', -1));
            document.getElementById('slPlus').addEventListener('click', () => updatePointsInput('slPointsInput', 1));
            document.getElementById('slMinus').addEventListener('click', () => updatePointsInput('slPointsInput', -1));

            document.getElementById('tpPointsInput').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val > 0) {
                    state.tpPoints = val;
                    enforceRrGuard();
                } else {
                    e.target.value = state.tpPoints;
                }
            });

            document.getElementById('slPointsInput').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val > 0) {
                    state.slPoints = val;
                    enforceRrGuard();
                } else {
                    e.target.value = state.slPoints;
                }
            });

            // Order type toggle — three-way: MARKET, LIMIT, FAKELIMIT
            function setOrderType(type) {
                state.orderType = type;
                const marketBtn = document.getElementById('marketBtn');
                const limitBtn = document.getElementById('limitBtn');
                const fakeLimitBtn = document.getElementById('fakeLimitBtn');
                marketBtn.classList.remove('active', 'active-trigger');
                limitBtn.classList.remove('active', 'active-trigger');
                fakeLimitBtn.classList.remove('active', 'active-trigger');
                if (type === 'MARKET') marketBtn.classList.add('active');
                else if (type === 'LIMIT') limitBtn.classList.add('active');
                else if (type === 'FAKELIMIT') fakeLimitBtn.classList.add('active-trigger');
            }

            document.getElementById('marketBtn').addEventListener('click', () => setOrderType('MARKET'));
            document.getElementById('limitBtn').addEventListener('click', () => setOrderType('LIMIT'));
            document.getElementById('fakeLimitBtn').addEventListener('click', () => setOrderType('FAKELIMIT'));

            // BUY/SELL buttons - Interactive order placement
            document.getElementById('buyBtn').addEventListener('click', () => {
                enableFollowMode('BUY');
            });

            document.getElementById('sellBtn').addEventListener('click', () => {
                enableFollowMode('SELL');
            });

            // Close position button
            document.getElementById('btnClosePosition').addEventListener('click', () => {
                closePosition();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input field
                if (e.target.tagName === 'INPUT') return;

                const key = e.key.toLowerCase();

                if (key === 'x') {
                    // Close position with X key
                    if (state.position) {
                        closePosition();
                    }
                } else if (key === 'b') {
                    // B = BUY
                    e.preventDefault();
                    if (state.orderType === 'MARKET') {
                        // MARKET: Place immediately at current price
                        placeMarketOrder('BUY');
                    } else {
                        // LIMIT: Enable chart selection
                        enableFollowMode('BUY');
                    }
                } else if (key === 's') {
                    // S = SELL
                    e.preventDefault();
                    if (state.orderType === 'MARKET') {
                        // MARKET: Place immediately at current price
                        placeMarketOrder('SELL');
                    } else {
                        // LIMIT: Enable chart selection
                        enableFollowMode('SELL');
                    }
                } else if (key === 'x') {
                    // X = Close all positions or cancel follow mode
                    e.preventDefault();
                    if (state.followingMode) {
                        disableFollowMode();
                        showToast('Order cancelled', 'info');
                    } else {
                        // Close all positions
                        closeAllPositions();
                    }
                } else if (key === 'escape') {
                    // ESC also cancels
                    e.preventDefault();
                    if (state.followingMode) {
                        disableFollowMode();
                    }
                }
            });
        }

        // Interactive Order Placement - Cursor Following
        let followPriceLine = null;
        let followLineSide = null;

        function enableFollowMode(action) {
            if (state.followingMode) {
                // Cancel existing follow mode
                disableFollowMode();
            }

            state.followingMode = true;
            state.followingType = action;

            const isTrigger = state.orderType === 'FAKELIMIT';
            const color = isTrigger ? '#ffa500' : (action === 'BUY' ? '#00ff88' : '#ff4560');
            const titlePrefix = isTrigger ? 'TRIGGER ' : '';

            const ctx = getContextForSide(state.activeSide);
            if (!ctx || !ctx.series) return;

            // Create a price line that will follow cursor
            followPriceLine = ctx.series.createPriceLine({
                price: 100, // Initial price (will be updated on mouse move)
                color: color,
                lineWidth: 2,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: `${titlePrefix}${action}`,
            });
            followLineSide = state.activeSide;
            console.log('Created followPriceLine:', followPriceLine);

            // Change cursor
            document.getElementById('chart-container').style.cursor = 'crosshair';

            const orderLabel = isTrigger ? 'TRIGGER ' : '';
            showToast(`Click on chart to place ${orderLabel}${action} order`, 'info');
            console.log(`Follow mode enabled for ${action}`);
        }

        function disableFollowMode() {
            state.followingMode = false;
            state.followingType = null;

            if (followPriceLine) {
                const ctx = getContextForSide(followLineSide || state.activeSide);
                if (ctx?.series) {
                    ctx.series.removePriceLine(followPriceLine);
                }
                followPriceLine = null;
                followLineSide = null;
            }

            document.getElementById('chart-container').style.cursor = 'default';
        }

        function resetFollowLineForSide(side) {
            if (!state.followingMode) return;
            if (followPriceLine && followLineSide) {
                const prevCtx = getContextForSide(followLineSide);
                if (prevCtx?.series) {
                    prevCtx.series.removePriceLine(followPriceLine);
                }
            }

            const ctx = getContextForSide(side);
            if (!ctx?.series) {
                followPriceLine = null;
                followLineSide = null;
                return;
            }

            const isTrigger = state.orderType === 'FAKELIMIT';
            const color = isTrigger ? '#ffa500' : (state.followingType === 'BUY' ? '#00ff88' : '#ff4560');
            const titlePrefix = isTrigger ? 'TRIGGER ' : '';

            followPriceLine = ctx.series.createPriceLine({
                price: ctx.currentPrice || 100,
                color: color,
                lineWidth: 2,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `${titlePrefix}${state.followingType || ''}`.trim(),
            });
            followLineSide = side;
        }

        // Track crosshair position for follow line
        function setupChartInteraction() {
            console.log('setupChartInteraction called');
            Object.values(chartContexts).forEach(ctx => {
                if (!ctx?.chart || !ctx.series) return;

                ctx.chart.subscribeCrosshairMove((param) => {
                    if (!state.followingMode || !followPriceLine) return;
                    if (state.activeSide !== ctx.side) return;

                    if (param.point) {
                        const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                        const price = roundToTick(rawPrice);
                        if (price && price > 0) {
                            followPriceLine.applyOptions({ price: price });
                        }
                    }
                });

                ctx.chart.subscribeClick((param) => {
                    if (!param.point) return;

                    if (ctx.side && ctx.side !== state.activeSide) {
                        const preserveFollow = state.followingMode && (state.followingType === 'BUY' || state.followingType === 'SELL');
                        setActiveSide(ctx.side, { preserveFollow });
                    }

                    if (!state.followingMode) return;
                    if (state.followingType !== 'BUY' && state.followingType !== 'SELL') return;

                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);
                    if (price && price > 0) {
                        if (state.orderType === 'FAKELIMIT') {
                            placeFakeLimitOrder(price, state.followingType);
                        } else {
                            placeOrderAtPrice(price, state.followingType, {
                                side: ctx.side,
                                symbol: ctx.symbol,
                                ctx: ctx,
                                orderType: state.orderType
                            });
                        }
                        disableFollowMode();
                    }
                });
            });
        }

        // Place MARKET order immediately at current price
        function placeMarketOrder(action) {
            // Get current price from the last candle or state
            const currentPrice = state.currentPrice || 0;

            if (!currentPrice || currentPrice <= 0) {
                showToast('⚠️ Current price not available. Please wait...', 'error');
                return;
            }

            console.log(`Placing MARKET ${action} at current price: ₹${currentPrice}`);
            placeOrderAtPrice(currentPrice, action);
        }

        function computeTPSLPrices(basePrice, action, tpPoints, slPoints) {
            const tpPrice = action === 'BUY' ? basePrice + tpPoints : basePrice - tpPoints;
            const slPrice = action === 'BUY' ? basePrice - slPoints : basePrice + slPoints;
            return { tpPrice, slPrice };
        }

        function createAutoTPSLLines(ctx, basePrice, action, tpPoints, slPoints) {
            if (!ctx?.series) return { tpOrder: null, slOrder: null };
            const { tpPrice, slPrice } = computeTPSLPrices(basePrice, action, tpPoints, slPoints);
            const tpLine = ctx.series.createPriceLine({
                price: tpPrice,
                color: '#00ff88',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `TP @ ${tpPrice.toFixed(2)}`
            });
            const slLine = ctx.series.createPriceLine({
                price: slPrice,
                color: '#ff4560',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: `SL @ ${slPrice.toFixed(2)}`
            });
            return {
                tpOrder: { price: tpPrice, priceLine: tpLine },
                slOrder: { price: slPrice, priceLine: slLine }
            };
        }

        function attachOrderTPSLOverlays(orderData) {
            if (!orderData) return;
            if (orderData.tpOrder?.priceLine && !orderData.tpOrder.overlay) {
                orderData.tpOrder.overlay = createOrderTPSLOverlay(orderData, 'TP');
            }
            if (orderData.slOrder?.priceLine && !orderData.slOrder.overlay) {
                orderData.slOrder.overlay = createOrderTPSLOverlay(orderData, 'SL');
            }
        }

        function removeOrderTPSL(orderData, type) {
            if (!orderData) return;
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            if (!ctx?.series) return;

            if (type === 'TP') {
                if (orderData.tpOrder?.priceLine) {
                    ctx.series.removePriceLine(orderData.tpOrder.priceLine);
                }
                if (orderData.tpOrder?.overlay) {
                    orderData.tpOrder.overlay.remove();
                }
                orderData.tpOrder = null;
                orderData.tpAuto = false;
            } else {
                if (orderData.slOrder?.priceLine) {
                    ctx.series.removePriceLine(orderData.slOrder.priceLine);
                }
                if (orderData.slOrder?.overlay) {
                    orderData.slOrder.overlay.remove();
                }
                orderData.slOrder = null;
                orderData.slAuto = false;
            }
        }

        function createOrderTPSLOverlay(orderData, type) {
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            const tpsl = type === 'TP' ? orderData.tpOrder : orderData.slOrder;
            if (!ctx?.series || !tpsl || !Number.isFinite(tpsl.price)) return null;

            const overlay = document.createElement('div');
            overlay.className = 'tpsl-line-overlay';
            overlay.dataset.orderId = orderData.orderId || orderData.id || '';
            overlay.dataset.tpslType = type;

            const label = document.createElement('div');
            label.className = `order-line-label ${type === 'TP' ? 'buy' : 'sell'}`;
            label.textContent = `${type} @ ₹${tpsl.price.toFixed(2)}`;
            overlay.appendChild(label);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'tpsl-close';
            closeBtn.type = 'button';
            closeBtn.textContent = '×';
            closeBtn.title = `Remove ${type}`;
            closeBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                removeOrderTPSL(orderData, type);
            });
            overlay.appendChild(closeBtn);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, tpsl.price, ctx);

            setupOrderTPSLDraggable(overlay, orderData, type);
            return overlay;
        }

        function setupOrderTPSLDraggable(overlay, orderData, type) {
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            if (!ctx?.series) return;
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                const tpsl = type === 'TP' ? orderData.tpOrder : orderData.slOrder;
                if (!tpsl) return;
                startY = e.clientY;
                startPrice = tpsl.price;

                const onMouseMove = (e) => {
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        tpsl.price = newPrice;
                        tpsl.priceLine?.applyOptions({
                            price: newPrice,
                            title: `${type} @ ${newPrice.toFixed(2)}`
                        });
                        if (type === 'TP') {
                            orderData.tpAuto = false;
                        } else {
                            orderData.slAuto = false;
                        }
                        updateOverlayPosition(overlay, newPrice, ctx);
                        const label = overlay.querySelector('.order-line-label');
                        if (label) {
                            label.textContent = `${type} @ ₹${newPrice.toFixed(2)}`;
                        }
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function updateAutoTPSLLines(orderData, basePrice) {
            if (!orderData) return;
            const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
            const tpPoints = Number.isFinite(orderData.tpPoints) ? orderData.tpPoints : state.tpPoints;
            const slPoints = Number.isFinite(orderData.slPoints) ? orderData.slPoints : state.slPoints;
            const { tpPrice, slPrice } = computeTPSLPrices(basePrice, orderData.action, tpPoints, slPoints);

            const tpAuto = orderData.tpAuto !== false;
            const slAuto = orderData.slAuto !== false;

            if (tpAuto && orderData.tpOrder?.priceLine) {
                orderData.tpOrder.price = tpPrice;
                orderData.tpOrder.priceLine.applyOptions({
                    price: tpPrice,
                    title: `TP @ ${tpPrice.toFixed(2)}`
                });
                if (orderData.tpOrder?.overlay) {
                    updateOverlayPosition(orderData.tpOrder.overlay, tpPrice, ctx);
                    const label = orderData.tpOrder.overlay.querySelector('.order-line-label');
                    if (label) label.textContent = `TP @ ₹${tpPrice.toFixed(2)}`;
                }
            } else if (tpAuto) {
                const lines = createAutoTPSLLines(ctx, basePrice, orderData.action, tpPoints, slPoints);
                orderData.tpOrder = lines.tpOrder;
                orderData.slOrder = lines.slOrder;
                attachOrderTPSLOverlays(orderData);
                return;
            }

            if (slAuto && orderData.slOrder?.priceLine) {
                orderData.slOrder.price = slPrice;
                orderData.slOrder.priceLine.applyOptions({
                    price: slPrice,
                    title: `SL @ ${slPrice.toFixed(2)}`
                });
                if (orderData.slOrder?.overlay) {
                    updateOverlayPosition(orderData.slOrder.overlay, slPrice, ctx);
                    const label = orderData.slOrder.overlay.querySelector('.order-line-label');
                    if (label) label.textContent = `SL @ ₹${slPrice.toFixed(2)}`;
                }
            }
        }

        // Place order at specific price
        async function placeOrderAtPrice(price, action, options = {}) {
            const symbol = options.symbol || state.symbol;
            const side = options.side || state.activeSide;
            const orderType = options.orderType || state.orderType;
            const ctx = options.ctx || getContextForSide(side);

            console.log(`Placing ${action} order at ₹${price.toFixed(2)}`);

            // Use lot size from URL params (passed from main interface)
            const lots = Number.isFinite(options.lots) ? options.lots : state.quantity;
            const actualQuantity = lots * state.lotSize;
            console.log(`Quantity: ${lots} lots × ${state.lotSize} = ${actualQuantity}`);

            const orderData = {
                apikey: state.apiKey,
                strategy: options.strategy || (options.autoTag ? 'auto_trading' : 'chart_trading'),
                exchange: state.exchange, // Already mapped to NFO/BFO
                symbol: symbol,
                action: action,
                quantity: String(actualQuantity),
                pricetype: orderType,
                product: 'MIS'
            };

            // Add price for LIMIT orders (use clicked price)
            if (orderType === 'LIMIT') {
                orderData.price = price.toFixed(2);
                console.log(`LIMIT order - using clicked price: ₹${price.toFixed(2)}`);
            }

            try {
                showToast(`Placing ${action} order...`, 'info');

                console.log('Order data:', orderData);

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 sec timeout for order placement

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();
                console.log('Order response:', result);

                if (result.status === 'success') {
                    showToast(`✅ ${action} order placed at ₹${price.toFixed(2)}`, 'success');

                    // Draw order line on chart immediately
                    const meta = {
                        quantity: actualQuantity,
                        lots: lots,
                        tpPoints: Number.isFinite(options.tpPoints) ? options.tpPoints : state.tpPoints,
                        slPoints: Number.isFinite(options.slPoints) ? options.slPoints : state.slPoints,
                        autoTag: !!options.autoTag,
                        paper: !!options.paper
                    };
                    drawOrderLine(price, action, result.orderid, orderType, side, ctx, meta);

                    if (options.autoTag) {
                        autoState.pendingOrders.set(result.orderid, {
                            side,
                            symbol,
                            lots,
                            ts: Date.now(),
                            entryPrice: price,
                            reason: options.reason || '',
                            tpPoints: options.tpPoints,
                            slPoints: options.slPoints,
                            // Capture at decision time for accurate logging
                            preset: autoState.presetKey || 'custom',
                            presetLabel: AUTO_PRESETS[autoState.presetKey]?.label || 'Custom',
                            adaptivePreset: autoState.currentAdaptivePreset || null,
                            adaptivePresetLabel: autoState.currentAdaptivePreset ? AUTO_PRESETS[autoState.currentAdaptivePreset]?.label : null,
                            momentumTicks: autoState.momentumTicks,
                            momentumCount: autoState.momentumCount?.[side] || 0,
                            momentumThreshold: getAutoMomentumThreshold(),
                            momentumVelocity: typeof getMomentumVelocity === 'function' ? getMomentumVelocity(side) : 0,
                            regime: autoState.currentRegime || 'UNKNOWN',
                            regimeMode: autoState.regimeTradingMode || 'all',
                            noTradeZoneActive: typeof isNoTradeZone === 'function' ? isNoTradeZone() : false,
                            underlyingFilterOk: autoState.underlyingFilterEnabled && typeof autoUnderlyingOk === 'function' ? autoUnderlyingOk(side) : null,
                            candleConfirmOk: autoState.candleConfirmEnabled && typeof autoCandleOk === 'function' ? autoCandleOk(side) : null,
                            relativeStrengthOk: autoState.relativeStrengthEnabled && typeof autoRelativeStrengthOk === 'function' ? autoRelativeStrengthOk(side) : null
                        });
                    }

                    // For MARKET orders, check fill immediately (don't wait for 5s poll)
                    if (orderType === 'MARKET') {
                        setTimeout(() => checkOrderFills(), 200);
                    }
                } else {
                    showToast(`❌ Order failed: ${result.message}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Order timeout - broker server slow', 'error');
                } else {
                    console.error('Error placing order:', error);
                    showToast(`❌ Order failed: ${error.message}`, 'error');
                }
            }
        }

        // Depth panel: place smart order directly from order book price (does not change UI order type)
        async function placeDepthSmartOrder(price, action, pricetype, mode, options = {}) {
            const actualQuantity = state.quantity * state.lotSize;
            const orderData = {
                apikey: state.apiKey,
                strategy: 'chart_trading',
                exchange: state.exchange,
                symbol: state.symbol,
                action: action,
                quantity: String(actualQuantity),
                pricetype: pricetype,
                product: 'MIS',
                price: pricetype === 'LIMIT' ? price.toFixed(2) : undefined
            };

            try {
                const label = pricetype === 'MARKET' ? 'market' : 'limit';
                showToast(`Placing ${action} ${label}...`, 'info');

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 sec timeout

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    const orderId = result.orderid || result.order_id || `DEPTH_${Date.now()}`;
                    if (pricetype === 'LIMIT') {
                        drawOrderLine(price, action, orderId, 'LIMIT', state.activeSide, getContextForSide(state.activeSide));
                        showToast(`✅ ${action} limit placed at ₹${price.toFixed(2)}`, 'success');
                        if (depthState.repriceEnabled && !Number.isFinite(depthState.selectedPrice)) {
                            const retriesLeft = Number.isFinite(options.retriesLeft) ? options.retriesLeft : depthState.repriceMaxRetries;
                            scheduleDepthReprice(orderId, action, mode || depthState.orderMode, retriesLeft);
                        }
                    } else {
                        showToast(`✅ ${action} market order placed`, 'success');
                    }
                } else {
                    showToast(`❌ Order failed: ${result.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Order timeout - broker server slow', 'error');
                } else {
                    console.error('Error placing depth order:', error);
                    showToast(`❌ Order failed: ${error.message}`, 'error');
                }
            }
        }

        async function isOrderOpen(orderId) {
            try {
                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });
                const result = await response.json();
                if (result.status !== 'success' || !result.data || !result.data.orders) return false;
                const order = result.data.orders.find(o => String(o.orderid) === String(orderId));
                if (!order) return false;
                const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();
                return status === 'OPEN' ||
                    status === 'PENDING' ||
                    status === 'TRIGGER PENDING' ||
                    status === 'PENDING ORDER' ||
                    status === 'NOT EXECUTED';
            } catch (error) {
                console.error('Error checking order status:', error);
                return false;
            }
        }

        function updateDepthOrderVisual(orderId, newPrice) {
            const order = state.orders.get(orderId);
            if (!order) return;
            order.price = newPrice;
            if (order.priceLine) {
                order.priceLine.applyOptions({ price: newPrice });
            }
            if (order.overlay) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                updateOverlayPosition(order.overlay, newPrice, ctx);
                const label = order.overlay.querySelector('.order-line-label');
                if (label) {
                    label.textContent = `${order.action} @ ₹${newPrice.toFixed(2)}`;
                }
            }
            if (order.type === 'LIMIT') {
                updateAutoTPSLLines(order, newPrice);
            }
        }

        function scheduleDepthReprice(orderId, action, mode, retriesLeft) {
            if (!depthState.repriceEnabled || !depthState.enabled) return;
            if (!Number.isFinite(retriesLeft) || retriesLeft <= 0) return;
            setTimeout(async () => {
                if (!depthState.repriceEnabled || !depthState.enabled) return;
                const stillOpen = await isOrderOpen(orderId);
                if (!stillOpen) return;

                const spec = getDepthOrderSpec(action, mode);
                if (spec.pricetype !== 'LIMIT' || !Number.isFinite(spec.price)) return;

                updateDepthOrderVisual(orderId, spec.price);
                await modifyOrder(orderId, spec.price, state.orders.get(orderId)?.symbol);

                scheduleDepthReprice(orderId, action, mode, retriesLeft - 1);
            }, Math.max(100, depthState.repriceMs));
        }

        // ========== FAKE LIMIT (VIRTUAL TRIGGER) ORDERS ==========

        function placeFakeLimitOrder(triggerPrice, action) {
            const side = state.activeSide;
            const ctx = getContextForSide(side);
            const priceAtPlacement = ctx?.currentPrice || state.currentPrice;
            if (!ctx?.series) {
                showToast('Chart not ready yet', 'error');
                return;
            }

            // Direction based on action: BUY fires when price rises (>=), SELL fires when price drops (<=)
            const direction = action === 'BUY' ? 'ABOVE' : 'BELOW';

            // Prevent triggers that would fire immediately (only validate if we have a live price)
            if (priceAtPlacement > 0) {
                if (action === 'BUY' && priceAtPlacement >= triggerPrice) {
                    showToast(`BUY trigger must be above current price (₹${priceAtPlacement.toFixed(2)})`, 'error');
                    return;
                }
                if (action === 'SELL' && priceAtPlacement <= triggerPrice) {
                    showToast(`SELL trigger must be below current price (₹${priceAtPlacement.toFixed(2)})`, 'error');
                    return;
                }
            }

            const id = `fakelimit_${++state.fakeLimitIdCounter}`;
            const actualQuantity = state.quantity * state.lotSize;

            console.log(`[TRIGGER] Placing: ${action} at ₹${triggerPrice.toFixed(2)} (LTP ₹${priceAtPlacement.toFixed(2)}, ${direction})`);

            const { priceLine, overlay } = drawFakeLimitLine(ctx, triggerPrice, action, id);
            const autoLines = createAutoTPSLLines(ctx, triggerPrice, action, state.tpPoints, state.slPoints);

            state.fakeLimitOrders.set(id, {
                id,
                action,
                triggerPrice,
                priceAtPlacement,
                direction,
                side,
                symbol: ctx?.symbol || state.symbol,
                ctx,
                quantity: actualQuantity,
                lots: state.quantity,
                priceLine,
                overlay,
                tpOrder: autoLines.tpOrder,
                slOrder: autoLines.slOrder,
                tpPoints: state.tpPoints,
                slPoints: state.slPoints,
                tpAuto: true,
                slAuto: true,
                createdAt: Date.now()
            });

            const orderData = state.fakeLimitOrders.get(id);
            attachOrderTPSLOverlays(orderData);

            showToast(`Trigger ${action} at ₹${triggerPrice.toFixed(2)} (fires when LTP ${action === 'BUY' ? '>=' : '<='} ₹${triggerPrice.toFixed(2)})`, 'success');
        }

        function drawFakeLimitLine(ctx, price, action, id) {
            if (!ctx?.series) return { priceLine: null, overlay: null };
            const priceLine = ctx.series.createPriceLine({
                price: price,
                color: '#ffa500',
                lineWidth: 2,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: ''
            });

            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay fake-limit';
            overlay.dataset.fakeLimitId = id;

            // Cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.style.borderColor = '#ffa500';
            cancelBtn.style.color = '#ffa500';
            cancelBtn.style.background = 'rgba(255, 165, 0, 0.2)';
            cancelBtn.textContent = '\u2715';
            cancelBtn.title = 'Cancel trigger order';
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginRight = '8px';
            cancelBtn.style.flexShrink = '0';
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                cancelFakeLimitOrder(id);
            });
            overlay.appendChild(cancelBtn);

            // Label
            const label = document.createElement('div');
            label.className = `order-line-label trigger-${action.toLowerCase()}`;
            label.textContent = `TRIGGER ${action} @ \u20B9${price.toFixed(2)}`;
            overlay.appendChild(label);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            setupFakeLimitDraggable(overlay, id);

            return { priceLine, overlay };
        }

        function setupFakeLimitDraggable(overlay, fakeLimitId) {
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (e.target.classList.contains('order-close-btn')) return;
                e.preventDefault();
                e.stopPropagation();

                const orderData = state.fakeLimitOrders.get(fakeLimitId);
                if (!orderData) return;

                overlay.classList.add('dragging');
                startY = e.clientY;
                startPrice = orderData.triggerPrice;

                const onMouseMove = (e) => {
                    const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
                    if (!ctx?.series) return;
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        orderData.triggerPrice = newPrice;
                        orderData.priceLine.applyOptions({ price: newPrice });
                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent =
                            `TRIGGER ${orderData.action} @ \u20B9${newPrice.toFixed(2)}`;
                        updateAutoTPSLLines(orderData, newPrice);
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    const orderData = state.fakeLimitOrders.get(fakeLimitId);
                    if (orderData && Math.abs(orderData.triggerPrice - startPrice) > 0.01) {
                        showToast(`Trigger moved to \u20B9${orderData.triggerPrice.toFixed(2)}`, 'info');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function cancelFakeLimitOrder(id) {
            const order = state.fakeLimitOrders.get(id);
            if (!order) return;

            const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
            if (order.priceLine) {
                ctx?.series?.removePriceLine(order.priceLine);
            }
            if (order.overlay) {
                order.overlay.remove();
            }
            if (order.tpOrder?.priceLine) {
                ctx?.series?.removePriceLine(order.tpOrder.priceLine);
            }
            if (order.slOrder?.priceLine) {
                ctx?.series?.removePriceLine(order.slOrder.priceLine);
            }
            if (order.tpOrder?.overlay) {
                order.tpOrder.overlay.remove();
            }
            if (order.slOrder?.overlay) {
                order.slOrder.overlay.remove();
            }
            state.fakeLimitOrders.delete(id);
            showToast('Trigger order cancelled', 'info');
        }

        function checkFakeLimitTriggers() {
            if (state.fakeLimitOrders.size === 0) return;

            for (const [id, order] of [...state.fakeLimitOrders.entries()]) {
                const ctx = order.ctx || getContextForSide(order.side);
                const ltp = ctx?.currentPrice || 0;
                if (!ltp || ltp <= 0) continue;
                // BUY triggers when price rises to level (>=), SELL triggers when price drops to level (<=)
                const triggered = order.action === 'BUY'
                    ? ltp >= order.triggerPrice
                    : ltp <= order.triggerPrice;

                if (triggered) {
                    console.log(`[TRIGGER] FIRED: ${order.action} at LTP=${ltp}, trigger=${order.triggerPrice}, dir=${order.direction}`);
                    executeFakeLimitOrder(id, order);
                }
            }
        }

        async function executeFakeLimitOrder(id, order) {
            const pendingTPSL = {
                tpOrder: order.tpOrder,
                slOrder: order.slOrder,
                tpPoints: order.tpPoints,
                slPoints: order.slPoints
            };

            const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
            const symbol = order.symbol || ctx?.symbol || state.symbol;

            // Remove visual trigger line immediately (keep TP/SL lines)
            if (order.priceLine) {
                ctx?.series?.removePriceLine(order.priceLine);
            }
            if (order.overlay) {
                order.overlay.remove();
            }
            state.fakeLimitOrders.delete(id);

            showToast(`Trigger fired! Placing MARKET ${order.action}...`, 'info');

            const orderData = {
                apikey: state.apiKey,
                strategy: 'chart_trigger',
                exchange: state.exchange,
                symbol: symbol,
                action: order.action,
                quantity: String(order.quantity),
                pricetype: 'MARKET',
                product: 'MIS',
                price: '0',
                trigger_price: '0',
                disclosed_quantity: '0'
            };

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000);

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`\u2705 Trigger ${order.action} executed! OrderID: ${result.orderid}`, 'success');

                    // Temporarily use the TP/SL values from when the trigger was placed
                    const savedTP = state.tpPoints;
                    const savedSL = state.slPoints;
                    state.tpPoints = order.tpPoints;
                    state.slPoints = order.slPoints;

                    // Draw order line so checkOrderFills() tracks fill + auto TP/SL
                    drawOrderLine(ctx?.currentPrice || state.currentPrice, order.action, result.orderid, 'MARKET', order.side, ctx);

                    state.tpPoints = savedTP;
                    state.slPoints = savedSL;

                    const trackedOrder = state.orders.get(result.orderid);
                    if (trackedOrder && pendingTPSL) {
                        trackedOrder.tpOrder = pendingTPSL.tpOrder || trackedOrder.tpOrder;
                        trackedOrder.slOrder = pendingTPSL.slOrder || trackedOrder.slOrder;
                        trackedOrder.tpPoints = pendingTPSL.tpPoints;
                        trackedOrder.slPoints = pendingTPSL.slPoints;
                        trackedOrder.tpAuto = order.tpAuto !== false;
                        trackedOrder.slAuto = order.slAuto !== false;
                    }

                    // Immediate fill check for MARKET order
                    setTimeout(() => checkOrderFills(), 200);
                } else {
                    showToast(`\u274C Trigger ${order.action} failed: ${result.message}`, 'error');
                    if (pendingTPSL.tpOrder?.priceLine) {
                        ctx?.series?.removePriceLine(pendingTPSL.tpOrder.priceLine);
                    }
                    if (pendingTPSL.slOrder?.priceLine) {
                        ctx?.series?.removePriceLine(pendingTPSL.slOrder.priceLine);
                    }
                    if (pendingTPSL.tpOrder?.overlay) {
                        pendingTPSL.tpOrder.overlay.remove();
                    }
                    if (pendingTPSL.slOrder?.overlay) {
                        pendingTPSL.slOrder.overlay.remove();
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('\u274C Trigger order timeout - broker slow', 'error');
                } else {
                    showToast(`\u274C Trigger order error: ${error.message}`, 'error');
                }
                if (pendingTPSL.tpOrder?.priceLine) {
                    ctx?.series?.removePriceLine(pendingTPSL.tpOrder.priceLine);
                }
                if (pendingTPSL.slOrder?.priceLine) {
                    ctx?.series?.removePriceLine(pendingTPSL.slOrder.priceLine);
                }
                if (pendingTPSL.tpOrder?.overlay) {
                    pendingTPSL.tpOrder.overlay.remove();
                }
                if (pendingTPSL.slOrder?.overlay) {
                    pendingTPSL.slOrder.overlay.remove();
                }
            }
        }

        // ========== END FAKE LIMIT ==========

        function drawOrderLine(price, action, orderId, orderTypeOverride, sideOverride, ctxOverride, meta = {}) {
            const orderType = orderTypeOverride || state.orderType;
            const side = sideOverride || state.activeSide;
            const ctx = ctxOverride || getContextForSide(side);
            if (!ctx?.series) return;

            // Create lightweight charts price line
            const color = action === 'BUY' ? '#00ff88' : '#ff4560';
            const priceLine = ctx.series.createPriceLine({
                price: price,
                color: color,
                lineWidth: 2,
                lineStyle: 0, // Solid
                axisLabelVisible: true,
                title: '' // No title - we use the HTML overlay label instead
            });

            // Create HTML overlay for dragging and controls
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.dataset.orderId = orderId;

            // Cancel button (X mark) on the left
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.textContent = '✕';
            cancelBtn.title = 'Cancel order';
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginRight = '8px'; // Space between X and label
            cancelBtn.style.flexShrink = '0'; // Don't shrink
            // Use mousedown to prevent overlay drag from starting
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            // Use click for actual cancellation
            const orderSymbol = ctx.symbol || state.symbol;
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                cancelSingleOrder(orderId, orderSymbol);
            });
            overlay.appendChild(cancelBtn);

            // Order label (next to X button)
            const label = document.createElement('div');
            label.className = `order-line-label ${action.toLowerCase()}`;
            label.textContent = `${action} @ ₹${price.toFixed(2)}`;
            overlay.appendChild(label);

            // P&L label (will show when position fills)
            const pnlLabel = document.createElement('div');
            pnlLabel.className = 'pnl-label';
            pnlLabel.style.display = 'none';
            pnlLabel.style.marginLeft = 'auto'; // Push to the right
            overlay.appendChild(pnlLabel);

            // Add to chart
            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            // Store order data
            const orderData = {
                orderId,
                type: orderType,
                action,
                price,
                side,
                symbol: orderSymbol,
                ctx,
                quantity: Number.isFinite(meta.quantity) ? meta.quantity : state.quantity * state.lotSize,
                status: 'pending',
                priceLine,
                overlay,
                pnlLabel,
                tpOrder: null,
                slOrder: null,
                tpPoints: Number.isFinite(meta.tpPoints) ? meta.tpPoints : state.tpPoints,
                slPoints: Number.isFinite(meta.slPoints) ? meta.slPoints : state.slPoints,
                tpAuto: true,
                slAuto: true,
                autoTag: !!meta.autoTag,
                paper: !!meta.paper,
                lots: Number.isFinite(meta.lots) ? meta.lots : state.quantity
            };

            if (orderType === 'LIMIT') {
                const autoLines = createAutoTPSLLines(ctx, price, action, orderData.tpPoints, orderData.slPoints);
                orderData.tpOrder = autoLines.tpOrder;
                orderData.slOrder = autoLines.slOrder;
                attachOrderTPSLOverlays(orderData);
            }
            state.orders.set(orderId, orderData);

            // Make draggable for LIMIT orders
            if (orderType === 'LIMIT') {
                setupDraggable(overlay, orderData);
            }

            console.log(`Order line created: ${orderId} at ₹${price}`);
        }

        // Update overlay position
        function updateOverlayPosition(overlay, price, ctx) {
            const series = ctx?.series || state.candlestickSeries;
            if (!series || !overlay) return;
            const y = series.priceToCoordinate(price);
            if (y !== null) {
                overlay.style.top = `${y}px`;
            }
        }

        // Update all overlays when chart moves
        function updateAllOverlays() {
            state.orders.forEach(order => {
                if (order.overlay) updateOverlayPosition(order.overlay, order.price, order.ctx);
                if (order.tpOrder?.overlay) updateOverlayPosition(order.tpOrder.overlay, order.tpOrder.price, order.ctx);
                if (order.slOrder?.overlay) updateOverlayPosition(order.slOrder.overlay, order.slOrder.price, order.ctx);
            });

            Object.entries(positionStates).forEach(([side, posState]) => {
                const ctx = getContextForSide(side);
                if (!ctx) return;
                if (posState.positionOverlay && posState.entryPrice) {
                    updateOverlayPosition(posState.positionOverlay, posState.entryPrice, ctx);
                }
                if (posState.positionTPSL?.tpOverlay && posState.positionTPSL?.tpPrice) {
                    updateOverlayPosition(posState.positionTPSL.tpOverlay, posState.positionTPSL.tpPrice, ctx);
                }
                if (posState.positionTPSL?.slOverlay && posState.positionTPSL?.slPrice) {
                    updateOverlayPosition(posState.positionTPSL.slOverlay, posState.positionTPSL.slPrice, ctx);
                }
            });

            state.fakeLimitOrders.forEach(order => {
                if (order.overlay) updateOverlayPosition(order.overlay, order.triggerPrice, order.ctx);
                if (order.tpOrder?.overlay) updateOverlayPosition(order.tpOrder.overlay, order.tpOrder.price, order.ctx);
                if (order.slOrder?.overlay) updateOverlayPosition(order.slOrder.overlay, order.slOrder.price, order.ctx);
            });
        }

        // Setup draggable for limit orders
        function setupDraggable(overlay, orderData) {
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                startY = e.clientY;
                startPrice = orderData.price;

                const onMouseMove = (e) => {
                    const ctx = orderData.ctx || getContextForSide(orderData.side) || getContextForSide(state.activeSide);
                    if (!ctx?.series) return;
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        orderData.price = newPrice;
                        orderData.priceLine.applyOptions({ price: newPrice, title: `${orderData.action} @ ${newPrice.toFixed(2)}` });
                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent = `${orderData.action} @ ₹${newPrice.toFixed(2)}`;
                        if (orderData.type === 'LIMIT') {
                            updateAutoTPSLLines(orderData, newPrice);
                        }
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    if (Math.abs(orderData.price - startPrice) > 0.01) {
                        modifyOrder(orderData.orderId, orderData.price, orderData.symbol);
                        showToast(`Order modified to ₹${orderData.price.toFixed(2)}`, 'success');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // Modify order API call
        async function modifyOrder(orderId, newPrice, symbolOverride) {
            const order = state.orders.get(orderId);
            if (!order) return;
            const symbol = symbolOverride || order.symbol || state.symbol;

            try {
                const response = await fetch('/api/v1/modifyorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apikey: state.apiKey,
                        strategy: 'chart_trading',
                        exchange: state.exchange,
                        symbol: state.symbol,
                        orderid: orderId,
                        action: order.action,
                        quantity: order.quantity,
                        product: 'MIS',
                        pricetype: 'LIMIT',
                        price: newPrice.toFixed(2),
                        trigger_price: 0,
                        disclosed_quantity: 0
                    })
                });

                const result = await response.json();
                if (result.status !== 'success') {
                    showToast(`⚠️ Modify failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error modifying order:', error);
            }
        }

        // Show order controls popup
        let currentPopup = null;
        function showOrderControls(orderData, x, y) {
            // Remove existing popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }

            const popup = document.createElement('div');
            popup.className = 'order-controls-popup';
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;

            // Set TP button
            const tpBtn = document.createElement('button');
            tpBtn.className = 'set-tp-btn';
            tpBtn.textContent = orderData.tpOrder ? '✓ TP Set' : 'Set TP';
            tpBtn.addEventListener('click', () => {
                enableTPSLMode(orderData, 'TP');
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(tpBtn);

            // Set SL button
            const slBtn = document.createElement('button');
            slBtn.className = 'set-sl-btn';
            slBtn.textContent = orderData.slOrder ? '✓ SL Set' : 'Set SL';
            slBtn.addEventListener('click', () => {
                enableTPSLMode(orderData, 'SL');
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(slBtn);

            // Close order button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-order-btn';
            closeBtn.textContent = '✕ Close Order';
            closeBtn.addEventListener('click', () => {
                closeOrder(orderData.orderId);
                popup.remove();
                currentPopup = null;
            });
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
            currentPopup = popup;

            // Close popup when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        currentPopup = null;
                        document.removeEventListener('click', closePopup);
                    }
                }, { once: true });
            }, 10);
        }

        // Enable TP/SL placement mode
        function enableTPSLMode(parentOrder, type) {
            const action = type === 'TP'
                ? (parentOrder.action === 'BUY' ? 'SELL' : 'BUY')
                : (parentOrder.action === 'BUY' ? 'SELL' : 'BUY');

            const color = type === 'TP' ? '#00ff88' : '#ff4560';
            const style = 2; // Dashed
            const ctx = parentOrder.ctx || getContextForSide(parentOrder.side) || getContextForSide(state.activeSide);
            if (!ctx?.series || !ctx?.chart) return;

            // Create follow line
            const priceLine = ctx.series.createPriceLine({
                price: parentOrder.price,
                color: color,
                lineWidth: 2,
                lineStyle: style,
                axisLabelVisible: true,
                title: `${type}`
            });

            state.followingMode = true;
            state.followingType = type;
            state.tpslParent = parentOrder;
            showToast(`Click chart to set ${type} level`, 'info');

            // Update line on mouse move
            ctx.chart.subscribeCrosshairMove((param) => {
                if (!state.followingMode || state.followingType !== type) return;

                if (param.point) {
                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);

                    if (price && price > 0) {
                        priceLine.applyOptions({ price: price });
                    }
                }
            });

            // Place TP/SL on click
            const clickHandler = (param) => {
                if (!state.followingMode || state.followingType !== type) return;

                if (param.point) {
                    const rawPrice = ctx.series.coordinateToPrice(param.point.y);
                    const price = roundToTick(rawPrice);

                    if (price && price > 0) {
                        // Remove follow line
                        ctx.series.removePriceLine(priceLine);

                        // Place TP/SL order
                        placeTPSLOrder(parentOrder, type, price);

                        state.followingMode = false;
                        state.followingType = null;
                        state.tpslParent = null;
                    }
                }
            };

            ctx.chart.subscribeClick(clickHandler);
        }

        // Place TP or SL order
        async function placeTPSLOrder(parentOrder, type, price) {
            const action = type === 'TP'
                ? (parentOrder.action === 'BUY' ? 'SELL' : 'BUY')
                : (parentOrder.action === 'BUY' ? 'SELL' : 'BUY');

            // This would be a LIMIT order at the TP/SL price
            showToast(`${type} order placed at ₹${price.toFixed(2)}`, 'success');

            // For now just create the visual line
            // In production, you'd call the order API here
            const color = type === 'TP' ? '#00ff88' : '#ff4560';
            const ctx = parentOrder.ctx || getContextForSide(parentOrder.side) || getContextForSide(state.activeSide);
            if (type === 'TP' && parentOrder.tpOrder?.priceLine) {
                ctx?.series?.removePriceLine(parentOrder.tpOrder.priceLine);
                parentOrder.tpOrder = null;
            }
            if (type === 'SL' && parentOrder.slOrder?.priceLine) {
                ctx?.series?.removePriceLine(parentOrder.slOrder.priceLine);
                parentOrder.slOrder = null;
            }
            const priceLine = ctx?.series?.createPriceLine({
                price: price,
                color: color,
                lineWidth: 1,
                lineStyle: 2, // Dashed
                axisLabelVisible: true,
                title: `${type} @ ${price.toFixed(2)}`
            });

            // Store reference
            if (type === 'TP') {
                parentOrder.tpOrder = { price, priceLine };
            } else {
                parentOrder.slOrder = { price, priceLine };
            }
        }

        // Close order/position
        async function closeOrder(orderId) {
            // TODO: Call close position API
            showToast('Closing order...', 'info');

            // Remove from chart
            const order = state.orders.get(orderId);
            if (order) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                order.priceLine && ctx?.series?.removePriceLine(order.priceLine);
                order.overlay && order.overlay.remove();
                order.tpOrder?.priceLine && ctx?.series?.removePriceLine(order.tpOrder.priceLine);
                order.slOrder?.priceLine && ctx?.series?.removePriceLine(order.slOrder.priceLine);
                order.tpOrder?.overlay && order.tpOrder.overlay.remove();
                order.slOrder?.overlay && order.slOrder.overlay.remove();
                state.orders.delete(orderId);
                showToast('Order closed', 'success');
            }
        }

        // Close all positions
        function closeAllPositions() {
            // Cancel all fake limit trigger orders
            for (const [id] of [...state.fakeLimitOrders]) {
                cancelFakeLimitOrder(id);
            }

            if (state.orders.size === 0 && state.fakeLimitOrders.size === 0) {
                showToast('No positions to close', 'info');
                return;
            }

            if (state.orders.size > 0) {
                const orderIds = Array.from(state.orders.keys());
                showToast(`Closing ${orderIds.length} position(s)...`, 'info');
                orderIds.forEach(orderId => closeOrder(orderId));
            }
        }

        // Update live P&L for all positions
        function updateLivePNL() {
            state.orders.forEach(order => {
                const ctx = order.ctx || getContextForSide(order.side);
                const ltp = ctx?.currentPrice || state.currentPrice;
                if (!ltp || ltp <= 0) return;
                if (order.status === 'filled' && order.pnlLabel) {
                    const priceDiff = order.action === 'BUY'
                        ? (ltp - order.price)
                        : (order.price - ltp);

                    const pnl = priceDiff * order.quantity;
                    const pnlPct = (priceDiff / order.price) * 100;

                    order.pnlLabel.textContent = `₹${pnl.toFixed(2)} (${pnlPct > 0 ? '+' : ''}${pnlPct.toFixed(2)}%)`;
                    order.pnlLabel.className = pnl >= 0 ? 'pnl-label profit' : 'pnl-label loss';
                    order.pnlLabel.style.display = 'block';
                }
            });
        }

        // Start P&L update interval
        setInterval(() => {
            if (state.orders.size > 0) updateLivePNL();
        }, 1000);

        // WebSocket connection for live data
        // WebSocket connection for live data
        function connectWebSocket() {
            // Use configured WebSocket URL
            const wsUrl = CONFIG.wsUrl;
            console.log('Connecting to WebSocket:', wsUrl);

            state.ws = new WebSocket(wsUrl);

            state.ws.onopen = () => {
                console.log('Chart WebSocket connected');

                // Authenticate
                state.ws.send(JSON.stringify({
                    action: 'authenticate',
                    api_key: state.apiKey
                }));
            };

            state.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                // Debug: Log ALL WebSocket messages
                debugLog('📨 WS Message:', data);

                // Handle auth response
                if (data.type === 'auth' && data.status === 'success') {
                    debugLog('✅ Chart authenticated, subscribing to', state.symbol, 'on', state.exchange);
                    depthState.broker = data.broker || depthState.broker;
                    updateDepthBrokerUI();
                    const ltpSymbols = [];
                    if (state.ceSymbol) {
                        ltpSymbols.push({ symbol: state.ceSymbol, exchange: state.exchange });
                    }
                    if (state.peSymbol && state.peSymbol !== state.ceSymbol) {
                        ltpSymbols.push({ symbol: state.peSymbol, exchange: state.exchange });
                    }
                    if (ltpSymbols.length === 0 && state.symbol) {
                        ltpSymbols.push({ symbol: state.symbol, exchange: state.exchange });
                    }
                    // Subscribe to LTP for both sides
                    state.ws.send(JSON.stringify({
                        action: 'subscribe',
                        symbols: ltpSymbols,
                        mode: 'LTP'
                    }));
                    if (state.underlying && state.underlyingExchange && state.underlying !== state.symbol) {
                        state.ws.send(JSON.stringify({
                            action: 'subscribe',
                            symbols: [{
                                symbol: state.underlying,
                                exchange: state.underlyingExchange
                            }],
                            mode: 'LTP'
                        }));
                    }
                    if (depthState.enabled) {
                        subscribeDepth();
                    }
                }
                // Handle subscription confirmation
                else if (data.status === 'subscribed') {
                    debugLog('✅ Subscribed to', data.count, 'symbols');
                }
                else if (data.type === 'subscribe' && Array.isArray(data.subscriptions)) {
                    const depthSub = data.subscriptions.find(sub =>
                        (sub.mode === 'Depth' || sub.mode === 3) &&
                        sub.symbol === state.symbol
                    );
                    if (depthSub && depthSub.depth) {
                        depthState.level = parseInt(depthSub.depth, 10) || depthState.level;
                        if (depthUi.levelSelect) {
                            depthUi.levelSelect.value = String(depthState.level);
                        }
                        updateDepthHint();
                    }
                }
                // Handle market data
                else if (data.type === 'market_data' && (data.symbol === state.ceSymbol || data.symbol === state.peSymbol || data.symbol === state.symbol)) {
                    const side = getSideForSymbol(data.symbol) || state.activeSide;
                    if ((data.mode === 3 || data.data?.depth) && side === state.activeSide) {
                        handleDepthMessage(data);
                    }
                    if (data.data?.ltp != null) {
                        debugLog('📊 Market data (nested):', data.data);
                        handleMarketData(data.data, side);
                    } else if (data.ltp != null) {
                        debugLog('📊 Market data (flat):', data);
                        handleMarketData(data, side);
                    }
                }
                else if (data.type === 'market_data' && data.symbol === state.underlying) {
                    if (data.data?.ltp != null || data.ltp != null) {
                        handleUnderlyingData(data);
                    }
                }
                // Handle market data (format 2: flat ltp)
                else if ((data.symbol === state.ceSymbol || data.symbol === state.peSymbol || data.symbol === state.symbol) && data.ltp) {
                    debugLog('📊 Market data (flat):', data);
                    const side = getSideForSymbol(data.symbol) || state.activeSide;
                    handleMarketData(data, side);
                }
                else if (data.symbol === state.underlying && data.ltp) {
                    handleUnderlyingData(data);
                }
                else {
                    debugLog('⚠️ Unhandled message type:', data.type, data);
                }
            };

            state.ws.onclose = () => {
                console.log('Chart WebSocket closed, reconnecting in 5s...');
                updateDepthStatusUI();
                setTimeout(connectWebSocket, 5000);
            };

            state.ws.onerror = (error) => {
                console.error('Chart WebSocket error:', error);
            };
        }

        // ========== TECHNICAL INDICATORS ==========

        // Calculate EMA from candle closes
        function calculateEMA(candles, period) {
            if (candles.length < period) return [];
            const multiplier = 2 / (period + 1);
            const result = [];

            // Seed with SMA of first `period` candles
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += candles[i].close;
            }
            let ema = sum / period;
            result.push({ time: candles[period - 1].time, value: ema });

            // EMA for remaining candles
            for (let i = period; i < candles.length; i++) {
                ema = (candles[i].close - ema) * multiplier + ema;
                result.push({ time: candles[i].time, value: ema });
            }
            return result;
        }

        // Calculate Supertrend (ATR period=10, multiplier=3)
        function calculateSupertrend(candles, atrPeriod = 10, mult = 3) {
            if (candles.length < atrPeriod + 1) return [];

            // Calculate True Range
            const tr = [0]; // first TR = high - low
            tr[0] = candles[0].high - candles[0].low;
            for (let i = 1; i < candles.length; i++) {
                const hl = candles[i].high - candles[i].low;
                const hpc = Math.abs(candles[i].high - candles[i - 1].close);
                const lpc = Math.abs(candles[i].low - candles[i - 1].close);
                tr.push(Math.max(hl, hpc, lpc));
            }

            // Calculate ATR using RMA (Wilder's smoothing)
            let atr = 0;
            for (let i = 0; i < atrPeriod; i++) {
                atr += tr[i];
            }
            atr /= atrPeriod;

            const atrValues = new Array(atrPeriod - 1).fill(0);
            atrValues.push(atr);
            for (let i = atrPeriod; i < candles.length; i++) {
                atr = (atr * (atrPeriod - 1) + tr[i]) / atrPeriod;
                atrValues.push(atr);
            }

            // Calculate Supertrend
            const result = [];
            let upperBand = 0, lowerBand = 0;
            let prevUpperBand = 0, prevLowerBand = 0;
            let trend = 1; // 1 = up, -1 = down

            for (let i = atrPeriod - 1; i < candles.length; i++) {
                const hl2 = (candles[i].high + candles[i].low) / 2;
                const atrVal = atrValues[i];

                let basicUpper = hl2 + mult * atrVal;
                let basicLower = hl2 - mult * atrVal;

                // Carry forward bands
                upperBand = (basicUpper < prevUpperBand || candles[i - 1].close > prevUpperBand)
                    ? basicUpper : prevUpperBand;
                lowerBand = (basicLower > prevLowerBand || candles[i - 1].close < prevLowerBand)
                    ? basicLower : prevLowerBand;

                // Determine trend direction
                if (i === atrPeriod - 1) {
                    trend = candles[i].close > upperBand ? 1 : -1;
                } else {
                    if (trend === 1 && candles[i].close < lowerBand) {
                        trend = -1;
                    } else if (trend === -1 && candles[i].close > upperBand) {
                        trend = 1;
                    }
                }

                const stValue = trend === 1 ? lowerBand : upperBand;
                result.push({
                    time: candles[i].time,
                    value: stValue,
                    color: trend === 1 ? '#00ff88' : '#ff4560'
                });

                prevUpperBand = upperBand;
                prevLowerBand = lowerBand;
            }
            return result;
        }

        // Calculate session VWAP (typical price average, resets daily)
        function calculateVWAP(candles) {
            if (candles.length < 1) return [];
            const result = [];
            let cumTP = 0;
            let count = 0;
            let currentDay = null;

            for (let i = 0; i < candles.length; i++) {
                // Detect day change to reset VWAP
                const d = new Date(candles[i].time * 1000);
                const day = d.toDateString();
                if (day !== currentDay) {
                    cumTP = 0;
                    count = 0;
                    currentDay = day;
                }

                const tp = (candles[i].high + candles[i].low + candles[i].close) / 3;
                cumTP += tp;
                count++;
                result.push({ time: candles[i].time, value: cumTP / count });
            }
            return result;
        }

        // Calculate RSI (Wilder's smoothing)
        function calculateRSI(candles, period = 14) {
            if (candles.length < period + 1) return [];
            const result = [];
            let gains = 0;
            let losses = 0;
            for (let i = 1; i <= period; i++) {
                const change = candles[i].close - candles[i - 1].close;
                if (change >= 0) gains += change;
                else losses -= change;
            }
            let avgGain = gains / period;
            let avgLoss = losses / period;
            let rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
            let rsi = avgLoss === 0 ? 100 : 100 - (100 / (1 + rs));
            result.push({ time: candles[period].time, value: rsi });
            for (let i = period + 1; i < candles.length; i++) {
                const change = candles[i].close - candles[i - 1].close;
                const gain = Math.max(change, 0);
                const loss = Math.max(-change, 0);
                avgGain = ((avgGain * (period - 1)) + gain) / period;
                avgLoss = ((avgLoss * (period - 1)) + loss) / period;
                rs = avgLoss === 0 ? Infinity : avgGain / avgLoss;
                rsi = avgLoss === 0 ? 100 : 100 - (100 / (1 + rs));
                result.push({ time: candles[i].time, value: rsi });
            }
            return result;
        }

        // Calculate ADX + DI (returns last values)
        function calculateADX(candles, period = 14) {
            if (candles.length < period + 2) return null;
            const tr = [];
            const plusDM = [];
            const minusDM = [];
            for (let i = 1; i < candles.length; i++) {
                const highDiff = candles[i].high - candles[i - 1].high;
                const lowDiff = candles[i - 1].low - candles[i].low;
                plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
                minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
                const hl = candles[i].high - candles[i].low;
                const hpc = Math.abs(candles[i].high - candles[i - 1].close);
                const lpc = Math.abs(candles[i].low - candles[i - 1].close);
                tr.push(Math.max(hl, hpc, lpc));
            }
            let tr14 = tr.slice(0, period).reduce((a, b) => a + b, 0);
            let plusDM14 = plusDM.slice(0, period).reduce((a, b) => a + b, 0);
            let minusDM14 = minusDM.slice(0, period).reduce((a, b) => a + b, 0);
            if (!tr14) return null;
            let plusDI = 100 * (plusDM14 / tr14);
            let minusDI = 100 * (minusDM14 / tr14);
            let dx = (plusDI + minusDI === 0) ? 0 : (100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI));
            const dxList = [dx];
            let adx = null;
            for (let i = period; i < tr.length; i++) {
                tr14 = tr14 - (tr14 / period) + tr[i];
                plusDM14 = plusDM14 - (plusDM14 / period) + plusDM[i];
                minusDM14 = minusDM14 - (minusDM14 / period) + minusDM[i];
                if (!tr14) continue;
                plusDI = 100 * (plusDM14 / tr14);
                minusDI = 100 * (minusDM14 / tr14);
                dx = (plusDI + minusDI === 0) ? 0 : (100 * Math.abs(plusDI - minusDI) / (plusDI + minusDI));
                dxList.push(dx);
                if (dxList.length === period) {
                    adx = dxList.reduce((a, b) => a + b, 0) / period;
                } else if (dxList.length > period && adx !== null) {
                    adx = ((adx * (period - 1)) + dx) / period;
                }
            }
            return { adx, diPlus: plusDI, diMinus: minusDI };
        }

        // Recalculate and render all indicators
        function updateIndicators(ctx) {
            if (!ctx) return;
            const allCandles = [...ctx.candles];
            if (ctx.pendingCandle) {
                allCandles.push(ctx.pendingCandle);
            }
            if (allCandles.length < 2) return;

            const ema9Data = calculateEMA(allCandles, 9);
            if (ema9Data.length > 0) {
                ctx.ema9Series.setData(ema9Data);
                ctx.ema9Last = ema9Data[ema9Data.length - 1]?.value ?? ctx.ema9Last;
            }

            const ema21Data = calculateEMA(allCandles, 21);
            if (ema21Data.length > 0) {
                ctx.ema21Series.setData(ema21Data);
                ctx.ema21Last = ema21Data[ema21Data.length - 1]?.value ?? ctx.ema21Last;
            }

            const stData = calculateSupertrend(allCandles, 10, 3);
            if (stData.length > 0) ctx.supertrendSeries.setData(stData);

            const vwapData = calculateVWAP(allCandles);
            if (vwapData.length > 0) ctx.vwapSeries.setData(vwapData);
        }

        function scheduleIndicatorUpdate(ctx) {
            if (!ctx) return;
            const now = Date.now();
            if (now - ctx.lastIndicatorUpdate < PERF.indicatorThrottleMs) return;
            if (ctx.indicatorUpdateScheduled) return;
            ctx.indicatorUpdateScheduled = true;
            requestAnimationFrame(() => {
                ctx.indicatorUpdateScheduled = false;
                ctx.lastIndicatorUpdate = Date.now();
                updateIndicators(ctx);
            });
        }

        function updateIndexIndicators() {
            const allCandles = [...indexState.candles];
            if (indexState.pendingCandle) {
                allCandles.push(indexState.pendingCandle);
            }
            if (allCandles.length < 2) return;
            const ema9Data = calculateEMA(allCandles, 9);
            if (ema9Data.length > 0) {
                indexState.ema9Last = ema9Data[ema9Data.length - 1]?.value ?? indexState.ema9Last;
            }
            const ema21Data = calculateEMA(allCandles, 21);
            if (ema21Data.length > 0) {
                indexState.ema21Last = ema21Data[ema21Data.length - 1]?.value ?? indexState.ema21Last;
            }
            const stData = calculateSupertrend(allCandles, 10, 3);
            if (stData.length > 0) {
                indexState.supertrendLast = stData[stData.length - 1]?.value ?? indexState.supertrendLast;
            }
            const vwapData = calculateVWAP(allCandles);
            if (vwapData.length > 0) {
                indexState.vwapLast = vwapData[vwapData.length - 1]?.value ?? indexState.vwapLast;
            }
            const rsiData = calculateRSI(allCandles, 14);
            if (rsiData.length > 0) {
                indexState.rsiLast = rsiData[rsiData.length - 1]?.value ?? indexState.rsiLast;
            }
            const adxData = calculateADX(allCandles, 14);
            if (adxData) {
                indexState.adxLast = adxData.adx ?? indexState.adxLast;
                indexState.diPlusLast = adxData.diPlus ?? indexState.diPlusLast;
                indexState.diMinusLast = adxData.diMinus ?? indexState.diMinusLast;
            }
        }

        function scheduleIndexIndicatorUpdate() {
            const now = Date.now();
            if (now - indexState.lastIndicatorUpdate < PERF.indicatorThrottleMs) return;
            if (indexState.indicatorUpdateScheduled) return;
            indexState.indicatorUpdateScheduled = true;
            requestAnimationFrame(() => {
                indexState.indicatorUpdateScheduled = false;
                indexState.lastIndicatorUpdate = Date.now();
                updateIndexIndicators();
            });
        }

        function updateIndexCandles(price) {
            if (!Number.isFinite(price)) return;
            const now = Math.floor(Date.now() / 1000);
            const candleTime = Math.floor(now / CONFIG.candleInterval) * CONFIG.candleInterval;
            if (!indexState.pendingCandle || indexState.pendingCandle.time !== candleTime) {
                if (indexState.pendingCandle) {
                    indexState.candles.push({ ...indexState.pendingCandle });
                    if (indexState.candles.length > 240) {
                        indexState.candles.shift();
                    }
                }
                indexState.pendingCandle = {
                    time: candleTime,
                    open: price,
                    high: price,
                    low: price,
                    close: price
                };
            } else {
                indexState.pendingCandle.high = Math.max(indexState.pendingCandle.high, price);
                indexState.pendingCandle.low = Math.min(indexState.pendingCandle.low, price);
                indexState.pendingCandle.close = price;
            }
        }

        let pnlUpdateScheduled = false;

        function scheduleLivePnLUpdate() {
            if (pnlUpdateScheduled) return;
            pnlUpdateScheduled = true;
            requestAnimationFrame(() => {
                pnlUpdateScheduled = false;
                updateLivePNL();
            });
        }

        // ========== END TECHNICAL INDICATORS ==========

        function handleUnderlyingData(data) {
            const raw = data.ltp ?? data.data?.ltp;
            const ltp = parseFloat(raw);
            if (!Number.isFinite(ltp) || ltp <= 0) {
                return;
            }
            const ts = data.data?.timestamp || data.timestamp || Date.now();
            updateUnderlyingMetrics(ltp, ts);
            indexState.lastPrice = ltp;
            updateIndexCandles(ltp);
            scheduleIndexIndicatorUpdate();
            handleAutoUnderlyingTick(ltp);
        }

        // Handle incoming market data and build candles
        function handleMarketData(data, side) {
            const ltp = parseFloat(data.ltp);
            if (!Number.isFinite(ltp) || ltp <= 0) {
                debugWarn('⚠️ No LTP in market data:', data);
                return;
            }

            const resolvedSide = side || state.activeSide;
            const ctx = getContextForSide(resolvedSide);
            if (!ctx) return;

            debugLog(`💹 Price tick: ${ltp} for ${ctx.symbol}`);
            if (resolvedSide === state.activeSide) {
                updatePriceTimestamp();
            }

            // Update price display for active side only
            const prevPrice = ctx.currentPrice;
            ctx.currentPrice = ltp;
            if (resolvedSide === state.activeSide) {
                const prevActive = state.currentPrice;
                state.currentPrice = ltp;
                if (ui.currentPrice && prevActive !== ltp) {
                    const valueEl = ensureCurrentPriceValue();
                    if (valueEl) {
                        valueEl.textContent = `₹${ltp.toFixed(2)}`;
                    }
                    ui.currentPrice.className = 'current-price price-positive';
                }
                updateGreeksProxy(ltp, data.timestamp || Date.now());
            }

            const now = Math.floor(Date.now() / 1000);
            const candleTime = Math.floor(now / CONFIG.candleInterval) * CONFIG.candleInterval;

            if (!ctx.pendingCandle || ctx.pendingCandle.time !== candleTime) {
                // New candle period - save old one if exists
                if (ctx.pendingCandle) {
                    debugLog('📊 Updating candle:', ctx.pendingCandle);
                    ctx.series.update(ctx.pendingCandle);
                    // Store completed candle for indicator calculations
                    ctx.candles.push({ ...ctx.pendingCandle });
                } else {
                    // First real candle - clear dummy data
                    debugLog('🧹 Clearing dummy candle data');
                    ctx.series.setData([]);
                }

                // Start new candle
                ctx.pendingCandle = {
                    time: candleTime,
                    open: ltp,
                    high: ltp,
                    low: ltp,
                    close: ltp
                };
                // Render the new candle immediately (handles single-tick after hours)
                ctx.series.update(ctx.pendingCandle);
                debugLog('🕯️ New candle started:', ctx.pendingCandle);
            } else {
                // Update current candle
                ctx.pendingCandle.high = Math.max(ctx.pendingCandle.high, ltp);
                ctx.pendingCandle.low = Math.min(ctx.pendingCandle.low, ltp);
                ctx.pendingCandle.close = ltp;

                // Update chart
                ctx.series.update(ctx.pendingCandle);
            }

            // Update indicators with latest candle data
            scheduleIndicatorUpdate(ctx);

            // Update live P&L
            scheduleLivePnLUpdate();

            // Check if price crossed virtual TP/SL levels
            checkVirtualTPSL(resolvedSide);

            // Check if price crossed any fake limit trigger levels
            checkFakeLimitTriggers();

            // Auto trade engine tick
            handleAutoTradeTick(resolvedSide, ltp);
        }

        // ========== VIRTUAL TP/SL PRICE MONITORING ==========

        // Check if current price has crossed TP or SL levels
        function checkVirtualTPSL(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position || state.isClosingPosition) return;

            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return;

            const ctx = getContextForSide(side);
            const price = ctx?.currentPrice || 0;
            if (!price || price <= 0) return;
            const isLong = qty > 0;

            // Check TP hit (skip when auto trailing overrides TP)
            const skipTP = posState.position?.auto && autoState.trailingEnabled && autoState.trailingOverrideTP;
            if (!skipTP && posState.positionTPSL.tpPrice !== null) {
                if ((isLong && price >= posState.positionTPSL.tpPrice) || (!isLong && price <= posState.positionTPSL.tpPrice)) {
                    console.log(`🎯 TP HIT: price ${price} crossed TP ${posState.positionTPSL.tpPrice}`);
                    executeVirtualTPSL('TP', posState.positionTPSL.tpPrice, side);
                    return;
                }
            }

            // Check SL hit
            if (posState.positionTPSL.slPrice !== null) {
                if ((isLong && price <= posState.positionTPSL.slPrice) || (!isLong && price >= posState.positionTPSL.slPrice)) {
                    console.log(`🛑 SL HIT: price ${price} crossed SL ${posState.positionTPSL.slPrice}`);
                    const slReason = posState.position?.auto && posState.positionTPSL?.slTrail ? 'Trail SL' : null;
                    executeVirtualTPSL('SL', posState.positionTPSL.slPrice, side, slReason);
                    return;
                }
            }
        }

        // Execute virtual TP/SL by placing a MARKET close order
        async function executeVirtualTPSL(type, triggerPrice, sideOverride = null, reasonOverride = null) {
            if (state.isClosingPosition) return;
            state.isClosingPosition = true;

            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const qty = parseInt(posState.position?.quantity) || 0;
            const action = qty > 0 ? 'SELL' : 'BUY';
            const absQty = Math.abs(qty);
            const symbol = getContextForSide(side)?.symbol || state.symbol;
            const entryPrice = posState.entryPrice || parseFloat(posState.position?.average_price) || 0;
            const isAuto = !!posState.position?.auto;
            const isPaper = !!posState.position?.paper;

            const displayType = reasonOverride || type;
            showToast(`${displayType} triggered at ₹${triggerPrice.toFixed(2)} - closing position`, type === 'TP' ? 'success' : 'error');
            console.log(`Executing virtual ${type}: ${action} ${absQty} of ${symbol} at MARKET`);

            // Clear TP/SL visuals immediately
            cancelTPSLOrders(side);

            if (isAuto && isPaper) {
                recordAutoExit(side, triggerPrice, reasonOverride || type);
                autoState.paperPositions[side] = null;
                clearPositionVisuals(side);
                resetProfitProtection();
                state.isClosingPosition = false;
                return;
            }

            try {
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_tpsl',
                    exchange: state.exchange,
                    symbol: symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`${type} executed - position closed`, 'success');
                    if (isAuto) {
                        recordAutoExit(side, triggerPrice, reasonOverride || type, { skipLog: true, skipRealized: true });
                        setTimeout(() => {
                            logLiveExitWithFill({
                                side,
                                symbol,
                                action,
                                qty: absQty,
                                entryPrice,
                                reason: reasonOverride || type,
                                fallbackPrice: triggerPrice
                            });
                        }, 600);
                    }
                    clearPositionVisuals(side);
                    resetProfitProtection();
                } else {
                    showToast(`${type} close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error(`Error executing virtual ${type}:`, error);
                showToast(`${type} execution error: ${error.message}`, 'error');
            } finally {
                setTimeout(() => {
                    state.isClosingPosition = false;
                    fetchAndDisplayPosition(null, symbol, side);
                }, 2000);
            }
        }

        // ========== OPEN ORDERS PANEL ==========

        let openOrdersData = [];

        // Toggle orders panel collapse
        function toggleOrdersPanel() {
            const panel = document.getElementById('ordersPanel');
            const toggle = document.getElementById('ordersToggle');

            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                panel.classList.add('collapsed');
                toggle.textContent = '▲';
            }
        }

        // Fetch all open orders from API
        async function fetchOpenOrders() {
            if (isFetchingOrders) return; // Skip if already fetching

            isFetchingOrders = true;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 sec timeout

                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success' && result.data && result.data.orders) {
                    const allOrders = result.data.orders;

                    // Filter only open/pending orders
                    openOrdersData = allOrders.filter(order => {
                        const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();
                        return status === 'OPEN' ||
                            status === 'PENDING' ||
                            status === 'TRIGGER PENDING' ||
                            status === 'PENDING ORDER' ||
                            status === 'NOT EXECUTED';
                    });

                    renderOpenOrders();
                } else if (result.status === 'error') {
                    // Silently log server errors to avoid console spam
                    if (!result.message.includes('WinError')) {
                        console.error('Orderbook error:', result.message);
                    }
                }
            } catch (error) {
                // Silently handle timeout and connection errors
                if (error.name !== 'AbortError') {
                    console.error('Error fetching orders:', error.message);
                }
            } finally {
                isFetchingOrders = false;
            }
        }

        // Render open orders in the panel
        function renderOpenOrders() {
            const ordersList = document.getElementById('ordersList');
            const ordersCount = document.getElementById('ordersCount');

            ordersCount.textContent = openOrdersData.length;

            if (openOrdersData.length === 0) {
                ordersList.innerHTML = '<div class="orders-empty">No open orders</div>';
                return;
            }

            ordersList.innerHTML = openOrdersData.map(order => {
                const action = order.action || 'N/A';
                const actionClass = action.toUpperCase() === 'BUY' ? 'order-action-buy' : 'order-action-sell';
                const symbol = order.symbol || 'N/A';
                const price = order.price ? `₹${parseFloat(order.price).toFixed(2)}` : 'MARKET';
                const qty = order.quantity || 0;
                const orderType = order.order_type || order.pricetype || 'N/A';
                const orderId = order.orderid || order.order_id || '';

                return `
                    <div class="order-item">
                        <div class="order-info">
                            <div class="order-symbol">${symbol}</div>
                            <div class="order-details">
                                <span class="${actionClass}">${action}</span>
                                <span>${orderType}</span>
                                <span>${price}</span>
                                <span>Qty: ${qty}</span>
                            </div>
                        </div>
                        <div class="order-close-icon" onclick="cancelSingleOrder('${orderId}', '${symbol}')" title="Cancel order">✕</div>
                    </div>
                `;
            }).join('');
        }

        // Cancel a single order
        async function cancelSingleOrder(orderId, symbol) {
            if (!orderId) {
                showToast('Invalid order ID', 'error');
                return;
            }

            try {
                showToast('Cancelling order...', 'info');

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 sec timeout

                const response = await fetch('/api/v1/cancelorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        apikey: state.apiKey,
                        strategy: 'chart_trading',
                        orderid: orderId
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`✅ Order cancelled: ${symbol}`, 'success');

                    // Remove visual chart line if it exists
                    removeOrderLineFromChart(orderId);
                    if (autoState.pendingOrders.has(orderId)) {
                        autoState.pendingOrders.delete(orderId);
                    }

                    // Refresh orders list
                    setTimeout(() => fetchOpenOrders(), 500);
                } else {
                    showToast(`❌ Cancel failed: ${result.message}`, 'error');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    showToast('❌ Cancel timeout - server slow', 'error');
                } else {
                    console.error('Error cancelling order:', error);
                    showToast(`❌ Error: ${error.message}`, 'error');
                }
            }
        }

        // Remove order line from chart
        function removeOrderLineFromChart(orderId, preserveTPSL = false) {
            const order = state.orders.get(orderId);
            if (autoState.pendingOrders.has(orderId)) {
                autoState.pendingOrders.delete(orderId);
            }
            if (order) {
                const ctx = order.ctx || getContextForSide(order.side) || getContextForSide(state.activeSide);
                // Save TP/SL data if preserving (for order fills)
                let savedTPSL = null;
                if (preserveTPSL && (order.tpOrder || order.slOrder)) {
                    savedTPSL = {
                        tpOrder: order.tpOrder ? { price: order.tpOrder.price, priceLine: order.tpOrder.priceLine || null } : null,
                        slOrder: order.slOrder ? { price: order.slOrder.price, priceLine: order.slOrder.priceLine || null } : null,
                        action: order.action,
                        tpPoints: order.tpPoints,
                        slPoints: order.slPoints,
                        tpAuto: order.tpAuto !== false,
                        slAuto: order.slAuto !== false
                    };
                }

                // Remove price line
                if (order.priceLine) {
                    ctx?.series?.removePriceLine(order.priceLine);
                }
                // Remove overlay
                if (order.overlay) {
                    order.overlay.remove();
                }
                // Remove TP/SL lines if they exist
                if (!preserveTPSL) {
                    if (order.tpOrder?.priceLine) {
                        ctx?.series?.removePriceLine(order.tpOrder.priceLine);
                    }
                    if (order.slOrder?.priceLine) {
                        ctx?.series?.removePriceLine(order.slOrder.priceLine);
                    }
                }
                if (order.tpOrder?.overlay) {
                    order.tpOrder.overlay.remove();
                }
                if (order.slOrder?.overlay) {
                    order.slOrder.overlay.remove();
                }
                // Remove from map
                state.orders.delete(orderId);
                console.log(`🗑️ Removed order line from chart: ${orderId}`);

                return savedTPSL;
            }
            return null;
        }

        // Close all open orders
        async function closeAllOpenOrders() {
            // Also cancel all fake limit trigger orders
            for (const [id] of [...state.fakeLimitOrders]) {
                cancelFakeLimitOrder(id);
            }

            if (openOrdersData.length === 0) {
                showToast('No orders to cancel', 'info');
                return;
            }

            showToast(`Cancelling ${openOrdersData.length} orders...`, 'info');

            let successCount = 0;
            let failCount = 0;

            for (const order of openOrdersData) {
                try {
                    const response = await fetch('/api/v1/cancelorder', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            apikey: state.apiKey,
                            strategy: 'chart_trading',
                            orderid: order.orderid || order.order_id
                        })
                    });

                    const result = await response.json();
                    if (result.status === 'success') {
                        successCount++;
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    console.error('Error cancelling order:', error);
                    failCount++;
                }

                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            showToast(`✅ ${successCount} cancelled, ${failCount} failed`, successCount > 0 ? 'success' : 'error');

            // Remove all visual chart lines for cancelled orders
            for (const order of openOrdersData) {
                removeOrderLineFromChart(order.orderid || order.order_id);
            }

            // Refresh orders list
            setTimeout(() => fetchOpenOrders(), 1000);
        }

        // Track if requests are pending to avoid overlapping calls
        let isFetchingOrders = false;
        let isCheckingFills = false;

        // Auto-refresh orders every 5 seconds and check for fills
        setInterval(() => {
            if (!isFetchingOrders) {
                fetchOpenOrders();
            }
            if (!isCheckingFills) {
                checkOrderFills();
            }
        }, 5000); // Increased to 5 seconds to reduce server load

        function normalizeTPSLForFill(tpslData, action, fillPrice, tpPoints, slPoints) {
            if (!tpslData || !action || !Number.isFinite(fillPrice) || fillPrice <= 0) return tpslData;
            const { tpPrice, slPrice } = computeTPSLPrices(fillPrice, action, tpPoints, slPoints);
            const tpAuto = tpslData.tpAuto !== false;
            const slAuto = tpslData.slAuto !== false;

            if (!tpslData.tpOrder) tpslData.tpOrder = {};
            if (tpAuto) {
                tpslData.tpOrder.price = tpPrice;
                if (tpslData.tpOrder.priceLine) {
                    tpslData.tpOrder.priceLine.applyOptions({
                        price: tpPrice,
                        title: `TP @ ${tpPrice.toFixed(2)}`
                    });
                }
            }

            if (!tpslData.slOrder) tpslData.slOrder = {};
            if (slAuto) {
                tpslData.slOrder.price = slPrice;
                if (tpslData.slOrder.priceLine) {
                    tpslData.slOrder.priceLine.applyOptions({
                        price: slPrice,
                        title: `SL @ ${slPrice.toFixed(2)}`
                    });
                }
            }

            tpslData.action = action;
            tpslData.tpPoints = tpPoints;
            tpslData.slPoints = slPoints;
            tpslData.tpAuto = tpAuto;
            tpslData.slAuto = slAuto;
            return tpslData;
        }

        // Check if any pending orders were filled or cancelled
        async function checkOrderFills() {
            if (isCheckingFills) return; // Skip if already checking

            // Get all orderIds we're tracking (pending orders on chart)
            const trackedOrderIds = Array.from(state.orders.keys());

            if (trackedOrderIds.length === 0) return;

            isCheckingFills = true;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch('/api/v1/orderbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const result = await response.json();

                if (result.status === 'success' && result.data && result.data.orders) {
                    let foundFill = false;
                    const fillsBySide = new Map();

                    for (const orderId of trackedOrderIds) {
                        const order = result.data.orders.find(o => (o.orderid || o.order_id) === orderId);
                        if (order) {
                            const status = (order.status || order.order_status || order.orderstatus || '').toUpperCase();

                            // Check if order was cancelled/rejected externally
                            if (status === 'CANCELLED' || status === 'CANCELED' || status === 'REJECTED' || status === 'REJECTED ORDER') {
                                console.log(`🔴 Order cancelled externally: ${orderId} - ${status}`);
                                showToast('Order cancelled from mobile/external', 'info');
                                removeOrderLineFromChart(orderId, false);
                                foundFill = true;
                            }
                            // If order is complete/executed, remove the pending line and fetch position
                            else if (status === 'COMPLETE' || status === 'EXECUTED' || status === 'FILLED' || status === 'TRADED') {
                                console.log(`✅ Order filled: ${orderId} - ${status}`);

                                // Get the filled order details to calculate auto TP/SL
                                const orderState = state.orders.get(orderId);
                                const side = orderState?.side || getSideForSymbol(order.symbol) || state.activeSide;
                                let fillPrice = parseFloat(order.average_price || order.price || orderState?.price || 0);
                                const action = order.action || orderState?.action;
                                if (!fillPrice || fillPrice <= 0) {
                                    const fill = await fetchLatestTradeFill(order.symbol || orderState?.symbol, action);
                                    if (fill?.price) {
                                        fillPrice = fill.price;
                                    }
                                }
                                const tpPoints = Number.isFinite(orderState?.tpPoints) ? orderState.tpPoints : state.tpPoints;
                                const slPoints = Number.isFinite(orderState?.slPoints) ? orderState.slPoints : state.slPoints;
                                const autoMeta = autoState.pendingOrders.get(orderId);
                                if (autoMeta) {
                                    autoState.pendingOrders.delete(orderId);
                                    autoState.pendingPositionTag[side] = {
                                        ...autoMeta,
                                        entryPrice: fillPrice || autoMeta.entryPrice || 0,
                                        action: action,
                                        symbol: order.symbol || autoMeta.symbol,
                                        ts: Date.now()
                                    };
                                    const entryQty = Math.round((autoMeta.lots || 1) * (state.lotSize || 1));
                                    logAutoTrade({
                                        type: 'ENTRY',
                                        mode: 'LIVE',
                                        side,
                                        symbol: order.symbol || autoMeta.symbol,
                                        action: action || 'BUY',
                                        qty: entryQty,
                                        price: fillPrice || autoMeta.entryPrice || 0,
                                        tpPoints: Number.isFinite(autoMeta.tpPoints) ? autoMeta.tpPoints : tpPoints,
                                        slPoints: Number.isFinite(autoMeta.slPoints) ? autoMeta.slPoints : slPoints,
                                        reason: autoMeta.reason || 'Momentum',
                                        entryReason: autoMeta.reason || 'Auto momentum',
                                        tradeId: autoState.activeTradeId?.[side] || null,
                                        // Preset info (captured at decision time)
                                        preset: autoMeta.preset || autoState.presetKey || 'custom',
                                        presetLabel: autoMeta.presetLabel || (AUTO_PRESETS[autoState.presetKey]?.label || 'Custom'),
                                        adaptivePreset: autoMeta.adaptivePreset || null,
                                        adaptivePresetLabel: autoMeta.adaptivePresetLabel || null,
                                        // Use values captured at decision time (from autoMeta), not current state
                                        regime: autoMeta.regime || autoState.currentRegime || 'UNKNOWN',
                                        regimeMode: autoMeta.regimeMode || autoState.regimeTradingMode || 'all',
                                        momentumTicks: autoMeta.momentumTicks || autoState.momentumTicks,
                                        momentumCount: autoMeta.momentumCount || 0,
                                        momentumThreshold: autoMeta.momentumThreshold || getAutoMomentumThreshold(),
                                        momentumVelocity: autoMeta.momentumVelocity ? parseFloat(autoMeta.momentumVelocity.toFixed(2)) : 0,
                                        noTradeZoneActive: autoMeta.noTradeZoneActive,
                                        underlyingFilterOk: autoMeta.underlyingFilterOk,
                                        candleConfirmOk: autoMeta.candleConfirmOk,
                                        relativeStrengthOk: autoMeta.relativeStrengthOk,
                                        consecutiveLosses: autoState.consecutiveLosses || 0,
                                        winStreak: autoState.winStreak || 0,
                                        sessionPnl: parseFloat((autoState.realizedPnl || 0).toFixed(0)),
                                        tradeNumber: (autoState.tradeHistory?.length || 0) + 1,
                                        isReEntry: autoMeta.reason === 'Re-entry'
                                    });
                                    if (fillPrice) {
                                        updateLiveEntryFill(side, entryQty, fillPrice);
                                    }
                                    if (fillPrice) {
                                        autoState.trailingAnchor[side] = fillPrice;
                                    }
                                }

                                let tpslData = removeOrderLineFromChart(orderId, true);
                                if (fillPrice > 0 && action) {
                                    if (tpslData) {
                                        tpslData = normalizeTPSLForFill(tpslData, action, fillPrice, tpPoints, slPoints);
                                    } else {
                                        const { tpPrice, slPrice } = computeTPSLPrices(fillPrice, action, tpPoints, slPoints);
                                        tpslData = {
                                            tpOrder: { price: tpPrice },
                                            slOrder: { price: slPrice },
                                            action: action,
                                            tpPoints: tpPoints,
                                            slPoints: slPoints
                                        };
                                    }
                                    console.log(`📊 Auto TP/SL calculated: TP=${tpslData.tpOrder?.price?.toFixed(2)}, SL=${tpslData.slOrder?.price?.toFixed(2)}`);
                                }

                                if (side) {
                                    fillsBySide.set(side, tpslData || fillsBySide.get(side) || null);
                                }

                                foundFill = true;
                            }
                        } else {
                            // Order not in orderbook - likely filled or cancelled externally
                            console.log(`⚠️ Order ${orderId} not in orderbook - removing line`);
                            const orderState = state.orders.get(orderId);
                            const side = orderState?.side || getSideForSymbol(orderState?.symbol) || state.activeSide;

                            if (orderState?.autoTag) {
                                let fillPrice = orderState.price || 0;
                                if (!fillPrice || fillPrice <= 0) {
                                    const fill = await fetchLatestTradeFill(orderState.symbol, orderState.action);
                                    if (fill?.price) {
                                        fillPrice = fill.price;
                                    }
                                }
                                autoState.pendingPositionTag[side] = {
                                    side,
                                    symbol: orderState.symbol,
                                    lots: orderState.lots || state.quantity,
                                    entryPrice: fillPrice || 0,
                                    action: orderState.action,
                                    ts: Date.now()
                                };
                                const autoMeta = autoState.pendingOrders.get(orderId);
                                if (autoMeta) {
                                    autoState.pendingOrders.delete(orderId);
                                    const entryQty = Math.round((autoMeta.lots || 1) * (state.lotSize || 1));
                                    logAutoTrade({
                                        type: 'ENTRY',
                                        mode: 'LIVE',
                                        side,
                                        symbol: orderState.symbol || autoMeta.symbol,
                                        action: orderState.action || 'BUY',
                                        qty: entryQty,
                                        price: fillPrice || autoMeta.entryPrice || 0,
                                        tpPoints: Number.isFinite(autoMeta.tpPoints) ? autoMeta.tpPoints : state.tpPoints,
                                        slPoints: Number.isFinite(autoMeta.slPoints) ? autoMeta.slPoints : state.slPoints,
                                        reason: autoMeta.reason || 'Momentum'
                                    });
                                    if (fillPrice) {
                                        updateLiveEntryFill(side, entryQty, fillPrice);
                                    }
                                }
                                if (fillPrice) {
                                    autoState.trailingAnchor[side] = fillPrice;
                                }
                            }

                            // Try to calculate auto TP/SL even for externally filled orders
                            if (orderState && orderState.action) {
                                let fillPrice = orderState.price || 0;
                                if (!fillPrice || fillPrice <= 0) {
                                    const fill = await fetchLatestTradeFill(orderState.symbol, orderState.action);
                                    if (fill?.price) {
                                        fillPrice = fill.price;
                                    }
                                }
                                if (!fillPrice || fillPrice <= 0) {
                                    removeOrderLineFromChart(orderId, false);
                                    foundFill = true;
                                    continue;
                                }
                                const action = orderState.action;
                                const tpPoints = Number.isFinite(orderState.tpPoints) ? orderState.tpPoints : state.tpPoints;
                                const slPoints = Number.isFinite(orderState.slPoints) ? orderState.slPoints : state.slPoints;
                                const tpslData = normalizeTPSLForFill({
                                    tpOrder: { price: orderState.tpOrder?.price || 0, priceLine: orderState.tpOrder?.priceLine || null },
                                    slOrder: { price: orderState.slOrder?.price || 0, priceLine: orderState.slOrder?.priceLine || null },
                                    action: action,
                                    tpPoints: tpPoints,
                                    slPoints: slPoints,
                                    tpAuto: orderState.tpAuto !== false,
                                    slAuto: orderState.slAuto !== false
                                }, action, fillPrice, tpPoints, slPoints);
                                if (side) {
                                    fillsBySide.set(side, tpslData || fillsBySide.get(side) || null);
                                }
                            }

                            removeOrderLineFromChart(orderId, false);
                            foundFill = true;
                        }
                    }

                    // If any fills detected, refresh position with TP/SL data
                    if (foundFill) {
                        if (fillsBySide.size === 0) {
                            setTimeout(() => fetchAndDisplayPosition(null, state.symbol, state.activeSide), 300);
                        } else {
                            fillsBySide.forEach((tpslData, side) => {
                                const symbol = getContextForSide(side)?.symbol || state.symbol;
                                setTimeout(() => fetchAndDisplayPosition(tpslData, symbol, side), 300);
                            });
                        }
                    }
                }
            } catch (error) {
                // Silently handle timeout and connection errors
                if (error.name !== 'AbortError') {
                    console.error('Error checking fills:', error.message);
                }
            } finally {
                isCheckingFills = false;
            }
        }

        // Fetch current position and display
        async function fetchAndDisplayPosition(tpslData = null, symbolOverride = null, sideOverride = null) {
            try {
                const symbol = symbolOverride || state.symbol;
                const side = sideOverride || state.activeSide;
                console.log('📍 Fetching position for symbol:', symbol);
                const posState = getPositionState(side);
                if (autoState.paperMode || posState.position?.paper) {
                    return;
                }

                const response = await fetch('/api/v1/positionbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });

                const result = await response.json();
                console.log('📍 Position API response:', result);

                if (result.status === 'success' && result.data) {
                    console.log('📍 Total positions:', result.data.length);

                    // Find position for current symbol
                    const position = result.data.find(p => p.symbol === symbol);
                    if (position) {
                        console.log('📍 Found position for', symbol, ':', position);
                        const qty = parseInt(position.quantity) || 0;
                        if (qty !== 0) {
                            console.log('📍 Position has quantity:', qty, '- displaying');
                            updatePositionDisplay(position, tpslData, side);
                        } else {
                            console.log('📍 Position quantity is 0 - not displaying');
                        }
                    } else {
                        console.log('📍 No position found for', symbol);
                        clearPositionVisuals(side);
                    }
                }
            } catch (error) {
                console.error('Error fetching position:', error);
            }
        }

        // Update position display with live data
        function updatePositionDisplay(position, tpslData = null, sideOverride = null) {
            const side = sideOverride || getSideForSymbol(position.symbol) || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            const qty = parseInt(position.quantity) || 0;
            const wasAuto = posState.position?.auto;

            if (qty === 0) {
                if (posState.position?.auto) {
                    autoState.avgSession[side] = null;
                    autoState.trailingAnchor[side] = null;
                    autoState.pendingPositionTag[side] = null;
                }
                clearPositionVisuals(side);
                console.log('📍 Position closed - line removed');
                return;
            }

            posState.position = position;
            posState.entryPrice = parseFloat(position.average_price) || 0;
            posState.positionTPSL.slTrail = false;

            const pendingTag = autoState.pendingPositionTag[side];
            if (pendingTag && (!pendingTag.symbol || pendingTag.symbol === position.symbol)) {
                posState.position.auto = true;
                posState.position.paper = false;
                if (pendingTag.entryPrice) {
                    posState.entryPrice = pendingTag.entryPrice;
                }
                if (pendingTag.entryPrice && pendingTag.lots) {
                    const entryQty = Math.round((pendingTag.lots || 1) * (state.lotSize || 1));
                    updateLiveEntryFill(side, entryQty, pendingTag.entryPrice);
                }
                autoState.pendingPositionTag[side] = null;
            } else if (wasAuto) {
                posState.position.auto = true;
            }

            if (side === state.activeSide) {
                state.position = position;
                state.entryPrice = posState.entryPrice;
                document.getElementById('positionQty').textContent = `${qty > 0 ? '+' : ''}${qty}`;
                document.getElementById('entryPrice').textContent = `₹${state.entryPrice.toFixed(2)}`;
                document.getElementById('btnClosePosition').classList.remove('hidden');
            }

            // Draw position line on the correct chart
            drawPositionLine(posState.entryPrice, qty > 0 ? 'BUY' : 'SELL', tpslData, side);

            // Update P&L for active side
            if (side === state.activeSide && ctx?.currentPrice > 0) {
                const pnl = (ctx.currentPrice - posState.entryPrice) * qty;
                const pnlEl = document.getElementById('pnlValue');
                pnlEl.textContent = `₹${pnl.toFixed(2)}`;
                pnlEl.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;
            }
        }

        // Draw position line (entry price) with live P&L
        function drawPositionLine(entryPrice, action, tpslData = null, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            if (!ctx?.series) return;

            // Remove existing position line if any
            if (posState.positionLine) {
                ctx.series.removePriceLine(posState.positionLine);
            }
            if (posState.positionOverlay) {
                posState.positionOverlay.remove();
            }

            // Create price line
            const color = action === 'BUY' ? '#00ff88' : '#ff4560';
            posState.positionLine = ctx.series.createPriceLine({
                price: entryPrice,
                color: color,
                lineWidth: 2,
                lineStyle: 1, // Dashed for position
                axisLabelVisible: true,
                title: ''
            });

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.style.cursor = 'default'; // Not draggable

            // Close button
            const closeBtn = document.createElement('div');
            closeBtn.className = 'order-close-btn';
            closeBtn.textContent = '✕';
            closeBtn.title = 'Close position';
            closeBtn.style.pointerEvents = 'auto';
            closeBtn.style.marginRight = '8px';
            closeBtn.style.flexShrink = '0';
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closePosition(side);
            });
            overlay.appendChild(closeBtn);

            // Position label
            const label = document.createElement('div');
            label.className = `order-line-label ${action.toLowerCase()}`;
            label.textContent = `${action} @ ₹${entryPrice.toFixed(2)}`;
            overlay.appendChild(label);

            // Live P&L label (always visible)
            const pnlLabel = document.createElement('div');
            pnlLabel.className = 'pnl-label';
            pnlLabel.id = `positionPnlLabel_${side}`;
            pnlLabel.style.marginLeft = 'auto';
            pnlLabel.textContent = '₹0.00';
            overlay.appendChild(pnlLabel);

            const overlayRoot = ctx.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, entryPrice, ctx);
            posState.positionOverlay = overlay;

            // Create or reuse TP/SL lines if data was provided
            if (tpslData) {
                console.log('📍 Creating auto TP/SL lines:', tpslData);

                if (tpslData.tpOrder) {
                    const tpPrice = tpslData.tpOrder.price;
                    posState.positionTPSL.tpPrice = tpPrice;
                    if (!posState.positionTPSL.tpLine) {
                        posState.positionTPSL.tpLine = tpslData.tpOrder.priceLine || ctx.series.createPriceLine({
                            price: tpPrice,
                            color: '#00ff88',
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            axisLabelVisible: true,
                            title: `TP @ ${tpPrice.toFixed(2)}`
                        });
                    }
                    posState.positionTPSL.tpLine.applyOptions({ price: tpPrice, title: `TP @ ${tpPrice.toFixed(2)}` });
                    if (!posState.positionTPSL.tpOverlay) {
                        posState.positionTPSL.tpOverlay = createTPSLOverlay(tpPrice, 'TP', action, side);
                    } else {
                        updateOverlayPosition(posState.positionTPSL.tpOverlay, tpPrice, ctx);
                    }
                }

                if (tpslData.slOrder) {
                    const slPrice = tpslData.slOrder.price;
                    posState.positionTPSL.slPrice = slPrice;
                    if (!posState.positionTPSL.slLine) {
                        posState.positionTPSL.slLine = tpslData.slOrder.priceLine || ctx.series.createPriceLine({
                            price: slPrice,
                            color: '#ff4560',
                            lineWidth: 1,
                            lineStyle: 2, // Dashed
                            axisLabelVisible: true,
                            title: `SL @ ${slPrice.toFixed(2)}`
                        });
                    }
                    posState.positionTPSL.slLine.applyOptions({ price: slPrice, title: `SL @ ${slPrice.toFixed(2)}` });
                    if (!posState.positionTPSL.slOverlay) {
                        posState.positionTPSL.slOverlay = createTPSLOverlay(slPrice, 'SL', action, side);
                    } else {
                        updateOverlayPosition(posState.positionTPSL.slOverlay, slPrice, ctx);
                    }
                }
            }

            console.log('📍 Position line drawn at ₹' + entryPrice);
        }

        // Create draggable TP/SL overlay for position
        function createTPSLOverlay(price, type, parentAction, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const ctx = getContextForSide(side);
            const overlay = document.createElement('div');
            overlay.className = 'order-line-overlay';
            overlay.style.cursor = 'ns-resize'; // Draggable cursor
            overlay.dataset.tpslType = type;

            // Label
            const label = document.createElement('div');
            label.className = `order-line-label ${type === 'TP' ? 'buy' : 'sell'}`;
            label.textContent = `${type} @ ₹${price.toFixed(2)}`;
            overlay.appendChild(label);

            // Cancel button
            const cancelBtn = document.createElement('div');
            cancelBtn.className = 'order-close-btn';
            cancelBtn.textContent = '✕';
            cancelBtn.title = `Remove ${type}`;
            cancelBtn.style.pointerEvents = 'auto';
            cancelBtn.style.marginLeft = '8px';
            cancelBtn.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
            });
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                removePositionTPSL(type, side);
            });
            overlay.appendChild(cancelBtn);

            const overlayRoot = ctx?.overlayRoot || document.getElementById('chart-container');
            overlayRoot.appendChild(overlay);
            updateOverlayPosition(overlay, price, ctx);

            // Make draggable
            setupTPSLDraggable(overlay, type, parentAction, side);

            return overlay;
        }

        // Setup draggable for TP/SL on position
        function setupTPSLDraggable(overlay, type, parentAction, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);
            if (!ctx?.series) return;
            let startY, startPrice;

            overlay.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                // Don't drag if clicking the cancel button
                if (e.target.classList.contains('order-close-btn')) return;

                e.preventDefault();
                e.stopPropagation();

                overlay.classList.add('dragging');
                const currentPrice = type === 'TP' ? posState.positionTPSL.tpPrice : posState.positionTPSL.slPrice;
                startY = e.clientY;
                startPrice = currentPrice;

                const onMouseMove = (e) => {
                    const deltaY = e.clientY - startY;
                    const currentY = ctx.series.priceToCoordinate(startPrice);
                    const newY = currentY + deltaY;
                    let newPrice = ctx.series.coordinateToPrice(newY);
                    newPrice = roundToTick(newPrice);

                    if (newPrice && newPrice > 0) {
                        // Update stored price
                        if (type === 'TP') {
                            posState.positionTPSL.tpPrice = newPrice;
                            posState.positionTPSL.tpLine.applyOptions({
                                price: newPrice,
                                title: `TP @ ${newPrice.toFixed(2)}`
                            });
                        } else {
                            posState.positionTPSL.slPrice = newPrice;
                            posState.positionTPSL.slLine.applyOptions({
                                price: newPrice,
                                title: `SL @ ${newPrice.toFixed(2)}`
                            });
                        }

                        updateOverlayPosition(overlay, newPrice, ctx);
                        overlay.querySelector('.order-line-label').textContent = `${type} @ ₹${newPrice.toFixed(2)}`;
                    }
                };

                const onMouseUp = () => {
                    overlay.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    const finalPrice = type === 'TP' ? posState.positionTPSL.tpPrice : posState.positionTPSL.slPrice;
                    if (Math.abs(finalPrice - startPrice) > 0.01) {
                        showToast(`${type} moved to ₹${finalPrice.toFixed(2)}`, 'info');
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // Remove TP or SL from position (visual only — no broker orders)
        function removePositionTPSL(type, sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            if (type === 'TP') {
                if (posState.positionTPSL.tpLine) {
                    ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                    posState.positionTPSL.tpLine = null;
                }
                if (posState.positionTPSL.tpOverlay) {
                    posState.positionTPSL.tpOverlay.remove();
                    posState.positionTPSL.tpOverlay = null;
                }
                posState.positionTPSL.tpPrice = null;
                showToast('TP removed', 'info');
            } else {
                if (posState.positionTPSL.slLine) {
                    ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                    posState.positionTPSL.slLine = null;
                }
                if (posState.positionTPSL.slOverlay) {
                    posState.positionTPSL.slOverlay.remove();
                    posState.positionTPSL.slOverlay = null;
                }
                posState.positionTPSL.slPrice = null;
                showToast('SL removed', 'info');
            }
        }

        // Close current position
        async function closePosition(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return;

            try {
                showToast('Closing position...', 'info');

                const qty = parseInt(posState.position.quantity) || 0;
                if (qty === 0) {
                    showToast('No position to close', 'info');
                    return;
                }

                if (posState.position.paper) {
                    const exitPrice = getContextForSide(side)?.currentPrice || 0;
                    recordAutoExit(side, exitPrice, 'Manual Close');
                    clearPositionVisuals(side);
                    return;
                }

                // Cancel TP/SL orders first
                await cancelTPSLOrders(side);

                // Determine opposite action (SELL if long, BUY if short)
                const action = qty > 0 ? 'SELL' : 'BUY';
                const absQty = Math.abs(qty);

                const symbol = getContextForSide(side)?.symbol || state.symbol;
                console.log(`📍 Closing position: ${action} ${absQty} qty of ${symbol}`);

                // Place opposite MARKET order to close position
                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_trading',
                    exchange: state.exchange,
                    symbol: symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showToast('✅ Position closed', 'success');

                    if (posState.position?.auto) {
                        const exitPrice = getContextForSide(side)?.currentPrice || 0;
                        recordAutoExit(side, exitPrice, 'Manual Close', { skipLog: true, skipRealized: true });
                        setTimeout(() => {
                            logLiveExitWithFill({
                                side,
                                symbol,
                                action,
                                qty: absQty,
                                entryPrice: posState.entryPrice || parseFloat(posState.position?.average_price) || 0,
                                reason: 'Manual Close',
                                fallbackPrice: exitPrice
                            });
                        }, 600);
                    }

                    // Clear all visual elements
                    clearPositionVisuals(side);

                    // Refresh position after a delay to confirm closure
                    setTimeout(() => fetchAndDisplayPosition(null, symbol, side), 1000);
                } else {
                    showToast(`❌ Close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error closing position:', error);
                showToast(`❌ Error: ${error.message}`, 'error');
            }
        }

        // Clear virtual TP/SL lines (no broker orders to cancel)
        function cancelTPSLOrders(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            if (posState.positionTPSL.tpLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                posState.positionTPSL.tpLine = null;
            }
            if (posState.positionTPSL.slLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                posState.positionTPSL.slLine = null;
            }
            if (posState.positionTPSL.tpOverlay) {
                posState.positionTPSL.tpOverlay.remove();
                posState.positionTPSL.tpOverlay = null;
            }
            if (posState.positionTPSL.slOverlay) {
                posState.positionTPSL.slOverlay.remove();
                posState.positionTPSL.slOverlay = null;
            }
            posState.positionTPSL.tpPrice = null;
            posState.positionTPSL.slPrice = null;
        }

        // Clear all position visual elements
        function clearPositionVisuals(sideOverride = null) {
            const side = sideOverride || state.activeSide;
            const posState = getPositionState(side);
            const ctx = getContextForSide(side);

            // Remove position line
            if (posState.positionLine) {
                ctx?.series?.removePriceLine(posState.positionLine);
                posState.positionLine = null;
            }
            if (posState.positionOverlay) {
                posState.positionOverlay.remove();
                posState.positionOverlay = null;
            }

            // Remove TP/SL lines
            if (posState.positionTPSL.tpLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.tpLine);
                posState.positionTPSL.tpLine = null;
            }
            if (posState.positionTPSL.slLine) {
                ctx?.series?.removePriceLine(posState.positionTPSL.slLine);
                posState.positionTPSL.slLine = null;
            }
            if (posState.positionTPSL.tpOverlay) {
                posState.positionTPSL.tpOverlay.remove();
                posState.positionTPSL.tpOverlay = null;
            }
            if (posState.positionTPSL.slOverlay) {
                posState.positionTPSL.slOverlay.remove();
                posState.positionTPSL.slOverlay = null;
            }

            // Clear state
            posState.positionTPSL.tpPrice = null;
            posState.positionTPSL.slPrice = null;
            posState.positionTPSL.slTrail = false;
            posState.position = null;
            posState.entryPrice = 0;

            if (side === state.activeSide) {
                state.position = null;
                state.entryPrice = 0;
                document.getElementById('positionQty').textContent = '--';
                document.getElementById('entryPrice').textContent = '--';
                document.getElementById('pnlValue').textContent = '₹0.00';
                document.getElementById('btnClosePosition').classList.add('hidden');
            }
        }

        function getActivePositionPnl() {
            const side = state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return null;
            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return null;
            const ctx = getContextForSide(side);
            const price = ctx?.currentPrice || 0;
            const entry = posState.entryPrice || parseFloat(posState.position.average_price) || 0;
            if (!price || !entry) return null;
            const pnl = (price - entry) * qty;
            return { pnl, qty, price, entry };
        }

        function getActivePositionKey() {
            const side = state.activeSide;
            const posState = getPositionState(side);
            if (!posState.position) return null;
            const qty = parseInt(posState.position.quantity) || 0;
            if (qty === 0) return null;
            const entry = Number.isFinite(posState.entryPrice) && posState.entryPrice > 0
                ? posState.entryPrice
                : (parseFloat(posState.position.average_price) || 0);
            const symbol = posState.position.symbol
                || (side === 'PE' ? state.peSymbol : state.ceSymbol)
                || state.symbol
                || '';
            const entryKey = entry ? entry.toFixed(2) : '0';
            return `${side}|${symbol}|${qty}|${entryKey}`;
        }

        // Update position P&L in real-time
        setInterval(() => {
            const snapshot = getActivePositionPnl();
            if (!snapshot) return;

            const pnl = snapshot.pnl;
            state.totalPnl = pnl;

            // Update top panel
            const pnlElement = document.getElementById('pnlValue');
            pnlElement.textContent = `₹${pnl.toFixed(2)}`;
            pnlElement.className = `pnl-display ${pnl >= 0 ? 'price-positive' : 'price-negative'}`;

            // Update position line P&L label
            const pnlLabel = document.getElementById(`positionPnlLabel_${state.activeSide}`);
            if (pnlLabel) {
                pnlLabel.textContent = `₹${pnl.toFixed(2)}`;
                pnlLabel.className = pnl >= 0 ? 'pnl-label profit' : 'pnl-label loss';
            }

            // Check profit protection
            if (state.profitProtectionEnabled) {
                checkProfitProtection();
            }
        }, 500);

        // ========== PROFIT PROTECTION SYSTEM ==========

        function toggleProfitProtection() {
            const checkbox = document.getElementById('enableProfitProtection');
            state.profitProtectionEnabled = checkbox.checked;

            const securedDisplay = document.getElementById('securedProfitDisplay');

            if (checkbox.checked) {
                securedDisplay.style.display = 'inline';

                // Reset protection state
                state.currentProtectionLevel = -1;
                state.securedProfit = 0;
                state.breakevenActivated = false;
                state.highestPnl = 0;

                updateProfitProtectionUI();
                showToast('🛡️ Profit Protection enabled', 'success');
            } else {
                securedDisplay.style.display = 'none';
                showToast('🛡️ Profit Protection disabled', 'info');
            }
        }

        function updateProfitProtectionUI() {
            const securedValue = document.getElementById('securedProfitValue');
            if (securedValue) {
                securedValue.textContent = `₹${state.securedProfit.toFixed(0)}`;
            }
        }

        function checkProfitProtection() {
            if (!state.profitProtectionEnabled || state.totalPnl <= 0 || state.isClosingPosition) return;

            // Check breakeven activation
            if (!state.breakevenActivated && state.totalPnl >= state.breakevenThreshold) {
                state.breakevenActivated = true;
                state.securedProfit = 0;
                console.log(`🟢 Breakeven activated at ₹${state.totalPnl.toFixed(2)}`);
                showToast('🟢 Breakeven activated!', 'success');
            }

            // Check profit protection levels
            for (let i = state.profitProtectionLevels.length - 1; i >= 0; i--) {
                const level = state.profitProtectionLevels[i];

                if (state.totalPnl >= level.trigger && i > state.currentProtectionLevel) {
                    state.currentProtectionLevel = i;
                    state.securedProfit = level.trigger * (level.lockPercent / 100);

                    console.log(`🛡️ Protection Level ${i + 1}: Secured ₹${state.securedProfit.toFixed(0)}`);
                    showToast(`🛡️ Secured ₹${state.securedProfit.toFixed(0)} profit!`, 'success');
                    break;
                }
            }

            // Check if we should close due to profit protection
            if (state.securedProfit > 0 && state.totalPnl <= state.securedProfit) {
                console.log(`🛡️ Profit Protection triggered! P&L ₹${state.totalPnl.toFixed(2)} <= Secured ₹${state.securedProfit.toFixed(0)}`);
                showToast(`🛡️ Closing to secure ₹${state.securedProfit.toFixed(0)}`, 'success');
                closePositionAuto('Profit Protection');
                return;
            }

            // Check breakeven stop
            if (state.breakevenActivated && state.totalPnl <= 0) {
                console.log(`🛡️ Breakeven Stop triggered!`);
                showToast('🛡️ Breakeven Stop! Closing position', 'info');
                closePositionAuto('Breakeven Stop');
                return;
            }

            updateProfitProtectionUI();
        }

        async function closePositionAuto(reason) {
            if (state.isClosingPosition || !state.position) return;

            state.isClosingPosition = true;
            state.profitProtectionEnabled = false;
            document.getElementById('enableProfitProtection').checked = false;

            console.log(`🚨 Auto-closing position: ${reason}`);

            try {
                const qty = parseInt(state.position.quantity) || 0;
                if (qty === 0) {
                    state.isClosingPosition = false;
                    return;
                }

                if (state.position?.paper) {
                    const exitPrice = getContextForSide(state.activeSide)?.currentPrice || 0;
                    recordAutoExit(state.activeSide, exitPrice, reason);
                    clearPositionVisuals();
                    resetProfitProtection();
                    state.isClosingPosition = false;
                    return;
                }

                // Cancel TP/SL orders first
                await cancelTPSLOrders();

                const action = qty > 0 ? 'SELL' : 'BUY';
                const absQty = Math.abs(qty);

                const orderData = {
                    apikey: state.apiKey,
                    strategy: 'chart_protection',
                    exchange: state.exchange,
                    symbol: state.symbol,
                    action: action,
                    quantity: String(absQty),
                    pricetype: 'MARKET',
                    product: 'MIS',
                    price: '0',
                    trigger_price: '0',
                    disclosed_quantity: '0'
                };

                const response = await fetch('/api/v1/placeorder', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(orderData)
                });

                const result = await response.json();

                if (result.status === 'success') {
                    showToast(`✅ Position closed: ${reason}`, 'success');
                    if (state.position?.auto) {
                        const exitPrice = getContextForSide(state.activeSide)?.currentPrice || 0;
                        recordAutoExit(state.activeSide, exitPrice, reason, { skipLog: true, skipRealized: true });
                        setTimeout(() => {
                            const side = state.activeSide;
                            const qtyVal = Math.abs(parseInt(state.position?.quantity) || 0);
                            const action = qty > 0 ? 'SELL' : 'BUY';
                            logLiveExitWithFill({
                                side,
                                symbol: state.symbol,
                                action,
                                qty: qtyVal,
                                entryPrice: state.entryPrice || parseFloat(state.position?.average_price) || 0,
                                reason,
                                fallbackPrice: exitPrice
                            });
                        }, 600);
                    }
                    clearPositionVisuals();
                    resetProfitProtection();
                } else {
                    showToast(`❌ Close failed: ${result.message}`, 'error');
                }
            } catch (error) {
                console.error('Error closing position:', error);
                showToast(`❌ Error: ${error.message}`, 'error');
            } finally {
                setTimeout(() => {
                    state.isClosingPosition = false;
                    fetchAndDisplayPosition();
                }, 2000);
            }
        }

        function resetProfitProtection() {
            state.currentProtectionLevel = -1;
            state.securedProfit = 0;
            state.breakevenActivated = false;
            state.highestPnl = 0;
            state.totalPnl = 0;

            const securedDisplay = document.getElementById('securedProfitDisplay');
            if (securedDisplay) {
                securedDisplay.style.display = 'none';
            }
        }

        // ========== PHASE 3: PRICE STALENESS DETECTION ==========

        let lastPriceUpdate = 0;
        let lastStaleness = null;

        function updatePriceTimestamp() {
            lastPriceUpdate = Date.now();
        }

        function getPriceStaleness() {
            if (!lastPriceUpdate) return 'unknown';

            const staleness = Date.now() - lastPriceUpdate;
            if (staleness > 10000) return 'stale';      // > 10 seconds
            if (staleness > 5000) return 'delayed';     // > 5 seconds
            return 'live';
        }

        function isPriceStale() {
            return getPriceStaleness() === 'stale';
        }

        // Update price staleness indicator
        function updatePriceStalenessUI() {
            const priceEl = ui.currentPrice;
            if (!priceEl) return;

            ensureCurrentPriceValue();

            const staleness = getPriceStaleness();
            if (staleness === lastStaleness) return;
            lastStaleness = staleness;
            priceEl.classList.remove('price-live', 'price-delayed', 'price-stale');
            priceEl.classList.add(`price-${staleness}`);

            // Add visual indicator
            let indicator = priceEl.querySelector('.staleness-indicator');
            if (!indicator) {
                indicator = document.createElement('span');
                indicator.className = 'staleness-indicator';
                indicator.style.cssText = 'font-size: 8px; margin-left: 5px;';
                priceEl.appendChild(indicator);
            }

            if (staleness === 'live') {
                indicator.textContent = '🟢';
                indicator.title = 'Live price';
            } else if (staleness === 'delayed') {
                indicator.textContent = '🟡';
                indicator.title = 'Price delayed (>5s)';
            } else if (staleness === 'stale') {
                indicator.textContent = '🔴';
                indicator.title = 'Price stale (>10s)';
            }
        }

        // Check staleness every second
        setInterval(updatePriceStalenessUI, 1000);

        // ========== PHASE 4: ORDER VALIDATION ==========

        const ORDER_LIMITS = {
            maxQuantity: 50,           // Max lots per order
            maxDailyLoss: 10000,       // Max daily loss in rupees
            maxOrderValue: 500000,     // Max order value in rupees
            priceDeviationLimit: 0.5,  // Max 50% deviation from current price
            minPrice: 0.5,             // Minimum option price
            maxPrice: 50000            // Maximum option price
        };

        let dailyPnL = 0;

        function validateOrder(orderData, currentPrice) {
            const errors = [];
            const warnings = [];

            // 1. Quantity validation
            const lots = parseInt(orderData.quantity) / (state.lotSize || 15);
            if (lots > ORDER_LIMITS.maxQuantity) {
                errors.push(`Quantity ${lots} lots exceeds max ${ORDER_LIMITS.maxQuantity} lots`);
            }

            // 2. Price validation for limit orders
            if (orderData.pricetype === 'LIMIT') {
                const price = parseFloat(orderData.price);

                if (price < ORDER_LIMITS.minPrice) {
                    errors.push(`Price ₹${price} below minimum ₹${ORDER_LIMITS.minPrice}`);
                }

                if (price > ORDER_LIMITS.maxPrice) {
                    errors.push(`Price ₹${price} exceeds maximum ₹${ORDER_LIMITS.maxPrice}`);
                }

                // Check deviation from current price
                if (currentPrice > 0) {
                    const deviation = Math.abs(price - currentPrice) / currentPrice;
                    if (deviation > ORDER_LIMITS.priceDeviationLimit) {
                        warnings.push(`Price ₹${price} is ${(deviation * 100).toFixed(0)}% away from current ₹${currentPrice}`);
                    }
                }
            }

            // 3. Daily loss limit check
            if (dailyPnL < -ORDER_LIMITS.maxDailyLoss) {
                errors.push(`Daily loss limit (₹${ORDER_LIMITS.maxDailyLoss}) exceeded`);
            }

            // 4. Stale price check
            if (isPriceStale()) {
                warnings.push('Price data is stale (>10s old)');
            }

            return { errors, warnings, isValid: errors.length === 0 };
        }

        // ========== PHASE 4: AUDIT TRAIL ==========

        const auditTrail = [];
        const MAX_AUDIT_ENTRIES = 500;

        const autoTradeLog = [];
        const MAX_AUTO_LOG_ENTRIES = 300;
        const autoLogIds = new Set();
        const autoLogQueue = [];
        const MAX_AUTO_LOG_QUEUE = 400;
        const AUTO_LOG_FLUSH_MS = 1200;
        let autoLogFlushTimer = null;

        function generateEventId() {
            if (window.crypto && typeof window.crypto.randomUUID === 'function') {
                return window.crypto.randomUUID();
            }
            return `evt_${Date.now()}_${Math.random().toString(16).slice(2)}`;
        }

        function getAutoLogKey() {
            const base = state.ceSymbol || state.peSymbol || state.symbol || 'auto';
            const day = new Date().toISOString().split('T')[0];
            return `auto_trade_log_${base}_${day}`;
        }

        function queueAutoTradeLog(entry) {
            if (!entry) return;
            autoLogQueue.push(entry);
            if (autoLogQueue.length > MAX_AUTO_LOG_QUEUE) {
                autoLogQueue.shift();
            }
            if (!autoLogFlushTimer) {
                autoLogFlushTimer = setTimeout(flushAutoTradeLogs, AUTO_LOG_FLUSH_MS);
            }
        }

        function flushAutoTradeLogs() {
            autoLogFlushTimer = null;
            if (!autoLogQueue.length) return;
            const batch = autoLogQueue.splice(0, 60);
            const payload = JSON.stringify({ events: batch });
            try {
                if (navigator.sendBeacon) {
                    const ok = navigator.sendBeacon('/ai_scalper/logs', new Blob([payload], { type: 'application/json' }));
                    if (!ok) {
                        throw new Error('Beacon failed');
                    }
                } else {
                    fetch('/ai_scalper/logs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: payload,
                        keepalive: true
                    }).catch(() => { });
                }
            } catch (e) {
                // Requeue on failure (cap size)
                autoLogQueue.unshift(...batch);
                if (autoLogQueue.length > MAX_AUTO_LOG_QUEUE) {
                    autoLogQueue.length = MAX_AUTO_LOG_QUEUE;
                }
            }
            if (autoLogQueue.length) {
                autoLogFlushTimer = setTimeout(flushAutoTradeLogs, AUTO_LOG_FLUSH_MS);
            }
        }

        function logAutoTrade(event) {
            const entry = {
                ts: new Date().toISOString(),
                ...event
            };
            if (!entry.eventId) entry.eventId = generateEventId();
            if (!entry.source) entry.source = 'local';
            if (!entry.underlying && state.underlying) entry.underlying = state.underlying;
            if (!entry.exchange && state.underlyingExchange) entry.exchange = state.underlyingExchange;
            if (autoLogIds.has(entry.eventId)) return entry;
            autoLogIds.add(entry.eventId);
            autoTradeLog.push(entry);
            if (autoTradeLog.length > MAX_AUTO_LOG_ENTRIES) {
                autoTradeLog.shift();
            }
            renderAutoTradeLog();
            queueAutoTradeLog(entry);
            return entry;
        }

        function renderAutoTradeLog() {
            if (!autoUi.logList) return;
            const items = autoTradeLog.slice(-20).reverse();
            if (!items.length) {
                autoUi.logList.innerHTML = '<div class="auto-log-item">No auto trades yet</div>';
                return;
            }
            autoUi.logList.innerHTML = '';
            const frag = document.createDocumentFragment();
            items.forEach(item => {
                const row = document.createElement('div');
                row.className = 'auto-log-item';
                const tags = [];
                if (item.type) tags.push(`<span class="tag">${item.type}</span>`);
                if (item.mode) tags.push(`<span class="tag">${item.mode}</span>`);
                const parts = [
                    ...tags,
                    item.side ? `${item.side}` : '',
                    item.symbol ? `${item.symbol}` : '',
                    item.action ? `${item.action}` : '',
                    item.qty ? `Qty ${item.qty}` : '',
                    Number.isFinite(item.price) ? `@ ${item.price.toFixed(2)}` : '',
                    item.tpPoints ? `TP ${item.tpPoints}` : '',
                    item.slPoints ? `SL ${item.slPoints}` : '',
                    item.reason ? `(${item.reason})` : '',
                    item.pnl != null ? `PnL ${item.pnl >= 0 ? '+' : ''}${Number(item.pnl).toFixed(0)}` : ''
                ].filter(Boolean);
                row.innerHTML = parts.join(' ');
                frag.appendChild(row);
            });
            autoUi.logList.appendChild(frag);
        }

        function exportAutoTradeLog() {
            const data = JSON.stringify(autoTradeLog, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `auto_trade_log_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Auto trade log exported', 'success');
        }

        async function exportAutoTradeLogDb() {
            try {
                const params = new URLSearchParams({ limit: '2000' });
                const mode = autoUi.logModeFilter?.value || '';
                if (mode) params.set('mode', mode);
                if (state.underlying) params.set('underlying', state.underlying);
                const response = await fetch(`/ai_scalper/logs?${params.toString()}`);
                if (!response.ok) throw new Error('Fetch failed');
                const data = await response.json();
                const logs = data.logs || [];
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `auto_trade_log_db_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('DB auto trade log exported', 'success');
            } catch (e) {
                showToast('DB export failed', 'error');
            }
        }

        function resetAutoTradeLogView() {
            autoTradeLog.length = 0;
            autoLogIds.clear();
            renderAutoTradeLog();
        }

        async function loadAutoTradeLog(options = {}) {
            const { reset = false } = options || {};
            if (reset) {
                resetAutoTradeLogView();
            }
            try {
                const params = new URLSearchParams({ limit: '120' });
                const mode = autoUi.logModeFilter?.value || '';
                if (mode) params.set('mode', mode);
                if (state.underlying) params.set('underlying', state.underlying);
                const response = await fetch(`/ai_scalper/logs?${params.toString()}`);
                if (!response.ok) throw new Error('Fetch failed');
                const data = await response.json();
                const logs = data.logs || [];
                logs.reverse().forEach(entry => {
                    const eventId = entry.eventId || entry.event_id || generateEventId();
                    if (autoLogIds.has(eventId)) return;
                    autoLogIds.add(eventId);
                    autoTradeLog.push({
                        ...entry,
                        eventId,
                        ts: entry.ts || entry.ts_iso || new Date().toISOString()
                    });
                });
            } catch (e) {
                // Ignore if server not ready
            }
            renderAutoTradeLog();
        }

        let learningReplayTrades = [];
        let learningPollTimer = null;

        function renderLearningUnavailable(message = 'Server agent required') {
            if (autoUi.learningArms) {
                autoUi.learningArms.innerHTML = `<div class="auto-log-item">${message}</div>`;
            }
            if (autoUi.learningTradesList) {
                autoUi.learningTradesList.innerHTML = `<div class="auto-log-item">${message}</div>`;
            }
            if (autoUi.learningReplayOutput) {
                autoUi.learningReplayOutput.innerHTML = `<div class="auto-log-item">${message}</div>`;
            }
        }

        function renderLearningSummary(summary) {
            if (!summary) return;
            if (autoUi.learningTotal) autoUi.learningTotal.textContent = summary.total ?? '--';
            if (autoUi.learningWinRate) autoUi.learningWinRate.textContent = summary.win_rate != null ? `${summary.win_rate.toFixed(1)}%` : '--';
            if (autoUi.learningAvgPnl) autoUi.learningAvgPnl.textContent = summary.avg_pnl != null ? summary.avg_pnl.toFixed(1) : '--';
            if (autoUi.learningProfitFactor) autoUi.learningProfitFactor.textContent = summary.profit_factor != null ? summary.profit_factor.toFixed(2) : '--';
            if (autoUi.learningMaxDd) autoUi.learningMaxDd.textContent = summary.max_drawdown != null ? summary.max_drawdown.toFixed(0) : '--';
            if (autoUi.learningSumPnl) autoUi.learningSumPnl.textContent = summary.sum_pnl != null ? summary.sum_pnl.toFixed(0) : '--';
        }

        function renderLearningArms(trades) {
            if (!autoUi.learningArms) return;
            if (!trades || !trades.length) {
                autoUi.learningArms.innerHTML = '<div class="auto-log-item">No learning trades yet</div>';
                return;
            }
            const stats = {};
            trades.forEach(t => {
                const arm = t.arm_id || 'base';
                if (!stats[arm]) stats[arm] = { trades: 0, pnl: 0 };
                stats[arm].trades += 1;
                stats[arm].pnl += Number(t.pnl || 0);
            });
            const rows = Object.entries(stats)
                .sort((a, b) => b[1].pnl - a[1].pnl)
                .map(([arm, s]) => `<div class="auto-log-item"><span class="tag">${arm}</span> Trades ${s.trades} PnL ${s.pnl.toFixed(0)}</div>`);
            autoUi.learningArms.innerHTML = rows.join('') || '<div class="auto-log-item">No arm stats</div>';
        }

        function renderLearningTrades(trades) {
            if (!autoUi.learningTradesList) return;
            if (!trades || !trades.length) {
                autoUi.learningTradesList.innerHTML = '<div class="auto-log-item">No trades yet</div>';
                return;
            }
            const rows = trades.slice(0, 15).map(t => {
                const side = t.side || '?';
                const mode = t.mode ? String(t.mode).toUpperCase() : '';
                const entry = Number.isFinite(t.entry_price) ? `E ${Number(t.entry_price).toFixed(2)}` : '';
                const exit = Number.isFinite(t.exit_price) ? `X ${Number(t.exit_price).toFixed(2)}` : '';
                const pnl = t.pnl != null ? `PnL ${Number(t.pnl) >= 0 ? '+' : ''}${Number(t.pnl).toFixed(0)}` : '';
                const reason = t.reason ? `(${t.reason})` : '';
                const playbook = t.playbook ? `[${t.playbook}]` : '';
                const tags = [
                    `<span class="tag">${side}</span>`,
                    mode ? `<span class="tag">${mode}</span>` : ''
                ].filter(Boolean);
                const parts = [
                    ...tags,
                    t.symbol || '',
                    entry,
                    exit,
                    pnl,
                    reason,
                    playbook
                ].filter(Boolean);
                return `<div class="auto-log-item">${parts.join(' ')}</div>`;
            });
            autoUi.learningTradesList.innerHTML = rows.join('') || '<div class="auto-log-item">No trades yet</div>';
        }

        async function fetchLearningSummary() {
            if (!autoState.serverMode) {
                renderLearningUnavailable('Enable Server Agent for learning');
                return;
            }
            try {
                const response = await fetch('/ai_scalper/learning/summary');
                if (!response.ok) return;
                const summary = await response.json();
                renderLearningSummary(summary);
            } catch (e) {
                // ignore
            }
        }

        async function refreshLearningDashboard() {
            if (!autoState.serverMode) {
                renderLearningUnavailable('Enable Server Agent for learning');
                return;
            }
            try {
                const [summaryResp, tradesResp] = await Promise.all([
                    fetch('/ai_scalper/learning/summary'),
                    fetch('/ai_scalper/learning/trades?limit=400')
                ]);
                if (summaryResp.ok) {
                    const summary = await summaryResp.json();
                    renderLearningSummary(summary);
                }
                if (tradesResp.ok) {
                    const data = await tradesResp.json();
                    const trades = data.trades || [];
                    renderLearningArms(trades);
                    renderLearningTrades(trades);
                }
            } catch (e) {
                // ignore
            }
        }

        function analyzeReplay(trades) {
            const byPlaybook = {};
            const byHour = {};
            trades.forEach(t => {
                const pb = t.playbook || 'unknown';
                if (!byPlaybook[pb]) byPlaybook[pb] = { trades: 0, pnl: 0 };
                byPlaybook[pb].trades += 1;
                byPlaybook[pb].pnl += Number(t.pnl || 0);
                const ts = t.ts_exit || t.ts_entry;
                if (ts) {
                    const d = new Date(ts * 1000);
                    const hour = `${String(d.getHours()).padStart(2, '0')}:00`;
                    if (!byHour[hour]) byHour[hour] = { trades: 0, pnl: 0 };
                    byHour[hour].trades += 1;
                    byHour[hour].pnl += Number(t.pnl || 0);
                }
            });
            return { byPlaybook, byHour };
        }

        function renderReplay(trades) {
            if (!autoUi.learningReplayOutput) return;
            if (!trades || !trades.length) {
                autoUi.learningReplayOutput.innerHTML = '<div class="auto-log-item">No trades for replay</div>';
                return;
            }
            const analysis = analyzeReplay(trades);
            const playbookRows = Object.entries(analysis.byPlaybook)
                .sort((a, b) => b[1].pnl - a[1].pnl)
                .map(([pb, s]) => `<div class="auto-log-item"><span class="tag">${pb}</span> Trades ${s.trades} PnL ${s.pnl.toFixed(0)}</div>`);
            const hourRows = Object.entries(analysis.byHour)
                .sort((a, b) => a[0].localeCompare(b[0]))
                .map(([hour, s]) => `<div class="auto-log-item"><span class="tag">${hour}</span> Trades ${s.trades} PnL ${s.pnl.toFixed(0)}</div>`);
            autoUi.learningReplayOutput.innerHTML = [
                '<div class="auto-log-item"><span class="tag">Playbooks</span></div>',
                ...playbookRows,
                '<div class="auto-log-item"><span class="tag">By Hour</span></div>',
                ...hourRows
            ].join('');
        }

        async function runReplay() {
            if (!autoState.serverMode) {
                renderLearningUnavailable('Enable Server Agent for replay');
                return;
            }
            const limit = clampNumber(autoUi.learningReplayLimit?.value, 50, 1000, 300);
            if (autoUi.learningReplayLimit) autoUi.learningReplayLimit.value = String(limit);
            try {
                const response = await fetch('/ai_scalper/learning/trades?limit=' + limit);
                if (!response.ok) return;
                const data = await response.json();
                learningReplayTrades = data.trades || [];
                renderReplay(learningReplayTrades);
            } catch (e) {
                // ignore
            }
        }

        function exportLearningReplay() {
            if (!learningReplayTrades.length) {
                showToast('Replay is empty', 'info');
                return;
            }
            const headers = ['id', 'ts_entry', 'ts_exit', 'side', 'symbol', 'quantity', 'entry_price', 'exit_price', 'pnl', 'reason', 'playbook', 'arm_id', 'mode'];
            const rows = [headers.join(',')];
            learningReplayTrades.forEach(t => {
                const row = headers.map(h => {
                    const val = t[h] != null ? String(t[h]).replace(/"/g, '""') : '';
                    return `"${val}"`;
                });
                rows.push(row.join(','));
            });
            const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_scalper_replay_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Replay exported', 'success');
        }

        function startLearningPoll() {
            stopLearningPoll();
            learningPollTimer = setInterval(fetchLearningSummary, 10000);
            fetchLearningSummary();
        }

        function stopLearningPoll() {
            if (learningPollTimer) {
                clearInterval(learningPollTimer);
                learningPollTimer = null;
            }
        }

        function logAuditEntry(action, details) {
            const entry = {
                timestamp: new Date().toISOString(),
                action: action,
                details: details,
                symbol: state.symbol
            };

            auditTrail.push(entry);

            // Keep only last N entries
            if (auditTrail.length > MAX_AUDIT_ENTRIES) {
                auditTrail.shift();
            }

            // Persist to localStorage
            try {
                const key = `chart_audit_${state.symbol}`;
                localStorage.setItem(key, JSON.stringify(auditTrail.slice(-50)));
            } catch (e) {
                // Storage full, ignore
            }

            return entry;
        }

        function logOrderPlaced(orderData, result) {
            return logAuditEntry('ORDER_PLACED', {
                action: orderData.action,
                quantity: orderData.quantity,
                pricetype: orderData.pricetype,
                price: orderData.price,
                orderId: result.orderid,
                status: result.status
            });
        }

        function logPositionClosed(qty, pnl, reason) {
            return logAuditEntry('POSITION_CLOSED', {
                quantity: qty,
                pnl: pnl,
                reason: reason
            });
        }

        function logProfitProtectionTriggered(level, securedProfit) {
            return logAuditEntry('PROFIT_PROTECTION', {
                level: level,
                securedProfit: securedProfit
            });
        }

        function exportAuditTrail() {
            const data = JSON.stringify(auditTrail, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `chart_audit_${state.symbol}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();

            URL.revokeObjectURL(url);
            showToast('Audit trail exported', 'success');
        }

        // Load audit trail from localStorage
        function loadAuditTrail() {
            try {
                const key = `chart_audit_${state.symbol}`;
                const saved = localStorage.getItem(key);
                if (saved) {
                    const entries = JSON.parse(saved);
                    auditTrail.push(...entries);
                }
            } catch (e) {
                console.error('Failed to load audit trail:', e);
            }
        }

        // ========== PHASE 5: EXIT DECISION HELPER ==========

        function analyzeExitDecision(currentPnl, entryPrice, currentPrice, timeInPosition) {
            const analysis = {
                momentum: 'neutral',
                suggestion: 'HOLD',
                reason: '',
                actions: []
            };

            // Calculate momentum
            const priceChange = ((currentPrice - entryPrice) / entryPrice) * 100;

            if (priceChange > 5) analysis.momentum = 'strong_up';
            else if (priceChange > 2) analysis.momentum = 'up';
            else if (priceChange < -5) analysis.momentum = 'strong_down';
            else if (priceChange < -2) analysis.momentum = 'down';

            // Time-based analysis
            const now = new Date();
            const hours = now.getHours();
            const day = now.getDay();

            const isExpiryDay = day === 4;
            const isLateSession = hours >= 14;
            const isClosingHour = hours >= 15;

            // Generate suggestion
            if (currentPnl > 0) {
                if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing - book profits';
                    analysis.actions = ['Exit Now', 'Trail Tight'];
                } else if (isExpiryDay && isLateSession) {
                    analysis.suggestion = 'TRAIL';
                    analysis.reason = 'Expiry day - use tight trailing stop';
                    analysis.actions = ['Trail +3', 'Trail +5', 'Exit 50%'];
                } else if (analysis.momentum === 'strong_up') {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Strong momentum - let it ride';
                    analysis.actions = ['Trail +5', 'Trail +10', 'Exit 50%'];
                } else {
                    analysis.suggestion = 'HOLD';
                    analysis.reason = 'Position in profit - monitor';
                    analysis.actions = ['Trail +5', 'Exit 50%', 'Hold'];
                }
            } else {
                if (currentPnl < -2000) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Significant loss - cut position';
                    analysis.actions = ['Exit Now', 'Exit 50%'];
                } else if (isClosingHour) {
                    analysis.suggestion = 'EXIT';
                    analysis.reason = 'Market closing - avoid overnight risk';
                    analysis.actions = ['Exit Now'];
                } else {
                    analysis.suggestion = 'REVIEW';
                    analysis.reason = 'Position in loss - review thesis';
                    analysis.actions = ['Exit Now', 'Hold', 'Set SL'];
                }
            }

            return analysis;
        }

        // ========== PHASE 5: LOSS AVERSION COUNTERMEASURES ==========

        const LOSS_LIMITS = {
            warningThreshold: 1000,
            criticalThreshold: 2000,
            autoExitThreshold: 3000,
            maxTimeInLoss: 10 * 60 * 1000
        };

        let lossWarningShown = false;
        let lossTimerStarted = null;
        let autoExitTimer = null;
        let lossPositionKey = null;

        function resetLossAversionState() {
            lossWarningShown = false;
            lossTimerStarted = null;
            if (autoExitTimer) {
                clearTimeout(autoExitTimer);
                autoExitTimer = null;
            }
            hideLossWarning();
        }

        function checkLossAversion(currentPnl) {
            if (currentPnl >= 0) {
                resetLossAversionState();
                return;
            }

            const loss = Math.abs(currentPnl);

            if (!lossTimerStarted) {
                lossTimerStarted = Date.now();
            }

            // Auto-exit threshold
            if (loss >= LOSS_LIMITS.autoExitThreshold) {
                showLossWarning('critical', loss);
                if (!autoExitTimer) {
                    autoExitTimer = setTimeout(() => {
                        console.log('🚨 AUTO-EXIT: Loss limit reached');
                        showToast('🚨 Auto-exit triggered', 'error');
                        closePosition();
                        logAuditEntry('AUTO_EXIT', { reason: 'loss_limit', loss: loss });
                    }, 5000);
                }
                return;
            }

            // Critical warning
            if (loss >= LOSS_LIMITS.criticalThreshold) {
                showLossWarning('critical', loss);
                return;
            }

            // Warning threshold
            if (loss >= LOSS_LIMITS.warningThreshold && !lossWarningShown) {
                lossWarningShown = true;
                showLossWarning('warning', loss);
            }
        }

        function showLossWarning(type, loss) {
            let existing = document.getElementById('lossWarningBanner');

            const messages = {
                warning: `⚠️ Position at -₹${loss.toFixed(0)} | Review your thesis`,
                critical: `🚨 CRITICAL: -₹${loss.toFixed(0)} | Consider exiting NOW`
            };

            const bannerHtml = `
                <div class="loss-warning-banner ${type}" id="lossWarningBanner">
                    <span class="loss-message">${messages[type]}</span>
                    <div class="loss-actions">
                        <button onclick="closePosition()" class="loss-exit-btn">Exit Now</button>
                        <button onclick="hideLossWarning()" class="loss-dismiss-btn">Dismiss</button>
                    </div>
                </div>
            `;

            if (existing) {
                existing.outerHTML = bannerHtml;
            } else {
                document.body.insertAdjacentHTML('afterbegin', bannerHtml);
            }

            // Play alert sound for critical
            if (type === 'critical') {
                try {
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleQAA');
                    audio.volume = 0.3;
                    audio.play().catch(() => { });
                } catch (e) { }
            }
        }

        function hideLossWarning() {
            const banner = document.getElementById('lossWarningBanner');
            if (banner) banner.remove();
        }

        // Check loss aversion every second when in position
        setInterval(() => {
            const snapshot = getActivePositionPnl();
            const key = getActivePositionKey();

            if (!snapshot || !key) {
                if (lossPositionKey) {
                    lossPositionKey = null;
                    resetLossAversionState();
                }
                return;
            }

            if (lossPositionKey !== key) {
                lossPositionKey = key;
                resetLossAversionState();
            }

            if (getPriceStaleness() !== 'live') return;
            checkLossAversion(snapshot.pnl);
        }, 1000);

        // Monitor for external position closures (from mobile app, etc.)
        let lastPositionCheck = 0;
        setInterval(async () => {
            // Only check if we have an active position
            if (!state.position) return;
            if (autoState.paperMode) {
                return;
            }

            // Throttle checks to every 3 seconds
            const now = Date.now();
            if (now - lastPositionCheck < 3000) return;
            lastPositionCheck = now;

            try {
                const response = await fetch('/api/v1/positionbook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ apikey: state.apiKey })
                });

                const result = await response.json();

                if (result.status === 'success' && result.data) {
                    const position = result.data.find(p => p.symbol === state.symbol);
                    const qty = position ? parseInt(position.quantity) || 0 : 0;

                    // If position was closed externally (qty is now 0)
                    if (qty === 0 && state.position) {
                        console.log('🔔 Position closed externally - cleaning up TP/SL orders');
                        showToast('Position closed externally', 'info');

                        // Cancel TP/SL orders
                        await cancelTPSLOrders();

                        // Clear all visuals
                        clearPositionVisuals();
                    }
                }
            } catch (error) {
                // Silently handle errors to avoid spam
                console.error('Error checking position:', error.message);
            }
        }, 1000); // Check every second, but throttled to 3 seconds

        // ========== END OPEN ORDERS PANEL ==========

        // Initialize
        async function init() {
            // Fetch exact WebSocket URL from server config (overrides port-derived default)
            try {
                const configResp = await fetch('/scalping/config');
                const configData = await configResp.json();
                if (configData.wsUrl) {
                    CONFIG.wsUrl = configData.wsUrl;
                }
                console.log('WebSocket URL:', CONFIG.wsUrl);
            } catch (e) {
                console.warn('Config fetch failed, using derived WebSocket URL:', CONFIG.wsUrl);
            }

            // Allow URL param override for mock/replay testing
            const urlWs = new URLSearchParams(window.location.search).get('wsUrl');
            if (urlWs) {
                CONFIG.wsUrl = urlWs;
                console.log('WebSocket URL overridden via URL param:', CONFIG.wsUrl);
            }

            // Detect mock mode (replay server on port 8770 or wsUrl contains 'mock')
            const isMockMode = CONFIG.wsUrl.includes(':8770') || CONFIG.wsUrl.toLowerCase().includes('mock');
            state.isMockMode = isMockMode;
            if (isMockMode) {
                console.log('🎬 Mock mode detected - disabling data stall check and enabling paper mode');
                // Force paper mode in mock mode (no live broker API available)
                autoState.paperMode = true;
                setTimeout(() => {
                    const paperToggle = document.getElementById('autoPaperToggle');
                    if (paperToggle) {
                        paperToggle.checked = true;
                        paperToggle.disabled = true; // Prevent unchecking in mock mode
                    }
                }, 100);
            }

            parseUrlParams();
            console.log('After parseUrlParams - symbol:', state.symbol, 'ce:', state.ceSymbol, 'pe:', state.peSymbol);
            initAutoPanel();
            initDepthPanel();

            if (!state.symbol) {
                showToast('Open with symbol params (CE/PE) to start', 'info');
                const loading = document.getElementById('loading');
                if (loading) {
                    loading.innerHTML = '<p style="margin-top: 10px;">Waiting for symbol parameters...</p>';
                }
                return;
            }

            initChart();
            setupEventListeners();
            setupChartInteraction(); // Enable cursor tracking
            initTooltipHints();
            connectWebSocket();
            fetchOpenOrders(); // Load open orders immediately
            fetchAndDisplayPosition(); // Load any existing position

            console.log('Chart window initialized for:', state.symbol);
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>

</html>